【文章标题】：[求助]请推荐本操作系统的书 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1831 【创建时间】：2008-10-26 【作者】：xiaokaimail 【评论】：2 【内容】：发信人: xiaokaimail (King), 信区: Embedded_System
标  题: [求助]请推荐本操作系统的书
发信站: 北邮人论坛 (Sun Oct 26 16:36:24 2008), 站内

本科没学过操作系统，现在想学嵌入式，是不是应该学一下操作系统
是直接学习嵌入式操作系统呢，还是先学一下操作系统原理
大家能不能给推荐一本操作系统方面的经典书籍

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.133.*]
 
【文章标题】：[售]《MSP430单片机C语言应用程序设计实例精讲》 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1858 【创建时间】：2008-10-26 【作者】：mc34 【评论】：0 【内容】：发信人: mc34 (mmcc), 信区: Embedded_System
标  题: [售]《MSP430单片机C语言应用程序设计实例精讲》
发信站: 北邮人论坛 (Sun Oct 26 22:01:41 2008), 站内

《MSP430单片机C语言应用程序设计实例精讲》，没光盘，42.00。20米。 
书简介见 <a target="_blank" href="http://www.amazon.cn/dp/zjbk325705">http://www.amazon.cn/dp/zjbk325705</a> 
《离散数学》，耿素云 屈婉玲 编著，高教出版社，26.70。12米。 
《离散数学结构（第四版 影印版）》，Bernard Kolman 等，高教出版社，29.50。15米。
--
莱萨魔，天要掉下来了～～
别唧歪癞癞虫，那只是天上的星星！

※ 修改:·mc34 于 Oct 26 22:02:27 修改本文·[FROM: 59.64.184.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.184.*]
 
【文章标题】：学习嵌入式前，一定要先弄会单片机吗？？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/243 【创建时间】：2008-05-13 【作者】：staywithyou 【评论】：1 【内容】：发信人: staywithyou (太阳月亮), 信区: Embedded_System
标  题: 学习嵌入式前，一定要先弄会单片机吗？？
发信站: 北邮人论坛 (Tue May 13 15:11:58 2008), 站内

rt
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.151.*]
 
【文章标题】：求助ARM-Linux下键盘的使用 【文章地址】：https://bbs.byr.cn/article/Embedded_System/206 【创建时间】：2008-05-11 【作者】：warmbupt 【评论】：2 【内容】：发信人: warmbupt (warmbupt), 信区: Embedded_System
标  题: 求助ARM-Linux下键盘的使用
发信站: 北邮人论坛 (Sun May 11 13:58:10 2008), 站内

2440的板子，内核是2.6.13。以前真没注意这个，今天找了个USB键盘插上去，可以识别的，但是在Qt下不能用。怎样才能知道我的键盘已经被驱动起来了呢?
--
我们的根据地:<a target="_blank" href="http://blog.163.com/bupt_united/">http://blog.163.com/bupt_united/</a>
还有....欢迎来电子电路板，我在那等你！

※ 修改:·warmbupt 于 May 11 13:58:42 修改本文·[FROM: 59.64.135.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.135.*]
 
【文章标题】：[合集] 报到专用楼 【文章地址】：https://bbs.byr.cn/article/Embedded_System/259 【创建时间】：2008-05-15 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: [合集] 报到专用楼
发信站: 北邮人论坛 (Thu May 15 09:53:34 2008), 站内

☆─────────────────────────────────────☆
   Winters101 (Winters) 于  (Mon May  5 18:43:46 2008)  提到:

本楼是报道专用楼。
为了大家以后能够更好的交流和沟通，希望大家能够留下自己的一些基本信息。
大家报到时，请尽量按照模板来。以下是模板：

ID:


学院专业年级:


QQ:


email:


现在对嵌入式的掌握情况:


是否有过嵌入式方面的实习经验：


想对大家说的话:


☆─────────────────────────────────────☆
   tjfmail (INTEL) 于  (Mon May  5 18:58:21 2008)  提到:

ID:  
 
学院专业年级: 电院研一
 
QQ: 61816173 
 
email:  tjfmail@163.com
 
现在对嵌入式的掌握情况:  初级
 
是否有过嵌入式方面的实习经验：有一点ucos的项目经验
 
想对大家说的话: 想入门简单，想成为牛人难



☆─────────────────────────────────────☆
   huahua1860 (CH.F.Y) 于  (Mon May  5 19:00:03 2008)  提到:

ID: CH.F.Y
 
 
学院专业年级: 计算机科学与技术 研一 
 
 
QQ: 286781889
 
 
email: Chenfuyuan012@163.com
 
 
现在对嵌入式的掌握情况: 初级
 
 
是否有过嵌入式方面的实习经验： 无
 
 
想对大家说的话: 哎呀,缘分呢



☆─────────────────────────────────────☆
   sweetfly (mession) 于  (Mon May  5 19:01:20 2008)  提到:

ID: sweetfly
学院：电信工程学院
QQ:119608400
email:llongxiaopingfrf@gmail.com
嵌入式了解程度：对单片机编程操作熟悉，对嵌入式技术基本掌握原理概念，没有项目经历
对大家想说的话：这个板块是嵌入式系统协会对外宣传的重要方式，请大家能够在板块里相识相知，维护好我们作为北邮技术协会的荣誉；同时在板块之外，协会也会动用一切可以动用的资源为大家的学习交流创造最好的软件，硬件平台。一起努力，共同进步！


☆─────────────────────────────────────☆
   afeionline (afeionline) 于  (Mon May  5 19:11:47 2008)  提到:

ID: 
 afeionline
 
学院专业年级: 
 
 电院研一，电磁场与微波技术
QQ: 
 
 基本不用
email: 
 
 afeionline@hotmail.com (MSN)
现在对嵌入式的掌握情况: 
 
 一般，不熟悉操作系统
是否有过嵌入式方面的实习经验： 
 
 嵌入式编程，DSP
想对大家说的话: 
共同进步


☆─────────────────────────────────────☆
   igreenmaple (igreenmaple) 于  (Mon May  5 19:17:17 2008)  提到:

ID:  igreenmaple
 
学院专业年级:  电院研一
 
QQ: 80583854
 
email: zcd1985@sina.com 
 
现在对嵌入式的掌握情况:  入门 
 
是否有过嵌入式方面的实习经验： 无
 
想对大家说的话: 我们一起进步吧


☆─────────────────────────────────────☆
   zlm (bluesea) 于  (Mon May  5 19:44:47 2008)  提到:

ID: zlm
  
学院专业年级:  电院研一 
  
QQ: 285756410 
  
email: zlmeng1@yahoo.com.cn 
  
现在对嵌入式的掌握情况:  入门  
  
是否有过嵌入式方面的实习经验： 无 
  
想对大家说的话: 共同学习，共同进步！


☆─────────────────────────────────────☆
   yihang (Goodluckfly) 于  (Mon May  5 20:28:00 2008)  提到:

ID:yihang
学院专业年级:  信院研一  
QQ: 275061699  
email: lbangyun@gmail.com
现在对嵌入式的掌握情况:  入门
是否有过嵌入式方面的实习经验： 没
想对大家说的话: 共同学习，多多交流。


☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Mon May  5 21:48:11 2008)  提到:

ID: fzylijun886
   
学院专业年级:  微所 
   
QQ: 584634894
   
email: 不留了 
   
现在对嵌入式的掌握情况:  比初级强点吧 
   
是否有过嵌入式方面的实习经验： 带过点本科实验
   
想对大家说的话: 共同学习，共同进步！ 



☆─────────────────────────────────────☆
   DusTin (老了) 于  (Mon May  5 21:53:41 2008)  提到:

ID: Dustin
 
 
学院专业年级: 电院研二
 
 
QQ: 116648545
 
 
email: darkheaven1983@gmail.com
 
 
现在对嵌入式的掌握情况: 了解
 
 
是否有过嵌入式方面的实习经验：一年小公司嵌入式开发，主要做linux移植驱动以及应用程序编写，也做过部分ucos的应用程序。目前在nsn实习转做linux kernel
 
 
想对大家说的话: 希望能与大家多多交流


☆─────────────────────────────────────☆
   ccliu (匆匆过客) 于  (Tue May  6 09:02:52 2008)  提到:

ID: ccliu

学院专业年级: 电院研一 

QQ: 284468218 

email: liuchong.8@tom.com 

现在对嵌入式的掌握情况: 初级 

是否有过嵌入式方面的实习经验： 有快一年的项目经历,写过一个uC平台下的一个驱动,对ARM7比较熟
 
想对大家说的话: 共同学习,共同进步,多多交流



☆─────────────────────────────────────☆
   MorningJSHA (morning) 于  (Tue May  6 10:28:35 2008)  提到:

ID:   
  
学院专业年级: 电院研一 
  
QQ: 642491883
  
email:  xuxiaoning1984@163.com
  
现在对嵌入式的掌握情况:  入门 
  
是否有过嵌入式方面的实习经验：无 
  
想对大家说的话: 大家共同学习吧 



☆─────────────────────────────────────☆
   howl (夜鹰) 于  (Tue May  6 20:07:52 2008)  提到:

ID: howl
 
学院专业年级: 电院研一  多媒体中心
 
QQ: 282425743  
 
email: chengjianweiok@gmail.com
 
现在对嵌入式的掌握情况: 初级  
 
是否有过嵌入式方面的实习经验： 没有
嵌入式编程，DSP
  
想对大家说的话: 共同学习,共同进步,多多交流 


☆─────────────────────────────────────☆
   linny (linny) 于  (Wed May  7 15:32:39 2008)  提到:

ID:   
  
学院专业年级: 电院研一 
  
QQ: 229897492 
  
email: llfj010101@163.com 
  
现在对嵌入式的掌握情况:  无 
  
是否有过嵌入式方面的实习经验：开发过手机嵌入式应用程序
  
想对大家说的话: 共同学习,共同进步!



☆─────────────────────────────────────☆
   devahb (北邮人) 于  (Wed May  7 15:33:20 2008)  提到:

ID:   devahb
  
学院专业年级: 自动化研二
  
QQ: 44313104
  
email:  devahb@gmail.com
  
现在对嵌入式的掌握情况:  初级 
  
是否有过嵌入式方面的实习经验：杂七杂八的做了不少 但是很不系统  感觉基础不牢  

想对大家说的话: 希望大家互相帮助 交流才能更快的进步


☆─────────────────────────────────────☆
   Bupterm (怀孕中|我不喜欢泡汤。。|你爷爷的快好！) 于  (Wed May  7 20:03:52 2008)  提到:

ID Bupterm
年级 呃，我很年轻。。
QQ 276031545
现在对嵌入式掌握情况：一点不会呀..
想对大家说的话：我是专门来学习的，学习。。。请多多指教
【 在 Winters101 (Winters) 的大作中提到: 】
: 本楼是报道专用楼。 
: 为了大家以后能够更好的交流和沟通，希望大家能够留下自己的一些基本信息。 
: 大家报到时，请尽量按照模板来。以下是模板： 
: ................... 



☆─────────────────────────────────────☆
   crow (你吃面，我喝汤) 于  (Fri May  9 09:18:24 2008)  提到:

ID:   crow
   
学院专业年级:  电院研二 
   
QQ: 31871736
   
email:  jyoccd@gmail.com 
   
现在对嵌入式的掌握情况:  初级  
   
是否有过嵌入式方面的实习经验：做过一点点   
 
想对大家说的话: 向大家多多学习 



☆─────────────────────────────────────☆
   warmbupt (warmbupt) 于  (Fri May  9 18:04:20 2008)  提到:


 
ID: warmbupt
 
 
学院专业年级: 信息工程大三
 
 
 
现在对嵌入式的掌握情况: 一般
 
 
是否有过嵌入式方面的实习经验： 参加Intel邀请赛，同时进展两个本科生创新基金项目。
 



☆─────────────────────────────────────☆
   unicornllj (unicorn) 于  (Sat May 10 16:29:32 2008)  提到:

ID: unicornllj
 
学院专业年级: 电院研一  
 
QQ: 43244103
 
email: sgkllj@gmail.com 
 
现在对嵌入式的掌握情况: 初级  
 
是否有过嵌入式方面的实习经验： 软件：做过一些单片机的程序（无操作系统），编过少量vxworks下的程序（arm9） 硬件：现在做的就是硬件平台的设计
 
想对大家说的话: 正确认识嵌入式系统


☆─────────────────────────────────────☆
   cheetahxun (瘦企鹅) 于  (Sun May 11 02:16:54 2008)  提到:

ID: cheetahxun
 
学院专业年级: 电院大二
 
QQ: 398253545
 
email: cheetahxun@yahoo.com.cn
 
现在对嵌入式的掌握情况: 入门
 
是否有过嵌入式方面的实习经验： 在自学单片机，平台MSP430，主要针对低功耗应用。试着把uCOS移植过来。
 
想对大家说的话: 望诸位学长多多指教~（呵呵，我不会是版里最年轻的吧？）


☆─────────────────────────────────────☆
   h459127037 (残灭泪桥) 于  (Sun May 11 21:04:30 2008)  提到:

Id:   h459127037

计科大三

qq：459127037

email：llhe.1988@yahoo.com.cn

学习情况：正在邝大王手上选修该科，觉得他是大王，也就会烧个小板子

想说的话：觉得嵌入式很神奇，也很有市场，并且跟大王混肯定有前途，也请各位前辈多带带我们


☆─────────────────────────────────────☆
   legendiychq (人生蒙太奇) 于  (Sun May 11 21:30:12 2008)  提到:

ID: legendiychq
 
 
学院专业年级:计科大三（同ls） 
 
 
QQ: 447637679
 
 
email: legend_ychq@yahoo.com.cn
 
学习情况：于邝大王手下选修嵌入式课程，努力做vxworks模拟平台下的入门实验中 
 
想说的话：嵌入式有无限的吸引力，太有吸引力了，那是相当有吸引力啦，愿版内各位大牛指导



☆─────────────────────────────────────☆
   well645 (里伤隐) 于  (Mon May 12 14:52:45 2008)  提到:

ID: well645
  
  
学院专业年级:电院研二  
  
  
QQ: 116302556
  
  
email: well645@163.com 
  
学习情况：项目驱动，自学，目标是把一个基于gstreamer的工程移植到AMCC的PowerPC 405ex下，系统是2.6的内核  
  
想说的话：移植有风险，操作需谨慎，希望大家多多交流哈


☆─────────────────────────────────────☆
   wuyulunbi (轨迹) 于  (Mon May 12 15:12:17 2008)  提到:

ID:  wuyulunbi 
  
学院专业年级:  电院研一 
  
QQ: 271127714 
  
email: chudonganjing@gmail.com 
  
现在对嵌入式的掌握情况:  入门  
  
是否有过嵌入式方面的实习经验： 无 
  
想对大家说的话: 我们一起进步吧 



 【文章标题】：[转帖]linux串口通信 【文章地址】：https://bbs.byr.cn/article/Embedded_System/56 【创建时间】：2008-05-03 【作者】：fzylijun886 【评论】：3 【内容】：发信人: fzylijun886 (北邮人), 信区: Embedded_System
标  题: [转帖]linux串口通信
发信站: 北邮人论坛 (Sat May  3 11:32:39 2008), 站内

一、什么是串口通信 
串口通信是指计算机主机与外设之间以及主机系统与主机系统之间数据的串行传送。使用串口通信时，发送和接收到的每一个字符实际上都是一次一位的传送的，每一位为1或者为0。
 
二、串口通信的分类 
串口通信可以分为同步通信和异步通信两类。同步通信是按照软件识别同步字符来实现数据的发送和接收，异步通信是一种利用字符的再同步技术的通信方式。 
 
2.1同步通信 
同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息。这里的信息帧与异步通信中的字符帧不同，通常含有若干个数据字符。如图： 
单同步字符帧结构 
+-----+------+-------+------+-----+--------+-------+-------+ 
|同步|数据 |数据 |数据 | ... |数据 |CRC1|CRC2| 
|字符|字符1|字符2|字符3| |字符N| | | 
+-----+------+-------+------+-----+--------+-------+-------+ 
双同步字符帧结构 
+-----+--------+------+-------+---+-------+-------+--------+ 
|同步 |同步 |数据 |数据 | ... |数据 |CRC1|CRC2| 
|字符1|字符2|字符1|字符2| |字符N| | | 
+-----+--------+------+-------+---+-------+-------+--------+ 
它们均由同步字符、数据字符和校验字符（CRC）组成。其中同步字符位于帧开头，用于确认数据字符的开始。数据字符在同步字符之后，个数没有限制，由所需传输的数据块长度来决定；校验字符有1到2个，用于接收端对接收到的字符序列进行正确性的校验。 
同步通信的缺点是要求发送时钟和接收时钟保持严格的同步。 
 
2.2异步通信 
异步通信中，数据通常以字符或者字节为单位组成字符帧传送。字符帧由发送端逐帧发送，通过传输线被接收设备逐帧接收。发送端和接收端可以由各自的时钟来控制数据的发送和接收，这两个时钟源彼此独立，互不同步。 
接收端检测到传输线上发送过来的低电平逻辑"0"（即字符帧起始位）时，确定发送端已开始发送数据，每当接收端收到字符帧中的停止位时，就知道一帧字符已经发送完毕。 
在异步通行中有两个比较重要的指标：字符帧格式和波特率。 
(1)字符帧，由起始位、数据位、奇偶校验位和停止位组成。如图： 
无空闲位字符帧 
+--+---+---+---+---+--+--+--+--+--+--+--+---+---+---+--+--+ 
|D7|0/1| 1 | 0 |D0|D1|D2|D3|D4|D5|D6|D7|0/1| 1 | 0 |D0|D1| 
+--+---+---+---+--+--+--+--+--+--+--+--+---+---+---+--+--+ 
奇偶 停 起 奇偶 停 起 
校验 止 始 校验 止 始 
位 位 位 位 
有空闲位字符帧 
+---+---+--+--+--+--+--+--+--+--+---+---+---+---+---+---+--+ 
| 1 | 0 |D0|D1|D2|D3|D4|D5|D6|D7|0/1| 1 | 1 | 1 | 1 | 0 |D0| 
+---+---+--+--+--+--+--+--+--+--+---+---+---+---+---+---+--+ 
空 起 奇偶 停 空 闲 位 起 
闲 始 校验 止 始 
位 位 位 位 

1.起始位：位于字符帧开头，占1位，始终为逻辑0电平，用于向接收设备表示发送端开始发送一帧信息。 
2.数据位：紧跟在起始位之后，可以设置为5位、6位、7位、8位，低位在前高位在后。 
3.奇偶校验位：位于数据位之后，仅占一位，用于表示串行通信中采用奇校验还是偶校验。 
(2)波特率，波特率是每秒钟传送二进制数码的位数，单位是b/s。 
异步通信的优点是不需要传送同步脉冲，字符帧长度也不受到限制。缺点是字符帧中因为包含了起始位和停止位，因此降低了有效数据的传输速率。 
 
三、什么是RS-232 
RS-232-C 接口（又称 EIA RS-232-C）它是在 1970 年由美国电子工业协会（EISB2.0、网卡接口、Modem接口、VGA接口、扩展坞、IEEE 1394以及六合一读卡器，常用的端口一应俱全。 
HP Ze2022AP 

Ze2022AP外观上采用了惠普经典的Pavilion DV1000的模具，模具成熟，外观无可挑剔。银白色的主色调，再经过磨砂处理，视觉效果和触感都相当理想。Ze2202AP外形方方正正，棱角分明，同时惠普还颇费心思地在前后采用了倾斜的切割，整个外形更显精细动感。 
Ze2202AP的端口主要分布在左右两端，右侧有2个USB接口、1个1394接口， SD/MS/MMC多功能存储卡读取插槽，还有COMBO光驱，以及S端口。左侧从后到前分布电源接口、VGA输出接口、基座扩展接口、 RJ11/RJ45网络接口，1个USB接口，以及PCMCIA扩展插槽。除此之外，这款机型同样配备扩展端口，扩展性无疑是相当强大的。 
ThinkPad R50e 1834HC1 
IBM的R系列实际上是T系列的经济版本，有人将其形象地表示为“偷工减料版的T”，外形上依然承袭了IBM“小黑”一贯的酷。这款R50e顶盖材料采用了ABS工程塑料，但借助不错的顶盖框架，强度还是不错的。 
R150e的端口相对齐全，不仅有ThinkPad经典的指定杆，接口上还包括RJ45/11网络接口、两个USB接口、PC卡插槽、VGA接口、S视频端口，但没有IEEE1394接口，对经常使用数码产品的消费者无疑是个坏消息。 

 
五、全双工与半双工 
 
1.全双工，表示机器可以同时发送数据也可以接收数据，有两个独立的数据通道（一个用于发送，一个用于接收） 
2.半双工，表示机器不能在发送数据的同时也接收数据。 
 
六、流量控制 
 
1.使用软件方法 
使用特殊的字符来标记数据流的开始和结束，比如XON,DC1,八进制021来标志开始，用X0FF,DC3,八进制023来标志结束。 
2.使用硬件方法 
使用RS232的CTS和RTS信号来代替特殊字符控制。当接收方准备接收更多数据时，设置CTS为0,反之设置成1。对应的发送端准备发送数据时，设置RTS为0。 
 
 
七、串口的访问 
串口设备在LINUX下与所有设备一样都是通过设备文件来进行访问。 
 
7.1打开串口 
LINUX系统下串口设备是通过open函数来打开的，不过需要注意的是，一般用户是没有权限访问设备文件的，需要将打开的串口设备的访问权限设置成一般用户可以访问的权限。 
open函数 
头文件 
#include 
#include 
#include 
函数原型 
int open(const char *pathname, int oflag, .../*, mode_t mode*/); 
参数 
const char *pathname - 要打开文件的文件名称，例如/dev/ttyS0 
int oflag - 文件打开方式，可用标志如下： 
O_RDONLY 以只读方式打开文件 
O_WRONLY 以只写方式打开文件 
O_RDWR 以读写方式打开文件 
O_APPEND 写入数据时添加到文件末尾 
O_CREATE 如果文件不存在则产生该文件，使用该标志需要设置访问权限位mode_t 
O_EXCL 指定该标志，并且指定了O_CREATE标志，如果打开的文件存在则会产生一个错误 
O_TRUNC 如果文件存在并且成功以写或者只写方式打开，则清除文件所有内容，使得文件长度变为0 
O_NOCTTY 如果打开的是一个终端设备，这个程序不会成为对应这个端口的控制终端，如果没有该标志，任何一个输入，例如键盘中止信号等，都将影响进程。 
O_NONBLOCK 该标志与早期使用的O_NDELAY标志作用差不多。程序不关心DCD信号线的状态，如果指定该标志，进程将一直在休眠状态，直到DCD信号线为0。 
O_SYNC 对I/O进行写等待 
返回值 
成功返回文件描述符，如果失败返回-1 
例如：以可读写方式打开/dev/ttyS0设备 
int fd; /* 文件描述符 */ 
fd = open("/dev/ttyS0", O_RDWR | 0_NOCTTY | O_NONBLOCK); 
 
7.2关闭串口 
Linux系统下通过close函数来关闭串口设备 
close函数 
头文件 
#include 
函数原型 
int close(int filedes); 
参数 
int filedes - 文件描述符 
返回值 
成功返回0，否则返回-1 
例如：关闭打开的串口设备fd 
int ret; /* 返回标志，用于判断是否正常关闭设备 */ 
ret = close(fd); 
 
7.3写串口 
写串口是通过write函数来完成的 
write函数 
头文件 
#include 
函数原型 
ssize_t write(int filedes, const void *buff, size_t nbytes); 
参数 
int filedes - 文件描述符 
const void *buff - 存储写入数据的数据缓冲区 
size_t nbytes - 写入数据字节数 
返回值 
ssize_t - 返回写入数据的字节数,该值通常等于nbytes，如果写入失败返回-1 
例如：向终端设备发送初始化命令 
int n = 0; /* 写入字节数 */ 
n = write(fd, "ATZ\r", 4); 
if(n == -1) 
{ 
fprintf(stderr, "Wirte ATZ command error.\n"); 
} 

 
7.4读串口 
读串口是通过read函数来完成的 
read函数 
头文件 
#include 
函数原型 
ssize_t read(int filedes, void *buff, size_t nbytes); 
参数 
int filedes - 文件描述符 
void *buff - 存储读取数据的数据缓冲区 
size_t nbytes - 需要读取的字节数 
返回值 
ssize_t - 成功读取返回读取的字节数，否则返回-1 
注意，在对串口进行读取操作的时候，如果是使用的RAW模式，每个read系统调用将返回当前串行输入缓冲区中存在的字节数。如果没有数据，将会一致阻塞到有字符达到或者间隔时钟到期，或者发生错误。如果想使read函数在没有数据的时候立即返回则可以使用fcntl函数来设置文件访问属性。例如： 
fcntl(fd, F_SETFL, FNDELAY); 
这样设置后，当没有可读取的数据时，read函数立即返回0。 
通过fcntl(fd, F_SETFL, 0)可以设置回一般状态。 
例如：从终端读取5个字节的应答数据 
int nRead; /* 从终端读取的字节数 */ 
char buffer[256]; /* 接收缓冲区 */ 
nRead = read(fd, buffer, 5); 
if(nRead == -1) 
{ 
fprintf(stderr, "Read answer message error.\n"); 
} 
 
八、终端配置 
 
8.1 POSIX终端接口 
大多数系统都支持POSIX终端接口，POSIX终端通过一个termios结构来进行控制，该结构定义在termios.h文件中。 
termios结构 
struct termios 
{ 
tcflag_t c_iflag; /* 输入选项标志 */ 
tcflag_t c_oflag; /* 输出选项标志 */ 
tcflag_t c_cflag; /* 控制选项标志 */ 
tcflag_t c_lflag; /* 本地选项标志 */ 
cc_t c_cc[NCCS]; /* 控制特性 */ 
}; 

c_iflag成员 
Flag Description 
GNBRK 忽略输入中的BREAK状态 
BRKINT 如果设置了IGNBRK，将忽略BREAK。如果没有设置，但是设置了BRKINT，那么BREAK将使得输入和输出队列被刷新，如果终端是一个前台进程组的控制终端，这个进程组中所有进程将收到SIGINT信号。如果既未设置IGNBRK也未设置BRKINT，BREAK将视为NUL同义字符，除非设置了PARMRK，这种情况下被视为序列\377\0\0 
IGNPAR 忽略桢错误和奇偶校验错误 
PARMRK 如果没有设置IGNPAR，在有奇偶校验错误或者桢错误的字符前插入\377\0。如果既没有设置IGNPAR也没有设置PARMRK，将所有奇偶校验错误或者桢错误的字符视为\0。 
INPCK 启用输入奇偶校验检测。 
ISTRIP 去掉第八位。 
INLCR 将输入的NL翻译为CR。 
IGNCR 忽略输入中的回车。 
ICRNL 将输入中的回车翻译为新行字符（除非设置了IGNCR）。 
IUCLC （不属于POSIX）将输入中的大写字母映射为小写字母。 
IXON 启用输出的XON/XOFF流控制 
IXANY （不属于POSIX。1；XSI）允许任何字符来重新开始输出。 
IXOFF 启用输入的XON/XOFF流控制 
IMAXBEL （不属于POSIX）当输入队列满时响铃。LINUX没有实现该位，总是将其视为已设置。 
 
c_oflag成员 
Flag Description 
OPOST 启用具体实现自行定义的输出。 
OLCUC （不属于POSIX）将输出中的小写字母映射为大写字母。 
ONLCR （XSI）将输出中的新行符映射为回车-换行 
OCRNL 将输出中的回车映射为新行符。 
ONOCR 不在第0列输出回车。 
ONLRET 不输出回车。 
OFILL 发送填充字符作为延时。 
OFDEL （不属于POSIX）填充字符是ASCII DEL（0177）。如果不设置填充字符则是ASCII NUL。 
NLDLY 新行延时掩码。取值为NL0和NL1。 
CRDLY 回车延时掩码。取值为CR0,CR1,CR2或CR3。 
TABDLY 水平跳格延时掩码。取值为TAB0,TAB1,TAB2,TAB3（或XTABS）。取值为TAB3,即XTABS，将扩展跳格为空格（每个跳格符填充8个空格）。 
BSDLY 回车延时掩码。取值为BS0或BS1.（从来没有被实现） 
VTDLY 竖直跳格掩码。取值为VT0或VT1。 
FFDLY 进表延时掩码。取值为FF0或者FF1。 

c_cflag成员 
Flag Description 
CBAUD （不属于POSIX）波特率掩码（4+1位）。 
CBAUDEX （不属于POSIX）扩展的波特率掩码（1位），包含在CBAUD中。 
CSIZE 字符长度掩码。取值为CS5,CS6,CS7或CS8。 
CSTOPB 设置两个停止位。 
CREAD 打开接受者。 
PARENB 允许输出产生奇偶信息以及输入的奇偶校验。 
PARODD 输入和输出是奇校验 
HUPCL 在最后一个进程关闭设备后，降低MODEM控制线（挂断）。 
CLOCAL 忽略MODEM控制线。 
LOBLK （不属于POSIX）从非当前SHELL层阻塞输出（用于sh1）。 
CIBAUD （不属于POSIX）输入速度的掩码。CIBAUD各位的值与CBAUD各位相同，左移了IBSHIFT位。 
CRTSCTS （不属于POSIX）启用RTS/CTS（硬件）控制流。 
 
c_lflag成员 
Flag Description 
ISIG 当接收到字符INTR，QUIT，SUSP或DSUSP时，产生相应的信号。 
XCASE （不属于POSIX；LINUX下不支持）如果同时设置了ICANON，终端只有大写。输入被转换为小写，除了以\前缀的字符。输出时，大写字符被前缀\，小写字符被转换成大写。 
ECHO 回显输入字符。 
ECHOE 如果同时设置了ICANON，字符ERASE擦除前一个输入字符，WERASE擦除前一个词。 
ECHOK 如果同时设置了ICANON，字符KILL删除当前行。 
ECHONL 如果同时设置了ICANON，回显字符NL，即使没有设置ECHO。 
ECHOCTL （不属于POSIX）如果同时设置了ECHO，除了TAB，NL，START和STOP之外的ASCII控制信号被回显为^x，这里X是比控制信号大0x40的ASCII码。例如字符0x08(BS)被回显为^H。 
ECHOPRT （不属于POSIX）如果同时设置了ICANON和IECHO，字符在删除的同时被打印。 
ECHOKE （不属于POSIX）如果同时设置了ICANON，回显KILL时将删除一行中的每个字符，如同指定了ECHOE和ECHORPT一样。 
DEFECHO （不属于POSIX）只在一个进程读的时候回显。 
FLUSHO （不属于POSIX；LINUX不支持）输出被刷新。这个标志可以通过键入字符DISCARD来打开和关闭。 
NOFLSH 禁止产生SIGINT，SIGQUIT和SIGSUSP信号时刷新输入和输出队列。 
TOSTOP 向试图写控制终端的后台进程组发送SIGTTOU信号。 
PENDIN （不属于POSIX；LINUX不支持）在读入一个字符时，输入队列中的所有字符被重新输出。（bash用他来处理typeahead）。 
IEXTEN 启用实现自定义的输入处理。这个标志必须与ICANON同时使用，才能解释特殊字符EOL2,LNEXT，REPRINT和WERASE，IUCLC标志才有效。 

c_cc数组成员 
Flag Description 
VINTR （003,ETX，Ctrl-C,or also 0177, DEL, rubout）中断字符。发送SIGINT信号。当设置ISIG时可被识别，不再作为输入传递。 
VQUIT （034,FS，Ctrl-\）退出字符。发出SIGQUIT信号。当设置ISIG时可被识别，不再作为输入传递。 
VERASE (0177, DEL, rubout, or 010, BS, Ctrl-H, or also #) 删除字符。删除上一个还没有删掉的字符，但不删除上一个 EOF 或行首。当设置 ICANON 时可被识别，不再作为输入传递。 
VKILL (025, NAK, Ctrl-U, or Ctrl-X, or also @) 终止字符。删除自上一个 EOF 或行首以来的输入。当设置 ICANON 时可被识别，不再作为输入传递。 
VEOF (004, EOT, Ctrl-D) 文件尾字符。更精确地说，这个字符使得 tty 缓冲中的内容被送到等待输入的用户程序中，而不必等到 EOL。如果它是一行的第一个字符，那么用户程序的 read() 将返回 0，指示读到了 EOF。当设置 ICANON 时可被识别，不再作为输入传递。 
VMIN 非 canonical 模式读的最小字符数。 VEOL (0, NUL) 附加的行尾字符。当设置 ICANON 时可被识别。 VTIME 非 canonical 模式读时的延时，以十分之一秒为单位。 VEOL2 (not in POSIX; 0, NUL) 另一个行尾字符。当设置 ICANON 时可被识别。 
VEOL (0, NUL) 附加的行尾字符。当设置 ICANON 时可被识别。 
VTIME 非 canonical 模式读时的延时，以十分之一秒为单位。 
VEOL2 (not in POSIX; 0, NUL) 另一个行尾字符。当设置 ICANON 时可被识别。 
VSWTCH (not in POSIX; not supported under Linux; 0, NUL) 开关字符。(只为 shl 所用。) 
VSTART (021, DC1, Ctrl-Q) 开始字符。重新开始被 Stop 字符中止的输出。当设置 IXON 时可被识别，不再作为输入传递。 
VSTOP (023, DC3, Ctrl-S) 停止字符。停止输出，直到键入 Start 字符。当设置 IXON 时可被识别，不再作为输入传递。 
VSUSP (032, SUB, Ctrl-Z) 挂起字符。发送 SIGTSTP 信号。当设置 ISIG 时可被识别，不再作为输入传递。 
VDSUSP (not in POSIX; not supported under Linux; 031, EM, Ctrl-Y) 延时挂起信号。当用户程序读到这个字符时，发送 SIGTSTP 信号。当设置 IEXTEN 和 ISIG，并且系统支持作业管理时可被识别，不再作为输入传递。 
VLNEXT (not in POSIX; 026, SYN, Ctrl-V) 字面上的下一个。引用下一个输入字符，取消它的任何特殊含义。当设置 IEXTEN 时可被识别，不再作为输入传递。 
VWERASE (not in POSIX; 027, ETB, Ctrl-W) 删除词。当设置 ICANON 和 IEXTEN 时可被识别，不再作为输入传递。 
VREPRINT (not in POSIX; 022, DC2, Ctrl-R) 重新输出未读的字符。当设置 ICANON 和 IEXTEN 时可被识别，不再作为输入传递。 
VDISCARD (not in POSIX; not supported under Linux; 017, SI, Ctrl-O) 开关：开始/结束丢弃未完成的输出。当设置 IEXTEN 时可被识别，不再作为输入传递。 
VSTATUS (not in POSIX; not supported under Linux; status request: 024, DC4, Ctrl-T). 

 
8.2设置波特率 
对于波特率的设置通常使用cfsetospeed和cfsetispeed函数来完成。获取波特率信息是通过cfgetispeed和cfgetospeed函数来完成的。 
cfsetospeed函数 
头文件: 
#include 
函数原型: 
int cfsetospeed(struct termios *termptr, speed_t speed); 
参数： 
struct termios *termptr - 指向termios结构的指针 
speed_t speed - 需要设置的输出波特率 
返回值： 
如果成功返回0,否则返回-1 
cfsetispeed函数 
头文件： 
#include 
函数原型: 
int cfsetispeed(struct termios *termptr, speed_t speed); 
参数: 
struct termios *termptr - 指向termios结构的指针 
speed_t speed - 需要设置的输入波特率 
返回值： 
如果成功返回0,否则返回-1 
cfgetospeed函数 
头文件： 
#include 
函数原型： 
speed_t cfgetospeed(const struct termios *termptr); 
参数: 
const struct termios - 指向termios结构的指针 
返回值： 
返回输出波特率 
cfgetispeed函数 
头文件： 
#include 
函数原型: 
speed_t cfgetispeed(const struct termios *termptr); 
参数: 
const struct termios *termptr - 指向termios结构的指针 
返回值： 
返回输入波特率 
波特率常量： 
CBAUD 掩码 
B0 0波特 
B50 50波特 
B75 75波特 
B110 100波特 
B134 134波特 
B150 150波特 
B200 200波特 
B300 300波特 
B600 600波特 
B1200 1200波特 
B1800 1800波特 
B2400 2400波特 
B9600 9600波特 
B19200 19200波特 
B38400 38400波特 
B57600 57600波特 
B115200 115200波特 
 
8.3设置字符大小 
设置字符的大小通过设置c_cflag标志位来实现的。 
例如： 
option.c_cflag &amp;= ~CSIZE; 
option.c_cflag |= CS7; 
 
8.4设置奇偶校验 
对于奇偶校验是需要手工设置的，常用的设置方式如下： 
No parity (8N1): 
options.c_cflag &amp;= ~PARENB 
options.c_cflag &amp;= ~CSTOPB 
options.c_cflag &amp;= ~CSIZE; 
options.c_cflag |= CS8; 
Even parity (7E1): 
options.c_cflag |= PARENB 
options.c_cflag &amp;= ~PARODD 
options.c_cflag &amp;= ~CSTOPB 
options.c_cflag &amp;= ~CSIZE; 
options.c_cflag |= CS7; 
Odd parity (7O1): 
options.c_cflag |= PARENB 
options.c_cflag |= PARODD 
options.c_cflag &amp;= ~CSTOPB 
options.c_cflag &amp;= ~CSIZE; 
options.c_cflag |= CS7; 
Space parity is setup the same as no parity (7S1): 
options.c_cflag &amp;= ~PARENB 
options.c_cflag &amp;= ~CSTOPB 
options.c_cflag &amp;= ~CSIZE; 
options.c_cflag |= CS8; 

 
8.5获取和设置终端属性 
设置和获取终端控制属性是通过tcgetattr和tcsetattr两个函数来完成的 
tcgetattr函数 
头文件: 
#include 
函数原型: 
int tcgetattr(int filedes, struct termios *termptr); 
参数： 
int filedes - 文件描述符 
struct termiso *termptr - 指向termios结构的指针， 
返回值: 
如果成功返回0,否则返回-1 
tcsetattr函数 
头文件: 
#include 
函数原型： 
int tcsetattr(int filedes, int opt, const struct termios *termptr); 
参数： 
int filedes - 文件描述符 
int opt - 选项值，可以为下面三个值之一 
TCSANOW - 不等数据传输完毕就改变属性 
TCSADRAIN - 等待所有数据传输结束才改变属性 
TCSAFLUSH - 清空输入输出缓冲区并且是设置属性 
const struct termios *termptr - 指向termios结构的指针， 
返回值： 
成功返回0,否则返回-1 
 
九、常用设置 
 
9.1设置规范模式 
规范模式是面向行的输入方式，输入字符被放入用于和用户交互可以编辑的缓冲区内，直接到读入回车或者换行符号时才结束。 
可以通过如下方式来设置 
option.c_lflag |= (ICANON | ECHO | ECHOE); 
 
9.2设置原始输入模式 
原始输入模式是没有处理过的，当接收数据时，输入的字符在它们被接收后立即被传送，使用原始输入模式时候，一般可以选择取消ICANON，ECHO，ECHOE和ISIG选项。 
例如： 
option.c_lflag &amp;= ~(ICANON | ECHO | ECHOE); 

 
9.3设置输入奇偶选项 
当激活c_cflag中的奇偶校验后，应该激活输入的奇偶校验。与之相关的标志有INPCK，IGNPAR，PARMRK和ISTRIP。一般是通过选择INPCK和ISTRIP激活检验和移除奇偶位。 
例如： 
option.c_iflag |= (INPCK | ISTRIP); 
 
9.4设置软件控制流 
软件控制流通过IXON，IXOFF和IXANY标志来设置 
例如： 
option.c_iflag |=(IXON | IXOFF | IXANY); 
 
9.5选择预处理输出 
通过OPOST标志来设置预处理的输出 
例如： 
option.c_oflag |= OPOST; 
 
9.6选择原始数据输出 
原始数据的输出通过设置c_oflag的OPOST标志 
例如: 
option.c_oflag &amp;= ~OPOST; 
 
9.7设置软件流控制字符 
软件流控制字符是通过c_cc数组中的VSTART和VSTOP来设置的，一般来说，它们应该被设置城DC1（021八进制）和DC3（023八进制），分别表示ASCII码的XON和XOFF字符。 
 
9.8设置读超时 
c_cc数组中的VMIN指定了最少读取的字符数，如果设置为0,那么VTIME就指定了读取每个字符的等待时间。VTIME是以1/10秒为单位指定接收字符的超时时间的，如果VTIME设置为0,而端口没有用open或者fcntl设置为 NONBLOCK，那么read操作将会阻塞不确定的时间。 
 
十、参考资料 
1.《Serial Programming Guide for POSIX Operating Systems》5th Edition Michael R.Sweet 
2.《Linux 下串口编程入门》左锦 
3.《Advanced Programming in the UNIX Environment》 W.Richard Stevens 
4.《Linux Serial Programming HOWTO》 
5.《Unix Systems Programming》Kay A.Robbins &amp; Steven Robbins 
6.《Linux Programming by Example》Arnold Robbins 
7.《Linux Programmer's Manual》

--
少说话，多做事！

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.66.122.*]
 【文章标题】：有人用过uC/OS2.83吗? 【文章地址】：https://bbs.byr.cn/article/Embedded_System/241 【创建时间】：2008-05-13 【作者】：ccliu 【评论】：1 【内容】：发信人: ccliu (匆匆过客), 信区: Embedded_System
标  题: 有人用过uC/OS2.83吗?
发信站: 北邮人论坛 (Tue May 13 11:18:43 2008), 站内

请问一下,有那位大牛用过uC/OS2.83版,它新增了一个定时器管理器,能告诉一下怎么用吗?
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.151.*]
 
【文章标题】：[转帖]不要一辈子靠技术生存 【文章地址】：https://bbs.byr.cn/article/Embedded_System/253 【创建时间】：2008-05-15 【作者】：fzylijun886 【评论】：0 【内容】：发信人: fzylijun886 (北邮人), 信区: Embedded_System
标  题: [转帖]不要一辈子靠技术生存
发信站: 北邮人论坛 (Thu May 15 00:07:01 2008), 站内

来源：世界经理人 
　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊). 

一、 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事 市场开发，跑腿的人，没有前途。 

　　不知道你是不是知道，咱们中国有相当大的一部分软件公司，他们的软件开发团队都小的可怜，甚至只有1-3个人，连一个项目小组都算不上，而这样的团队却要承担一个软件公司所有的软件开发任务，在软件上线和开发的关键阶段需要团队的成员没日没夜的加班，还需要为测试出的BUG和不能按时提交的软件模块功能而心怀忐忑，有的时候如果你不幸加入现场开发的团队你则需要背井离乡告别你的女友，进行封闭开发，你平时除了编码之外就是吃饭和睡觉（有钱的公司甚至请个保姆为你做饭，以让你节省出更多的时间来投入到工作中，让你一直在那种累了就休息，不累就立即工作的状态） 

　　更可怕的是，会让你接触的人际关系非常单一，除了有限的技术人员之外你几乎见不到做其他行业工作和职位的人，你的朋友圈子小且单一，甚至破坏你原有的爱情（想象一下，你在外地做现场开发2个月以上，却从没跟女友见过一面的话，你的女友是不是会对你呲牙裂嘴）。 

　　也许你拿到了所谓的白领的工资，但你却从此失去享受生活的自由，如果你想做技术人员尤其是开发人员，我想你很快就会理解，你多么想在一个地方长期待一段时间，认识一些朋友，多一些生活时间的愿望。 

　　比之于我们的生活和人际关系及工作，那些从事售前和市场开发的朋友，却有比我们多的多的工作之外的时间，甚至他们工作的时间有的时候是和生活的时间是可以兼顾的，他们可以通过市场开发，认识各个行业的人士，可以认识各种各样的朋友，他们比我们坦率说更有发财和发展的机会，只要他们跟我们一样勤奋。（有一种勤奋的普通人，如果给他换个地方，他马上会成为一个勤奋且出众的人。） 

二、在学习技术的时候千万不要认为如果做到技术最强，就可以成为100%受尊重的人。 

　　有一次一个人在面试项目经理的时候说了这么一段话：我只用最听话的人，按照我的要求做只要是听话就要，如果不听话不管他技术再好也不要。随后这个人得到了试用机会，如果没意外的话，他一定会是下一个项目经理的继任者。 

　　朋友们你知道吗？不管你技术有多强，你也不可能自由的腾出时间象别人那样研究一下Linux源码，甚至写一个Linux样的杰作来表现你的才能。你需要做的就是按照要求写代码，写代码的含义就是都规定好，你按照规定写，你很快就会发现你昨天写的代码，跟今天写的代码有很多类似，等你写过一段时间的代码，你将领略：复制，拷贝，粘贴那样的技术对你来说是何等重要。（如果你没有做过1年以上的真正意义上的开发不要反驳我）。 

　　如果你幸运的能够听到市场人员的谈话，或是领导们的谈话，你会隐约觉得他们都在把技术人员当作编码的机器来看，你的价值并没有你想象的那么重要。而在你所在的团队内部，你可能正在为一个技术问题的讨论再跟同事搞内耗，因为他不服你，你也不服他，你们都认为自己的对，其实你们两个都对，而争论的目的就是为了在关键场合证明一下自己比对方技术好，比对方强。（在一个项目开发中，没有人愿意长期听别人的，总想换个位置领导别人。） 

三、你更不要认为，如果我技术够好，我就自己创业，自己有创业的资本，因为自己是搞技术的。 

　　如果你那样认为，真的是大错特错了，你可以做个调查在非技术人群中，没有几个人知道C#与JAVA的，更谈不上来欣赏你的技术是好还是不好。一句话，技术仅仅是一个工具，善于运用这个工具为别人干活的人，却往往不太擅长用这个工具来为自己创业，因为这是两个概念，训练的技能也是完全不同的。 

　　创业最开始的时候，你的人际关系，你处理人际关系的能力，你对社会潜规则的认识，还有你明白不明白别人的心，你会不会说让人喜欢的话，还有你对自己所提供的服务的策划和推销等等，也许有一万，一百万个值得我们重视的问题，但你会发现技术却很少有可能包含在这一万或一百万之内，如果你创业到了一个快成功的阶段，你会这样告诉自己：我干吗要亲自做技术，我聘一个人不就行了，这时候你才真正会理解技术的作用，和你以前做技术人员的作用。 

[小结] 

　　基于上面的讨论，我奉劝那些学习技术的朋友，千万不要拿科举考试样的心态去学习技术,对技术的学习几近的痴迷，想掌握所有所有的技术，以让自己成为技术领域的权威和专家，以在必要的时候或是心里不畅快的时候到网上对着菜鸟说自己是前辈。 

　　技术仅仅是一个工具，是你在人生一个阶段生存的工具，你可以一辈子喜欢他，但最好不要一辈子靠它生存。 

　　掌握技术的唯一目的就是拿它找工作（如果你不想把技术当作你第二生命的话），就是干活。所以你在学习的时候千万不要去做那些所谓的技术习题或是研究那些帽泡算法，最大数算法了，什么叫干活？ 

　　就是做一个东西让别人用，别人用了，可以提高他们的工作效率，想象吧，你做1万道技术习题有什么用？只会让人觉得酸腐，还是在学习的时候，多培养些自己务实的态度吧，比如研究一下当地市场目前有哪些软件公司用人，自己离他们的要求到底有多远，自己具体应该怎么做才可以达到他们的要求。等你分析完这些，你就会发现，找工作成功，技术的贡献率其实并没有你原来想象的那么高。 

　　不管你是学习技术为了找工作还是创业，你都要对技术本身有个清醒的认识，在中国不会出现BILL GATES，因为，中国目前还不是十分的尊重技术人才，还仅仅的停留在把软件技术人才当作人才机器来用的尴尬境地。（如果你不理解，一种可能是你目前仅仅从事过技术工作，你的朋友圈子里技术类的朋友占了大多数，一种可能是你还没有工作，但喜欢读比尔。盖茨的传记）。
--
少说话，多做事！

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.66.123.*]
 


【文章标题】：[求助]信院考研,嵌入式方向 【文章地址】：https://bbs.byr.cn/article/Embedded_System/325 【创建时间】：2008-05-16 【作者】：fox513 【评论】：2 【内容】：发信人: fox513 (理发店的学徒), 信区: Embedded_System
标  题: [求助]信院考研,嵌入式方向
发信站: 北邮人论坛 (Fri May 16 21:11:48 2008), 站内

本人准备09年考信院的研究生,想向大家了解一下嵌入式这个方向的一些情况,我学过微机原理,单片机(51),c/c++,用51做过一个温度采集及显示的板子( 80c51,ds18b20温度采集,汇编 c编程) , 但仍感觉没有入门的样子,自己感觉嵌入式应该会有很大用途,但对能真的掌握它并没有很大信心,希望得到一些建议,  另外信院搞嵌入式的项目多吗,我希望考上了以后能潜心学两年 谢谢
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 220.232.127.*]
 
【文章标题】：请问嵌入式算是单片机的升级版本吗? 【文章地址】：https://bbs.byr.cn/article/Embedded_System/118 【创建时间】：2008-05-06 【作者】：MorningJSHA 【评论】：4 【内容】：发信人: MorningJSHA (morning), 信区: Embedded_System
标  题: 请问嵌入式算是单片机的升级版本吗?
发信站: 北邮人论坛 (Tue May  6 10:16:48 2008), 站内

本科时用单片机作过两个小项目,自己立项,设计电路,焊板子编程,那时都用汇编呢,自己调试电路和程序,自己烧芯片.虽然项目连业余制作都算不上,幼稚无比,但不管怎么说在我们系那帮老师的要求下,整个流程算是都走下来了.
不知嵌入式和单片机的关系怎样? 
--

※ 修改:·MorningJSHA 于 May  6 10:21:11 修改本文·[FROM: 59.64.184.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.184.*]
 
【文章标题】：[请教]请问嵌入式系统中，做Driver和Application开发，哪个更有 【文章地址】：https://bbs.byr.cn/article/Embedded_System/318 【创建时间】：2008-05-16 【作者】：trustno1 【评论】：2 【内容】：发信人: trustno1 (TrustNo1), 信区: Embedded_System
标  题: [请教]请问嵌入式系统中，做Driver和Application开发，哪个更有前途呢
发信站: 北邮人论坛 (Fri May 16 17:23:26 2008), 站内

请问嵌入式系统中，做Driver和Application开发，哪个更有前途呢?

多谢多谢！：）
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 58.247.121.*]
 
【文章标题】：ARM 920T Samsung2440 从cross-tools到 linux2.6.24.4 【文章地址】：https://bbs.byr.cn/article/Embedded_System/373 【创建时间】：2008-05-19 【作者】：fzylijun886 【评论】：0 【内容】：发信人: fzylijun886 (北邮人), 信区: Embedded_System
标  题: ARM 920T Samsung2440 从cross-tools到 linux2.6.24.4
发信站: 北邮人论坛 (Mon May 19 21:39:51 2008), 站内


第一部分不必看了，这个open2440的原理图是开放的
------------------------------------------------------------------------------------------------------------------
1. 为vmware 添加新的硬盘
2. cross  build  principle       

--------------------------------------------------------------------------------

    1)  准备source code  （host：linux   targe：arm－linux）
      binutils-2.18                        <a target="_blank" href="ftp://ftp.ntu.edu.tw/pub/gnu/gnu/binutils/binutils-2.18.tar.bz2">ftp://ftp.ntu.edu.tw/pub/gnu/gnu/binutils/binutils-2.18.tar.bz2</a> 
      gcc-core-4.1.2                   <a target="_blank" href="ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gcc/gcc-4.1.2/gcc-core-4.1.2.tar.bz2">ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gcc/gcc-4.1.2/gcc-core-4.1.2.tar.bz2</a> 
      gcc-g++4.1.2                     <a target="_blank" href="ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gcc/gcc-4.1.2/gcc-g++-4.1.2.tar.bz2">ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gcc/gcc-4.1.2/gcc-g++-4.1.2.tar.bz2</a> 
      glibc-2.6.1                             <a target="_blank" href="ftp://ftp.ntu.edu.tw/pub/gnu//gnu/glibc/glibc-2.6.1.tar.gz">ftp://ftp.ntu.edu.tw/pub/gnu//gnu/glibc/glibc-2.6.1.tar.gz</a> 
      linux-2.6.24.4                       <a target="_blank" href="http://www.cn.kernel.org/pub/linux/kernel/v2.6/linux-2.6.24.4.tar.bz2">http://www.cn.kernel.org/pub/linux/kernel/v2.6/linux-2.6.24.4.tar.bz2</a> 
    

--------------------------------------------------------------------------------
  2)  定义环境变量 (然后解压缩...)

           export PREFIX=/cross/cross-arm           cross gcc的bin会放到这个目录
           export TARGET=arm-linux                          arm 上的linux

          cd /cross/src        假设你下载的gcc 和binutil在这个目录(你当然要解压缩了)
          mkdir build-binutils build-gcc build-glibc
  

--------------------------------------------------------------------------------
   3) binutils (要分清host和target啊...)
         cd /cross/src/build-binutils
         ../binutils-x.xx/configure --target=$TARGET --prefix=$PREFIX --disable-nls 
         make all
         make install
       
          --disable-nls :不要使用汉语吧, 用英语就行了. 这个选项让gcc不输出汉语的提示...
   

--------------------------------------------------------------------------------
  4) bootstrap gcc    
          cd /cross/src/build-gcc
          export PATH=$PATH:$PREFIX/bin
          ../gcc-x.x.x/configure --target=$TARGET --prefix=$PREFIX --disable-nls \
           --enable-languages=c  --without-headers   --disable-shared  --disable-threads --disable-libmudflap --disable-libssp 
           make all-gcc
           make install-gcc
  

-without-headers :这个选项使你编译出的GCC不能使用标准库.(host cpu和target cpu一样的话,基本不用
                                               cross toolchain系统通过编译选项也能实现这个功能).
--with-newlib 这只是个bug的work around,和newlib没有关系的.
This is only necessary if you are compiling GCC &lt;= 3.3.x. That version has a known bug 
that keeps --without-headers from working correctly. Additionally setting --with-newlib 
is a workaround for that bug.   
--enable-languages :tell gcc需要哪些语言支持:font end,   bootstrap gcc only surppot C
tells GCC not to compile all the other language frontends it supports, but only C。
--disable-shared  : 没有这个选项，会有 crti.o: No such file: No such file or directory collect2: ld returned 1 exit status
--disable-thread : 没有这个选项的话会有,  posix_thread.h  can't not found  的问题 . 
--disable-libmudflap --disable-libssp  ：两个边界检查使用的库，有问题，禁止

http://www.mail-archive.com/gcc@gcc.gnu.org/msg31021.html    无libc的时候这几个库是不能编译通过的 ：ssp,mudflap,gomp
http://projects.linuxtogo.org/pipermail/openembedded-commits/2007-November/010465.html  这个线索是这个问题的补丁
还有官方的 bug ：<a target="_blank" href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=25035">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=25035</a> 


   

--------------------------------------------------------------------------------

     5)  prepare linux kernel heads
            
        make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig             配置内核,记着选arm哦
        make ARCH=arm CROSS_COMPILE=arm-linux-                             随意运行下，就能产生version.h autoconf.h 

       cd    linux-2.4.21
       cp   -dR include/asm-arm     $PREFIX/$TARGET/include/asm
       cp   -dR include/linux              $PREFIX/$TARGET/include/linux

      


       在$TARGET/PREFIX/目录中建立下面的符号连接:

           cd $PREFIX/$TARGET
           ln -s include   sys-linux     相当于configure gcc  --with-heads=


      在$TARGET_PREFIX/目录中建立下面的符号连接:
           cd  $PREFIX/$TARGET/include/asm
           ln    -s  arch-s3c2410  arch      其实arch 已经建立了 （make了下，建立好了）
           ln  -s  proc-armv proc           这个版本没proc这个连接了

--------------------------------------------------------------------------------

    6)  build   glibc 
            搞了半天,原来glibc 2.6.1     是不支持arm的， 需要打上一系列的补丁
           glibc-2.6.1-alpha_ioperm_fix-1.patch
            glibc-2.6.1-cross_hacks-1.patch
            glibc-2.6.1-hppa_nptl-1.patch
            glibc-2.6.1-libgcc_eh-1.patch
            glibc-2.6.1-localedef_segfault-1.patch
            glibc-2.6.1-mawk_fix-1.patch
            glibc-2.6.1-RTLD_SINGLE_THREAD_P-1.patch
            glibc-2.6.1-sysdep_cancel-1.patch

    



           推荐补丁下载地址 ： <a target="_blank" href="http://ftp.osuosl.org/pub/clfs/conglomeration/glibc/">http://ftp.osuosl.org/pub/clfs/conglomeration/glibc/</a>
           推荐文章：  <a target="_blank" href="http://blog.chinaunix.net/u/26710/showart_394113.html">http://blog.chinaunix.net/u/26710/showart_394113.html</a>           
           RTLD_SINGLE_THREAD_P 的fix（上面的patch已经包含了，参考下）：                              <a target="_blank" href="http://sources.redhat.com/ml/libc-ports/2006-10/msg00070.html">http://sources.redhat.com/ml/libc-ports/2006-10/msg00070.html</a> 
           
            用 patch -Np1 -i  猛打把，少了那个都编译不过去 ，详细步骤如下
tar xvf glibc-2.6.1.tar.bz2 
 cd glibc-2.6.1/

 tar xvf ../glibc-ports-2.6.1.tar.bz2 
 mv -v glibc-ports-2.6.1 ports

 patch -Np1 -i ../glibc-2.6.1-libgcc_eh-1.patch
 patch -Np1 -i ../glibc-2.6.1-localedef_segfault-1.patch
 patch -Np1 -i ../glibc-2.6.1-cross_hacks-1.patch
 patch -Np1 -i ../glibc-2.6.1-RTLD_SINGLE_THREAD_P-1.patch

             NPTL problem fix: 
             patch for glibc2.4: <a target="_blank" href="http://www.devfiles.jlime.com/parted/glibc/nptl-crosscompile.patch">http://www.devfiles.jlime.com/parted/glibc/nptl-crosscompile.patch</a> 
             The following lines need to be added to config.cache for Glibc to support NPTL:
                    echo "libc_cv_forced_unwind=yes" &gt; config.cache                    echo "libc_cv_c_cleanup=yes" &gt;&gt; config.cache
         最后使用参数--cache-file=config.cache
             还不行，需要把asm-generic copy 到 $PREFIX/$TARGET/include ....   (为啥经验这么重要呢。。)
              

         $ tar -xvzf glibc-2.2.3.tar.gz
         $ tar -xzvf glibc-linuxthreads-2.2.3.tar.gz --directory=glibc-2.2.3

         $ cd build-glibc
         $ CC=arm-linux-gcc ../glibc-2.2.3/configure --host=$TARGET  --prefix=/usr \
                 --with-headers=$PREFIX/$TARGET/include --cache-file=config.cache


             CC=arm-linux-gcc 把 CC 变量设成你刚编译完的boostrap gcc, 用它来编译你的glibc.
             --host=$TARGET 告诉该链接库在目标系统上执行, 而非在本地主机.
             --prefix="/usr" 告诉配置脚本在目标板的根文件系统中glibc的位置.
             --with-headers 告诉glibc 我们的linux 内核头文件的目录位置.
             --enable-add-ons 告诉配置脚本使用我们下载的附加包. 已经将glibc-linuxthreads-2.2.3放入了glibc 源码目录中. 
                 由于我们只添加了一个附加包, 这里--enable-add-ons等价于  --enable-add-ons=linuxthreads. 
                 (如果使用glibc-2.1.x, 需要使用glibc-crypt附加包, 就得使用: --enable-add-ons= linuxthreads, crypt选项). (NPTL 了 )


            $ make
         $ make install_root=$PREFIX/$TARGET  prefix="" install 
        install_root 指定了安装链接库组件的目录, 将glibc安装到与我们项目相关的目录, 而非/usr目录.如果不指定prefix="", 那么glibc会被安装到$/PREFIX/$TARGET/usr/lib目录中. 指定prefix使glibc被安装到 $TARGET_PREFIX/lib目录.

          

--------------------------------------------------------------------------------
7.)修改$PREFIX$TARGET/lib目录中的libc.so
    $ cd $PREFIX/$TARGET/lib
    $ cat libc.so

libc.so的内容:

/* GNU ld script

   Use the shared library, but some functions are only in

   the static library, so try that secondarily.  */

GROUP ( /lib/libc.so.6 /lib/libc_nonshared.a )


将/lib/绝对目录去掉, 既将"GROUP ( /lib/libc.so.6 /lib/libc_nonshared.a )"改为: GROUP ( libc.so.6 libc_nonshared.a )



--------------------------------------------------------------------------------
8)  completed  GCC

  cd build-4.1.2 


  ../gcc-4.1.2/configure --target=arm-linux  --prefix=/cross/cross-arm  --enable-languages=c
  make
  make install 

（出鬼的顺利,不支持c++,gcc 相关补丁也没有打, 凑合先用吧）

--------------------------------------------------------------------------------

9)  simple check
arm-linux-gcc --print-libgcc-file-name
arm-linux-gcc -print-search-dirs
arm-linux-gcc -o test test.c
arm-linux-objdump -D test


--------------------------------------------------------------------------------
10 build kernel for arm
    为了配置方便,copy 一个default config 到linux2.6.24.4 的根目录. 然后就剪辑吧能去的都去掉.嘿嘿.
     
    cp arch/arm/configs/s3c2410_defconfig  .
    mv s3c2410_defconfig .config
    
    menuconfig:
    make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig  

    zImage 出来了, download 到s32440 看看吧.  任意键进入boot menu. 选2 downfrom uart,用DNW下载代码,完成 选4,写入nand flash. (不同系统不一样,看monitor 咋写了)   选boot os............. 操蛋,啥都没看到,
   只是在串口上看到monitor输出如下:
Set boot params = root=/dev/ram init=/linuxrc initrd=0x00000000,0x00000000 console=ttyS1,115200 mem=65536K devfs=mount 
Load Kernel...
Load Ramdisk...

   遇到的问题请继续看下一节...

--------------------------------------------------------------------------------
11 调整解压缩参数
    
    到底啥是最重要的啊, 如果连个printf都不能用,运气未免太差. 参数中的ttyS1 (第10节的输出),俺没有注意到(么经验啊). 于是上ADS 的AXD调试:
    先连接上目标板,然后选run, 这样就可以reboot 系统,选5, boot os, 然后用ADX stop,就会看到一段汇编了. 仔细查看发现arm 确实在运行一段程序,经过查询system.map,发现是panic( 我猜想是root fs没有...,但是没有显示内容到我的串口啊,串口接在uart1上). 
   
     随意看看那个2440 mon程序, linux的加载方式如下:

    将zImage从nand flash copy到 0x3040 0000 然后就jump过去. 内核参数放在0x3000 0100.
    goto_start = 0x3040 0000;
    (*goto_start)(0, 193);    
   不过对为啥不能启动还是没有线索啊...

   有几个比较可疑的内核配置选项可能引起问题比如
         boot option-&gt;
            compressed rom boot loader base address      #&lt;a&gt;
            default kernel command string                      #&lt;b&gt;
   所以俺又试了几个选项, 把 #&lt;a&gt; 的地址改成0x3040 0000...... 不幸还是不可以, 因为没有信息出现也不知道运行到了哪里,不过根据调试的结果,应该是过了解压缩阶段的.... 
   事后俺查上面两个选项的含义( 就是按 ? 了), #&lt;a&gt; 是说ROM able 的zImage, 就是zImage直接在rom中运行时, 才有效所以犯了错误啊. &lt;b&gt; 也不行, 因为如果没有办法传递kernel 的command line时才有效, 而s32440下无效. 帮助里列举有几个平台需要这个选项.

  先把参数地址为啥在0x3000 0100 和runaddr为啥在0x3040 0000跳过不谈,为啥没有任何信息? 连解压内核的信息都没有? 看了几遍config, 找到了如下的选项:
    system type-&gt;
         [0] S3C UART to use for low-level messages     
    嘿嘿,进去把0改成1, 看看arm的相关启动代码,印证了通过这个选项选择内核解压缩信息的输出端口. 选成1, 再试,果然有内核解压缩信息打印出来,呵呵. 相关代码在内核的位置:
decompress_kernel  -&gt; 
    putstr("Uncompressing Linux...");
    gunzip();
    putstr(" done, booting the kernel.\n"); 
-&gt; include/asm-arm/plat-s3c 
static void putc(int ch)
{
    if (uart_rd(S3C2410_UFCON) &amp; S3C2410_UFCON_FIFOMODE) {
    .....
}
uart_rd(unsigned int reg)
{
    volatile unsigned int *ptr;

    ptr = (volatile unsigned int *)(reg + uart_base);
    return *ptr;
}
#define uart_base S3C24XX_PA_UART + (0x4000*CONFIG_S3C_LOWLEVEL_UART_PORT)


--------------------------------------------------------------------------------
12. 内核控制台

   就是命令行里的console参数. 这里不打算讨论console到底是啥, 仅指出,俺没有看到内核正常的启动信息和这个选项大大的相关.我们分析下monitor给出的信息:

Set boot params = root=/dev/ram init=/linuxrc initrd=0x00000000,0x00000000 console=ttyS1,115200 mem=65536K devfs=mount 
Load Kernel...
Load Ramdisk...
  
   这里console设置成了 ttyS1, 而linux2.6.24.4 要求(不知道具体从啥时候开始,2.6?) 名字是ttySAC1,指定串口1. 看monitor的代码就能知道了, monitor需要升级的.  ...走了冤枉路了,明白了monitor和内核这里的一点纠缠.
   升级monitor之后... 嘿嘿,终于有东西了...呵呵


Uncompressing Linux...................................................... done
, booting the kernel.
Linux version 2.6.24.4 (root@localhost.localdomain) (gcc version 4.1.2) #7 
Tue Apr 15 07:50:25 CST 2008
CPU: ARM920T [41129200] revision 0 (ARMv4T), cr=c0007177
Machine: SMDK2410
ATAG_INITRD is deprecated; please update your bootloader.
Memory policy: ECC disabled, Data cache writeback
CPU S3C2440A (id 0x32440001)
S3C244X: core 400.000 MHz, memory 100.000 MHz, peripheral 50.000 MHz
S3C24XX Clocks, (c) 2004 Simtec Electronics
CLOCK: Slow mode (1.500 MHz), fast, MPLL on, UPLL on
CPU0: D VIVT write-back cache
CPU0: I cache: 16384 bytes, associativity 64, 32 byte lines, 8 sets
CPU0: D cache: 16384 bytes, associativity 64, 32 byte lines, 8 sets
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256
Kernel command line: root=/dev/ram init=/linuxrc initrd=0x00000000,0x00000000 
console=ttySAC1,115200 mem=65536K devfs=mount 
irq: clearing pending ext status 000dff00
irq: clearing pending ext status 00001000
irq: clearing subpending status 000000ba
irq: clearing subpending status 00000092
PID hash table entries: 256 (order: 8, 1024 bytes)
timer tcon=00090000, tcnt a2c1, tcfg 00000200,00000000, usec 00001eb8
Console: colour dummy device 80x30
console [ttySAC1] enabled
Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)
Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)
Memory: 64MB = 64MB total
Memory: 63128KB available (1428K code, 223K data, 92K init)
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
S3C2440: Initialising architecture
S3C2440: IRQ Support
S3C2440: Clock Support, DVS off
S3C24XX DMA Driver, (c) 2003-2004,2006 Simtec Electronics
DMA channel 0 at c4800000, irq 33
DMA channel 1 at c4800040, irq 34
DMA channel 2 at c4800080, irq 35
DMA channel 3 at c48000c0, irq 36
JFFS2 version 2.2. (NAND) 漏 2001-2006 Red Hat, Inc.
io scheduler noop registered
io scheduler anticipatory registered (default)
io scheduler deadline registered
io scheduler cfq registered
Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing enabled
s3c2440-uart.0: s3c2410_serial0 at MMIO 0x50000000 (irq = 70) is a S3C2440
s3c2440-uart.1: s3c2410_serial1 at MMIO 0x50004000 (irq = 73) is a S3C2440
s3c2440-uart.2: s3c2410_serial2 at MMIO 0x50008000 (irq = 76) is a S3C2440
RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize
loop: module loaded
S3C24XX NAND Driver, (c) 2004 Simtec Electronics
s3c2440-nand s3c2440-nand: Tacls=3, 30ns Twrph0=7 70ns, Twrph1=3 30ns
NAND device: Manufacturer ID: 0xec, Chip ID: 0x76 (Samsung NAND 64MiB 3,3V 8-
bit)
Scanning device for bad blocks
Creating 8 MTD partitions on "NAND 64MiB 3,3V 8-bit":
0x00000000-0x00004000 : "Boot Agent"
0x00000000-0x00200000 : "S3C2410 flash partition 1"
0x00400000-0x00800000 : "S3C2410 flash partition 2"
0x00800000-0x00a00000 : "S3C2410 flash partition 3"
0x00a00000-0x00e00000 : "S3C2410 flash partition 4"
0x00e00000-0x01800000 : "S3C2410 flash partition 5"
0x01800000-0x03000000 : "S3C2410 flash partition 6"
0x03000000-0x04000000 : "S3C2410 flash partition 7"
mice: PS/2 mouse device common for all mice
S3C24XX RTC, (c) 2004,2006 Simtec Electronics
s3c2440-i2c s3c2440-i2c: slave address 0x10
s3c2440-i2c s3c2440-i2c: bus frequency set to 390 KHz
s3c2440-i2c s3c2440-i2c: i2c-0: S3C I2C adapter
S3C2410 Watchdog Timer, (c) 2004 Simtec Electronics
s3c2410-wdt s3c2410-wdt: watchdog inactive, reset disabled, irq enabled
drivers/rtc/hctosys.c: unable to open rtc device (rtc0)
List of all partitions:
1f00         16 mtdblock0 (driver?)
1f01       2048 mtdblock1 (driver?)
1f02       4096 mtdblock2 (driver?)
1f03       2048 mtdblock3 (driver?)
1f04       4096 mtdblock4 (driver?)
1f05      10240 mtdblock5 (driver?)
1f06      24576 mtdblock6 (driver?)
1f07      16384 mtdblock7 (driver?)
No filesystem could mount root, tried:  cramfs romfs
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(1,0)


--------------------------------------------------------------------------------
13. 内核参数的传递方式

    前边说过monitor吧内核参数放到了地址 0x3000 0100 这个地址. 这个道理何在呢. 先看内核打印内核命令行的地方: init/main.c
asmlinkage void __init start_kernel(void)
     --&gt;printk(KERN_NOTICE "Kernel command line: %s\n", boot_command_line);
     是个全局变量,搜索下,在arch/arm/kernel/setup.c:
void __init setup_arch(char **cmdline_p)
{
    char *from = default_command_line; /*.config 中指定的命令行*/
    ...
    mdesc = setup_machine(machine_arch_type);  /*从上面串口输出知道是 "Machine: SMDK2410", 由.config决定*/
                /*里边引用的lookup_machine_type 在arch/arm/kernel/head_common.S*/
......
    if (__atags_pointer)
        tags = phys_to_virt(__atags_pointer);
    else if (mdesc-&gt;boot_params)
        tags = phys_to_virt(mdesc-&gt;boot_params);    
...
     /*
     * If we have the old style parameters, convert them to
     * a tag list.
     */
    if (tags-&gt;hdr.tag != ATAG_CORE)
        convert_to_tag_list(tags); /*把boot loader传递的参数, arch/arm/kernel/compat.c struct param_struct { 
                                                  ..} 转换成tag list, 其中包括 ATAG_CMDLINE */
    if (tags-&gt;hdr.tag != ATAG_CORE)
        tags = (struct tag *)&amp;init_tags;

    if (mdesc-&gt;fixup) /*s3c2410 是NULL*/
        mdesc-&gt;fixup(mdesc, tags, &amp;from, &amp;meminfo);

    if (tags-&gt;hdr.tag == ATAG_CORE) {
        if (meminfo.nr_banks != 0)
            squash_mem_tags(tags);
        parse_tags(tags); /*ATAG_CMDLINE 的parser 把相应命令行copy 到default_command_line, 也在这个文件内*/ 
    }

    ....
    memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
    boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
    parse_cmdline(cmdline_p, from);
}

这里先忽略下mdesc是怎么被找到的,先直接搜索 mdesc的类型,可以找到 #define MACHINE_START(_type,_name) 这个宏,然后console的"SMDK2410"这个宏定义, 可以在arch/arm/mach-s3c2410下找到:

MACHINE_START(SMDK2410, "SMDK2410") /* @TODO: request a new identifier and switch
                    * to SMDK2410 */
    /* Maintainer: Jonas Dietsche */
    .phys_io    = S3C2410_PA_UART,
    .io_pg_offst    = (((u32)S3C24XX_VA_UART) &gt;&gt; 18) &amp; 0xfffc,
    .boot_params    = S3C2410_SDRAM_PA + 0x100,
    .map_io        = smdk2410_map_io,
    .init_irq    = s3c24xx_init_irq,
    .init_machine    = smdk2410_init,
    .timer        = &amp;s3c24xx_timer,
MACHINE_END

#define S3C2410_SDRAM_PA    (S3C2410_CS6)
#define S3C2410_CS6 (0x30000000)

这下子就知道内核参数传递的方式了: (arm)
   把 arch/arm/kernel/compat.c 中定义的struct param_struct { } 放到0x3000 0100 处即可.... 

至于去求证 monitor 的 runAddr 和参数地址, 请看 :  (这个是monitor用到的参数,决定了runAddrs)

BootParams boot_params = {
    {"bootpara", 1},    //0=boot without parameters,1=boot with parameters
    {"cpuclk",   2},    //0=200M, 1=300M, 2=400M, 3=440M
    {"rundelay", 0},    //0 seconds
    {"serial",   1},    //0=serial port 0, 1=serial port 1
    {"baudrate", 115200},
    {"machine",  193},
    {"runAddr",  0x30400000},
    {"rootfs",   0},
    {"tty",      1},
    {"initrdA",  0},
    {"initrdL",  0},
    {"memsize",  0x04000000},
    {"devfs",    1},
    {"ostore",   0},    //0=nand, 1=nor
    {"userpara", sizeof(DEFAULT_USER_PARAMS)},
    DEFAULT_USER_PARAMS
};
从这个参数加载linux的代码在nand.c LoadRun .


--------------------------------------------------------------------------------

14. 内核加载地址和start参数问题

   从上面的分析, 知道内核被加载到0x30400 0000处, 这个其实是zImage的加载地址, 就是说内核解压缩程序的运行地址. 还有一个问题,我们的内核一直是little endian 的. arm-linux-objdump下就知道. 
   一个问题是Big-endian的内核如何run, 另一个是解压缩程序的运行地址是随意的吗?

  从monitor看, 这个环境一直在little endian运行... (big endian 实验也另作研究吧)

  能否加载到任意合理地址(至少有ram吧,呵呵), 试验一下即可. 结果证明是可以的, 当然应该行,因为zImage已经支持PIC代码,并且可以配置成在纯ROM环境下运行(那就得烧到到固定地址了).  

研究下zImage都包含什么东西,这个先从arch/arm/boot/Makefile看看吧:

$(obj)/compressed/vmlinux: $(obj)/Image FORCE
    $(Q)$(MAKE) $(build)=$(obj)/compressed $@

$(obj)/zImage:    $(obj)/compressed/vmlinux FORCE  #zImage 包含解压缩头的Image
    $(call if_changed,objcopy)
    @echo '  Kernel: $@ is ready'

.......
$(obj)/uImage:    $(obj)/zImage FORCE      # U-boot image
    $(call if_changed,uimage)
    @echo '  Image $@ is ready'

$(obj)/bootp/bootp: $(obj)/zImage initrd FORCE  包含bootp目录的image bootpImage, 如要initrd,这个平台不支持,所以加载    
    $(Q)$(MAKE) $(build)=$(obj)/bootp $@           RamDisk 是monitor的事情了
    @:

$(obj)/bootpImage: $(obj)/bootp/bootp FORCE   #包含bootp目录的image bootpImage
    $(call if_changed,objcopy)
    @echo '  Kernel: $@ is ready'

  
内核解压缩和PIC (position independent code)
arch/arm/boot/compressed/Makefile

#
# We now have a PIC decompressor implementation.  Decompressors running
# from RAM should not define ZTEXTADDR.  Decompressors running directly
# from ROM or Flash must define ZTEXTADDR (preferably via the config)
# FIXME: Previous assignment to ztextaddr-y is lost here. See SHARK
ifeq ($(CONFIG_ZBOOT_ROM),y)  #从boot ROM运行时需要配置一个固定地址,还有BSS的地址
ZTEXTADDR    := $(CONFIG_ZBOOT_ROM_TEXT)
ZBSSADDR    := $(CONFIG_ZBOOT_ROM_BSS)
else
ZTEXTADDR    := 0            #一般情况下,就是0, 是pic代码加上'手工'重定位,加载到任意地址
ZBSSADDR    := ALIGN(4)
endif

SEDFLAGS    = s/TEXT_START/$(ZTEXTADDR)/;s/BSS_START/$(ZBSSADDR)/   
#把vmlinux.lds.in 中TEXT_START换成配置的地址(主要针对ZBOOT_ROM)

targets       := vmlinux vmlinux.lds piggy.gz piggy.o font.o font.c \
         head.o misc.o $(OBJS)
EXTRA_CFLAGS  := -fpic -fno-builtin
EXTRA_AFLAGS  :=
.............
# Don't allow any static data in misc.o, which
# would otherwise mess up our GOT table
CFLAGS_misc.o := -Dstatic=

$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o \
         $(addprefix $(obj)/, $(OBJS)) FORCE
    $(call if_changed,ld)
    @:

$(obj)/piggy.gz: $(obj)/../Image FORCE  #piggy.gz 是压缩后的内核,见piggy.S
    $(call if_changed,gzip)

$(obj)/piggy.o:  $(obj)/piggy.gz FORCE

CFLAGS_font.o := -Dstatic=

$(obj)/font.c: $(FONTC)
    $(call cmd,shipped)

$(obj)/vmlinux.lds: $(obj)/vmlinux.lds.in arch/arm/boot/Makefile .config
    @sed "$(SEDFLAGS)" &lt; $&lt; &gt; $@

$(obj)/misc.o: $(obj)/misc.c include/asm/arch/uncompress.h lib/inflate.c

解压缩的pic技术以后再研究吧,挺多的.这里就是增强下信心吧.  知道可以加载到任意地址,呵呵. 下面看看decompress的入口函数start的参数问题:
arch/arm/boot/compressed/head.S
/*
 * sort out different calling conventions
 */
        .align
start:
        .type    start,#function
        .rept    8
        mov    r0, r0
        .endr

        b    1f
        .word    0x016f2818        @ Magic numbers to help the loader
        .word    start            @ absolute load/run zImage address
        .word    _edata            @ zImage end address
1:        mov    r7, r1            @ save architecture ID
        mov    r8, r2            @ save atags pointer

从这里看出, r1 存放的是architectureID, r2存放 atags 指针. 寄存器传递参数, 加上没有用的r0, 应该是这样一个函数:

void   start(0, archID, *atags)
其实,在arch/arm/kernel/head.S中有关于参数的一段详细的注释,看看就明白了:
/*
 * Kernel startup entry point.
 * ---------------------------
 *
 * This is normally called from the decompressor code.  The requirements
 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags pointer.
 *
 * This code is mostly position independent, so if you link the kernel at
 * 0xc0008000, you call this at __pa(0xc0008000).
 *
 * See linux/arch/arm/tools/mach-types for the complete list of machine
 * numbers for r1.
 *
 * We're trying to keep crap to a minimum; DO NOT add any machine specific
 * crap here - that's what the boot loader (or in extreme, well justified
 * circumstances, zImage) is for.
 */
找到mach-type是:
s3c2440            ARCH_S3C2440        S3C2440            362
不过通过实验, 我们的机器看来是SMDK兼容了,machine 参数必须传递193: SMDK2410 这个才行,而cpu类型则是自动侦测的,呵呵.

对应kernel的参数和decompressed一样:

void (*theKernel)(int zero, int arch, uint params);

另:试了试big endian,发现现在linux kernel对s3c的系统还不支持big模式.make config也无此选项. 


--------------------------------------------------------------------------------
15. initrd : initial ram disk load process
     让我们从新审视所得到的内核console的输出(见上文),看看需要做的东西, 先来关注最后几行的输出信息,内核相关代码是:

start_kernel-&gt;rest_init-&gt;kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);-&gt;
static int __init kernel_init(void * unused)
{
..........
    /*
     * check if there is an early userspace init.  If yes, let it do all
     * the work
     */

    if (!ramdisk_execute_command)  /*由内核命令行参数 rdinit= 来控制,我们没有指定 (搜索就知道是rdinit=来控制了...)*/
        ramdisk_execute_command = "/init";

    if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
        ramdisk_execute_command = NULL;
        prepare_namespace();
    }
 .........
}

内核中有各种__setup宏定义的内核参数, 其前面的字符串是内核命令行, 其后的函数是这个命令行的处理函数,相关的宏定义在init.h中.grep下,很快有结果. 详细讨论先放一放. 
void __init prepare_namespace(void)
{
.............
    if (saved_root_name[0]) {
        root_device_name = saved_root_name; /*这个就是由 root=/dev/ram传递的内核参数,稍作搜索即知*/
        if (!strncmp(root_device_name, "mtd", 3)) { /*我们当然不是这个*/
          .............
        }
        ROOT_DEV = name_to_dev_t(root_device_name); /*/dev/ram 解析出来的设备是 ROOT_DEV= root_RAM0(1,0)*/
        if (strncmp(root_device_name, "/dev/", 5) == 0)
            root_device_name += 5; /* root_dev_name = "ram" */
    }

    if (initrd_load()) /*  CONFIG_BLK_DEV_INITRD 之后才能使用initrd,我们的.config是有的*/
        goto out;
    ......
    mount_root();
out:
    sys_mount(".", "/", NULL, MS_MOVE, NULL);  /*  /root 如何成为根, 何以叫mount root,原来并不是加载 "/" */
    sys_chroot(".");
    security_sb_post_mountroot();
}



int __init initrd_load(void)
{
    if (mount_initrd) { /*只有配置了内核命令行: noinitrd才为0, 我们当然没有'自杀'了*/
        create_dev("/dev/ram", Root_RAM0);  /*创建设备先...*/
        /*
         * Load the initrd data into /dev/ram0. Execute it as initrd
         * unless /dev/ram0 is supposed to be our actual root device,
         * in that case the ram disk is just set up here, and gets
         * mounted in the normal path.
         */
        if (rd_load_image("/initrd.image") &amp;&amp; ROOT_DEV != Root_RAM0) { /*下面看看/initrd.image啥时候创建的*/
            sys_unlink("/initrd.image");
            handle_initrd();
            return 1;
        }
    }
    sys_unlink("/initrd.image");
    return 0;
}

从我们配置的参数是Root_RAM0, 最后 void __init prepare_namespace(void)会调用mount_root:

void __init mount_root(void)
{
#ifdef CONFIG_ROOT_NFS
 ...
#endif
#ifdef CONFIG_BLK_DEV_FD
   ....
#endif
#ifdef CONFIG_BLOCK
    create_dev("/dev/root", ROOT_DEV);
    mount_block_root("/dev/root", root_mountflags); /*有默认值 MS_RDONLY | MS_SILENT*/
#endif
}
void __init mount_block_root(char *name, int flags)
{
    get_fs_names(fs_names); /*所有已经安装的文件系统的名字列表*/
retry:
    for (p = fs_names; *p; p += strlen(p)+1) { /*p代表fs type, 这里name 是/dev/root,就是Root_RAM0*/
        int err = do_mount_root(name, p, flags, root_mount_data); /*(dev,type,mntflags,(rootflags=,给具体文件系统的参数) )*/
        .......
        /*如果失败了,下面的信息倒是没有显示出来....*/
        printk("VFS: Cannot open root device \"%s\" or %s\n",
                root_device_name, b);
        printk("Please append a correct \"root=\" boot option; here are the available partitions:\n");

        printk_all_partitions();
        panic("VFS: Unable to mount root fs on %s", b);
    }

    printk("List of all partitions:\n");
    printk_all_partitions();
    printk("No filesystem could mount root, tried: "); /*列出曾经尝试的文件系统类型*/
    for (p = fs_names; *p; p += strlen(p)+1)
        printk(" %s", p);
    printk("\n");
.......
    panic("VFS: Unable to mount root fs on %s", b); /*知名panic*/
...
}

好了上面的函数就是知名的panic. 这个过程就是将文件/initrd.image 拷贝到Root_RAM0设备内, 然后创建设备文件/dev/root(这个个文件就是为了fs的接口函数准备的),然后将 /dev/root 安装到/root, 最后升级/root到文件系统根目录 '/'.

遇到这个panic从代码上看,是do_mount_root在尝试用各种文件系统来解析/dev/root后竭尽失败.无奈之下,panic的.原因可就多了,比如config的时候没有选上ramdisk支持(设备层), 或者ramdisk中的文件系统内核不支持(文件系统层), 再或者initrd的加载出了问题(无论是boot loader 还是内核创建"/initrd.image", 最后参数传递错误也不成. 经过仔细检查,内核配置和参数传递应该没有啥问题. 这里好多内核的信息没有打印出来,详细的错误也就被隐蔽了. 
  为了验证ramdisk是否正确加载, 在rd_load_image("/initrd.image") 里面加了不少调试信息,结果发现, 根本没有/initrd.image这个文件,在这个函数打开这个文件的时候出错了, 这证明这个文件创建失败了. 原因也很多,不过还是先扫一眼这个文件在什么地方创建.一搜,在这个函数里呢:

static int __init populate_rootfs(void) 这是一个init函数,内核悄悄的运行了他.... (运行的地方好找,不提).
static int __init populate_rootfs(void)
{
 ...  /*解压缩先略过不看...*/
    if (initrd_start) { /*这个就是内核命令行传递进来的值...., 汗...monitor里这个值是0, 显然是不对的啊*/
        /* ...创建 initrd.image 这个文件*/
        fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 0700);
      .......
}

好了一个问题出来了, 改吧, 去monitor的参数里修改一番,也犯了不少错误: 
1) 第一个就是initrd的初始地址不能为0..., 

2) 再有就是有个地方出错比如我设置initrd初始地址0x1000(随意值), 大小是0x1000(随意值,不设置长度monitor不加载ramdisk,只对此monitor有效). 这个地址有傻问题? 看看输出:
Memory policy: ECC disabled, Data cache writeback
initrd (0x00000000 - 0x000003e8) extends beyond physical memory - disabling initrd
CPU S3C2440A (id 0x32440001)
这里又跳出个地方和initrd有关, 位置在bootmem初始化中:(ft...)
arch/arm/mm/init.c
static int __init check_initrd(struct meminfo *mi)
{
.......
    if (phys_initrd_size) {/*最初传递的initrd start 和size都是0, 我ft.... */
         for (i = 0; i &lt; mi-&gt;nr_banks; i++) {
             ...........
         }

    if (initrd_node == -1) {
        printk(KERN_ERR "initrd (0x%08lx - 0x%08lx) extends beyond "
               "physical memory - disabling initrd\n",
               phys_initrd_start, end);
        phys_initrd_start = phys_initrd_size = 0;
    }
..........
}
没有仔细探究这个bank是个什么意思(估计就是2440cpu里对内存bank的划分吧),但是这个警告信息提醒了我.超出物理内存? 不一定是地址太大,呵呵,因为啊, ram物理地址并不是从0开始的,启动的时候是2440 自己吧nand读到了地址0开始的一段内部ram中.....所以,吧initrd
start地址和size设置成一个在RAM地址范围内的一段地址里. 重启,这下,果然不同了........
     出现的信息还是不能加载root文件系统,但是initrd加载成功了, 即ramdisk已经包含了initrd.image, "/initrd.image"文件也已经创建成功了. 但是出现RAMDISK: image too big! (2078xx/4096) ,相关函数是

int __init rd_load_image(char *from) /*从/initrd.image 写入/dev/ram设备*/
{
......
     /*nblocks是从ramdisk image中根据文件系统magic猜测的block数(identify_ramdisk_image),
      *rd_blocks是从/dev/ram设备中读出的数值,ramdisk大小是4096K size ,1024 blocksize,可以配置
      */
    if (nblocks &gt; rd_blocks) { /*这个信息是发现加载的initrd image大小大于ram disk的大小,加载失败*/
        printk("RAMDISK: image too big! (%dKiB/%ldKiB)\n",
               nblocks, rd_blocks);
        goto done;
    }
....
}
另外，建议调试阶段把kernel consolelog 设置成verbose,就是在setup_arch的最前端,调用下面函数:
    console_verbose();
这样一些提示性和continue性质的信息能够显示出来方便调试. 

  这个原因是什么? 根据调试信息打印出来信息, identify_ramdisk_image:RAMDISK: cramfs filesystem found at block 0
显然是发现了一个cramfs,但是不知到是什么原因. 呵呵,秘密是我还没有烧一个initrd进去呢,用的是现有的, 其大小和格式都是未知的.这样当然累了,要知道原因就太难(?), 所以要自己制作一个....


--------------------------------------------------------------------------------
16. 制作ramfs

为了测试,仅制作文件系统..步骤如下:  RDSIZE=1024  BLKSIZE=1024# 为了测试,越小越好,创建一个1M 的ram disk,这样下载快(现在我只有串口)dd if=/dev/zero of=ramdisk.img bs=$BLKSIZE count=$RDSIZE#在其上制作ext2文件系统/sbin/mke2fs -F -m 0 -b $BLKSIZE ramdisk.img $RDSIZE     -F       强制运行,不管是否是块设备/或者已经安装-m 0     设置预留块数量的百分比, 我们可不能浪费,所以一个都不保留....呵呵.-b 1024  一个block 1k下载,运行,呵呵又出错了:try load ram disk /*这是自己加的调试信息*/RAMDISK: ext2 filesystem found at block 0   /*我们制作的是ext2文件系统,这里也认出了*/RAMDISK: Loading 4000KiB [1 disk] into ram disk... done. /*这里看出initrd真是加载成功了,到了ramdisk0中*/load image ret 1   /*这是自己加的调试信息, mount失败*/           原因很明显,我们根本没有编译ext2文件系统支持, 重新配置编译,运行.呵呵根文件系统安装真的成功了.不过,问题还没有完:VFS: Mounted root (ext2 filesystem).Freeing init memory: 92KWarning: unable to open an initial console.Failed to execute /linuxrc.  Attempting defaults...Kernel panic - not syncing: No init found.  Try passing init= option to kernel.这个嘛,嘿嘿,我们的文件系统上啥都没有, 得搞个什么东西上去才行啊. 

--------------------------------------------------------------------------------

16.1 initrd "hello world"   也试了直接编译busybox,可是看起来busybox启动了,但是没有任何输出.查busybox的说明,busybox建议最好自己用cross toolchain搞个hello world试试,看看你能不能运行,不行的话就别搞busybox了,肯定不行啦.   故而,写hello world一个(好久不hello world了):   arm-linux-gcc -static -o test test.c   arm-linux-objcopy -S test test_strip  [这个去掉大部分没有用的段,大大减小bin的大小]   然后用arm-linux-readelf -A test 看看. (aeabi)   在rootfs上(ramdisk.img)建立/dev和必要的设备文件:   mount -t ext2 ramdisk.img /mnt/initrd -o loop   mkdir dev   cp -a /dev/null dev   cp -a /dev/console dev   cp /cross/src/linux2.6.24.4/test_strip linuxrc   [我们的hello world就是linuxrc,呵呵]   sync   umount /mnt/initrd      gzip -9 ramdisk.img       下载, 启动.... 没有看到我熟悉的hello worldVFS: Mounted root (ext2 filesystem).Freeing init memory: 92Kselected clock c01adf24 (pclk) quot 26, calc 115740  google下,发现自己几乎犯过了所有的毛病,先是内核并不支持eabi串口无输出,就编译成支持eabi的内核,结果一样不幸.再google,发现float point emulation必须选一,我没选,选上重来. 最终float point终于解决了这个问题.内核中只能使用浮点模拟,运行大部分的 binaries 都需要浮点支持.   最后hello world终于搞定了. (经测试,没有eabi支持的内核照样可以hello world,以后再研究吧]VFS: Mounted root (ext2 filesystem).Freeing init memory: 92Kselected clock c01adf24 (pclk) quot 26, calc 115740hello world  [这就是我们期待的输出...]


--------------------------------------------------------------------------------

16.2 busy box先编译一个busybox用用,到  <a target="_blank" href="http://www.busybox.net/downloads/">http://www.busybox.net/downloads/</a> 下载最新的1.9.2玩玩.配置的时候选上 don't use /usr,不然make install 就完蛋了make ARCH=arm CROSS_COMPILE=arm-linux- allnoconfigmake ARCH=arm  CROSS_COMPILE=arm-linux- menuconfig  /*只要ash mount echo ls cat ps dmsg sysctl, static 连接*/make  ARCH=arm  CFLAGS="-I/cross/cross-arm/arm-linux/sys-include/" CROSS_COMPILE=arm-linux-make  ARCH=arm  CFLAGS="-I/cross/cross-arm/arm-linux/sys-include/" CROSS_COMPILE=arm-linux- install(需要把applets.c的警告去掉, glibc静态连接不好用,有bug,我们就试试,玩玩, 建议用ulibc,呵呵)然后就开始制作了:# 把我们先前制作的ramdisk.img加载到临时目录mount ramdisk.img /mnt/initrd -t ext2 -o loop=/dev/loop0# busy box 为我们建立好了各种符号连接,copy即可cp -rf  /cross/src/busybox-1.9.2/_install/*  .我们的rootfs就有了 bin sbin 和linuxrc# 然后在ramdisk上建立如下目录mkdir dev# 创建相应的设备文件cp -a /dev/console devcp -a /dev/null dev#cp -a /dev/ttyS0 dev   #没用s3c2410上串口设备是s3c2410_serial1#cp -a /dev/ttyS1 dev   ## 解除安装, 可以压缩的(俺的很小,不压缩也罢!)umount /mnt/initrdgzip -9 ramdisk.img#先搞这么多,先玩一把,下面是输出,爽啊FS: Mounted root (ext2 filesystem).Freeing init memory: 92Kselected clock c01a9df0 (pclk) quot 26, calc 115740selected clock c01a9df0 (pclk) quot 26, calc 115740init started: BusyBox v1.9.2 (2008-04-18 22:44:50 CST)selected clock c01a9df0 (pclk) quot 26, calc 115740command='reboot' action=32 tty=''command='umount -a -r' actselected clock c01a9df0 (pclk) quot 26, calc 115740ion=64 tty=''command='init' action=128 tty=''command='-/bin/sh' action=4 tty=''command='-/bin/sh' action=4 tty='/dev/tty2'command='-/bin/sh' action=4 tty='/dev/tty3'command='-/bin/sh' action=4 tty='/dev/tty4'command='/etc/init.d/rcS' action=1 tty=''starting pid 720, tty '': '/etc/init.d/rcS'Cannot run '/etc/init.d/rcS': No such file or directorywaiting for enter to start '/bin/sh'(pid 721, tty '')Please press Enter to activate this console. Can't open /dev/tty3: No such file or directoryCan't open /dev/tty4: No such file or directoryprocess '-/bin/sh' (pid 724) exited. Scheduling it for restart.process '-/bin/sh' (pid 726) exited. Scheduling it for restart.Can't open /dev/tty3: No such file or directoryCan't open /dev/tty4: No such file or directory(不断重复中,看看需要做的东西还多着呢,不过ash已经启动了...ls可以工作的..呵呵)这个事情有人报告是个bug:<a target="_blank" href="http://groups.google.com/group/linux.debian.bugs">http://groups.google.com/group/linux.debian.bugs</a> 关于这个问题的报告 既然如此,先升级的1.10.1看看, 测试结果:1. applets.c的警告没有了2. make ARCH=arm CROSS_COMPILE=arm-linux-  CFLAGS=-I/cross/cross-arm/arm-linux/sys-linux这次busybox选的东西比较多,弄了个2M的ramdisk, 压缩后399k. ...问题一样地...,好了自己写linuxrc吧.

--------------------------------------------------------------------------------

16.3 为busybox 配置脚本1) 先简单看看各种文件系统的作用吧:tmpfs  :/dev/shm   #share mem对应的文件系统devpts :/dev/pts   #目前最常见的 pseudo 终端(PTYs)实现方式sysfs  :/sys       #sysfs 包含进程相关的proc fs，设备相关的devfs以及为终端相关的devpty fs的信息,是当前趋势,                      由内核内的kobj形成,udev严重依赖于sysf,能够在/dev目录下产生系统真正存在的设备,而不是一锅粥的方式                      sysfs和udev配合,势必要击败devfs+devfsd(?)udev   :           # 需要/etc/udev/rules.d 目录和一堆的配置规则devfs   :/dev         #和devfsd配合使用, devfsd将会负责创建“旧类型”兼容性设备节点；在注册／注销设备时执行自动化操作；                      负责备份对根文件系统上某个目录的设备许可权和所有权的更改，以及其它更多功能proc   :proc       # proc文件系统,不必多说
2) 简单的inuxrc:#!/bin/shecho echo "Open ARM AKAE www.linuxforum.net "echo mount -t proc /proc /proc mount -t sysfs sysfs /sysmount -t devpts devpts /dev/ptsecho "Start mdev..."mdev -s                         /*mdev -s 把设备从sysfs 同步到/dev目录,需要要/etc/mdev.conf*/init                            /*传递给脚本inittab...*/3) /etc/inittabs3c2410_serial1::respawn:-/bin/sh   #/*注意s3c2410上串口的设备名称是/dev/s3c2410_serial[0..3]*/4) /etc/mdev.conf#空文件,有就行,用了在说吧5) 启动信息Open ARM www.linuxforum.net akaeStart mdev...selected clock c0239b70 (pclk) quot 26, calc 115740init started: Busyselected clock c0239b70 (pclk) quot 26, calc 115740Box v1.10.1 (2008-04-19 15:27:01 CST)command='-/bin/sh ' action=2 tty='/dev/s3c2410_serial1'starting pid 229, tty '/dev/s3c2410_serial1': '-/bin/sh 'BusyBox v1.10.1 (2008-04-19 15:27:01 CST) built-in shell (ash)Enter 'help' for a list of built-in commands.#6) Trouble shoot
(1) /bin/sh: can't access tty; job control turned off  busybox 通过系统控制台来做些工作, 如果我们的shell启动在 /dev/console  (5,1)上, tty_io.c 函数open中noctty就被设置成1,导致这个问题,具体原因还不知道.总之要启动在一个真实的串口就没有关系.   解决方法可以通过busybox的init指定shell的设备, 注意, S3C2410上, 串口1是s3c2410_serial1.最终就是在etc/inittab中加入下面一句话就可以了:s3c2410_serial1::respawn:-/bin/sh   #/*注意s3c2410上串口的设备名称是/dev/s3c2410_serial[0..3]*/ (2)busybox的init脚本问题  no tty3 tty4 之类  可以先启动mdev, (mdev -s), 然后运行init就可以了.   就是让/dev/tty0-4 都存在即可.... (具体原因未知)(3) 加载mtdblock3 的jffs2文件系统出现下述信息:   jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x0001001c: 0x3c04   建议:将此分区数据清除,更近一步,加载一个image到这个分区.(4)下载了新内核,ramdisk找不到了  runaddr 和 ramdisk距离太近, 内核解压缩后覆盖了ramdisk... ft

--------------------------------------------------------------------------------

16.4 busy box的init 和各种脚本的分工  看到上面的脚本...写的不咋样,甚至都不符合各种配置文件的具体分工,很不规整. 下面来研究一个比较规整的方案. 下面是google结果(看busybox init的代码?,人生苦短,以后把) 1)在串口上启动 shell    为了避开在busybox "job control"的那个问题, 把/dev/console 直接改成 s3c2410_serial1的设备号,就是:  mknod -m 666 console c 204 65  #204, 64,65,66  然后直接用busybox _install目录下的linuxrc,到busybox的一个软连接,也是启动init.  2)busybox init的流程   简单说,就是执行inittab里指定的命令.具体流程如下:   a)如果没有/etc/inittab,则默认执行/etc/init.d/rcS (见下面说明)   b)执行inittab中动作类型为wait的命令   c)执行inittab中动作类型是once的命令   d)然后进入等待和循环执过程:      .如果一动作为respawn类型的进程退出了,就重新启动它.      .如果动作为askfirst类型的程序退出了,也要重新启动它,但是先询问用户.   busybox的inittab的语法格式是: (examples/inittab)  id:runlevels:action:process id: busybox 用id域指定程序运行的控制台. 如果是串口控制台,id域  runlevels:  busybox根本不使用它   action: 字段定义了该进程应该运行在何种状态下：      sysinit :boot time时执行 (第一此运行init的时候?)      respawn :init 监视其启动的进程,如果退出了,这种类型的进程需要重新启动      askfirst:和respawn差不多,就是要按下回车键才运行      wait    : 要等待其运行完成      once    : 只运行一次      ctrlaltdel : 这个组合键按下时启动.
  busybox init的默认动作:    ::sysinit:/etc/init.d/rcS    ::askfirst:/bin/sh        如果/dev/console 不是串口终端则继续运行:    tty2::askfirst:/bin/sh3) inittab#在pc机上这个inittab本来是定义运行级别来着,这里就简单这么写吧::sysinit:/etc/init.d/rcS console::askfirst:-/bin/sh         #我们把console换成了第一串口4)etc/init.d/rcS#!/bin/shecho echo "Open ARM AKAE-www.linuxforum.net "echo mount -t proc /proc /proc mount -t devpts devpts /dev/ptsecho "Start mdev..."# read the busybox docs: mdev.txt, you need config your kernerl with hotplug surportmount -t sysfs sysfs /sysecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev -s5)一个空的/etc/mdev.conf文件先对付着6)/etc/fstab也没有做    

--------------------------------------------------------------------------------
17.内核启动信息分析

Uncompressing Linux...................................................... done           
, booting the kernel.                                              [arch\arm\boot\compressed\misc.c: decompress_kernel()]
Linux version 2.6.24.4 (root@localhost.localdomain) (gcc version 4.1.2) #7 
Tue Apr 15 07:50:25 CST 2008                                                                                      [init/main.c :start_kernel]
CPU: ARM920T [41129200] revision 0 (ARMv4T), cr=c0007177                   [start_kernel-&gt;setup_arch-&gt;setup_processor]
Machine: SMDK2410                                                                                           [setup_arch-&gt;setup_machine]
Converting old-style param struct to taglist                                  [setup_arch-&gt;convert_to_tag_list-&gt;..-&gt;build_tag_list]
ATAG_INITRD is deprecated; please update your bootloader.                       [setup_arch-&gt;parse_tags-&gt;parse_tag_initrd ]
Memory policy: ECC disabled, Data cache writeback                          [setup_arch-&gt;paging_init-&gt;build_mem_type_table]
On node 0 totalpages: 16384   [setup_arch-&gt;paging_init-&gt;bootmem_init_node-&gt;free_area_init_node-&gt; calculate_node_totalpages]
   DMA zone: 128 pages used for memmap                        [setup_arch-&gt;..-&gt;free_area_init_node-&gt;free_area_init_core]
   DMA zone: 0 pages reserved
   DMA zone: 16256 pages, LIFO batch:3
   Normal zone: 0 pages used for memmap
   Movable zone: 0 pages used for memmap

CPU S3C2440A (id 0x32440001) [setup_arch-&gt;paging_init-&gt;devicemaps_init-&gt;mdesc-&gt;smdk2410_map_io-&gt;s3c24xx_init_io]
S3C244X: core 400.000 MHz, memory 100.000 MHz, peripheral 50.000 MHz [..smdk2410_map_io-&gt;cpu_ids-&gt;s3c244x_init_clocks]
S3C24XX Clocks, (c) 2004 Simtec Electronics                                       [...s3c244x_init_clocks-&gt;s3c24xx_setup_clocks]
CLOCK: Slow mode (1.500 MHz), fast, MPLL on, UPLL on                          [...s3c244x_init_clocks-&gt;s3c2410_baseclk_add]

CPU0: D VIVT write-back cache                                                                [setup_arch-&gt;cpu_init-&gt;dump_cpu_info] CPU0: I cache: 16384 bytes, associativity 64, 32 byte lines, 8 setsCPU0: D cache: 16384 bytes, associativity 64, 32 byte lines, 8 setsBuilt 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256                         [start_kernel-&gt;build_all_zonelists]Kernel command line: root=/dev/ram init=/linuxrc initrd=0x30a00000,0x00100000                  [start_kernel, print cmd line ]console=ttySAC1,115200 mem=65536K devfs=mount irq: clearing pending ext status 000dff00          [start_kernel-&gt;init_IRQ-&gt;init_arch_irq(mdesc-&gt;init_irq)-&gt;s3c24xx_init_irq]irq: clearing pending ext status 00001000          [init_arch_irq 在arm体系下是一个函数指针,setup_arch初始化其为mdesc-&gt;init_irq]irq: clearing subpending status 0000009airq: clearing subpending status 00000092PID hash table entries: 256 (order: 8, 1024 bytes)  [start_kernel-&gt;pidhash_init]timer tcon=00090000, tcnt a2c1, tcfg 00000200,00000000, usec 00001eb8  [start_kernel-&gt;time_init-&gt;system_timer.init-&gt;                                                                                                  s3c2410_timer_init-&gt;s3c2410_timer_setup]        [setup_arch中初始化全局函数指针 system_timer = mdesc-&gt;timer ,既s3c24xx_timer, arch/arm/plat-s3c24xx/timer.c]Console: colour dummy device 80x30                [start_kernel-&gt;console_init-&gt; via lds __con_initcall_start -&gt;vt:con_init]selected clock c0239b70 (pclk) quot 26, calc 115740 [console_initcall(s3c24xx_serial_initconsole)-&gt;register_console-&gt;console.setup-&gt;s3c24xx_serial_console.setup(s3c24xx_serial_console_setup)-&gt;uart_set_options-&gt;s3c24xx_serial_set_termios-&gt;s3c24xx_serial_getclk]console [ttySAC1] enabled                             [console_initcall(s3c24xx_serial_initconsole)-&gt;register_console]Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)                                          [start_kernel-&gt;vfs_caches_init_early]Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)Memory: 64MB = 64MB total                                                                                                             [start_kernel-&gt;mem_init]Memory: 61440KB available (2060K code, 248K data, 108K init)Calibrating delay loop... 199.47 BogoMIPS (lpj=498688)                                                            [start_kernel-&gt;calibrate_delay]Mount-cache hash table entries: 512                                                                      [start_kernel-&gt; vfs_caches_init-&gt;mnt_init]CPU: Testing write buffer coherency: ok                                    [start_kernel-&gt;check_bugs-&gt;check_writebuffer_bugs]net_namespace: 64 bytes                   [start_kernel-&gt;rest_init-&gt;kernel_init-&gt;do_basic_setup-&gt;pure_initcall(net_ns_init)]NET: Registered protocol family 16                                                     [core_initcall(netlink_proto_init)-&gt;sock_register]S3C2440: Initialising architecture                          [arch_initcall(s3c_arch_init)-&gt;(cpu-&gt;init())-&gt;cpu_ids-&gt;s3c2410_init]S3C2440: IRQ Support             [arch_initcall(s3c2440_irq_init)-&gt;sysdev_driver_register-&gt;drv.add()-&gt;s3c2440_irq_add]S3C2440: Clock Support, DVS off                          [arch_initcall(s3c24xx_clk_driver)-&gt;s3c2440_clk_driver.s3c2440_clk_add]S3C24XX DMA Driver, (c) 2003-2004,2006 Simtec Electronics       [arch_initcall(s3c2410_dma_drvinit)-&gt;sysdev_driver_register-&gt;DMA channel 0 at c4800000, irq 33              c2410_dma_driver.s3c2410_dma_add-&gt;s3c2410_dma_init-&gt;s3c24xx_dma_init]DMA channel 1 at c4800040, irq 34DMA channel 2 at c4800080, irq 35DMA channel 3 at c48000c0, irq 36usbcore: registered new interface driver usbfs   [subsys_initcall(usb_init)-&gt;usb_register(&amp;usbfs_driver)-&gt;usb_register_driver]usbcore: registered new interface driver hub    [subsys_initcall(usb_init)-&gt;usb_hub_init(&amp;hub_driver)-&gt;usb_register_driver]usbcore: registered new device driver usb        [subsys_initcall(usb_init)-&gt;usb_register_device_driver(&amp;usb_generic_driver)]NET: Registered protocol family 2                                                                                        [fs_initcall(inet_init)-&gt;sock_register]IP route cache hash table entries: 1024 (order: 0, 4096 bytes)                                [fs_initcall(inet_init)-&gt;ip_init-&gt;ip_rt_init ]TCP established hash table entries: 2048 (order: 2, 16384 bytes)    [fs_initcall(inet_init)-&gt;ip_init-&gt;tcp_init]TCP bind hash table entries: 2048 (order: 1, 8192 bytes)                [fs_initcall(inet_init)-&gt;ip_init-&gt;tcp_init]TCP: Hash tables configured (established 2048 bind 2048)              [fs_initcall(inet_init)-&gt;ip_init-&gt;tcp_init]TCP reno registered                              [fs_initcall(inet_init)-&gt;ip_init-&gt;tcp_init-&gt;tcp_register_congestion_control] checking if image is initramfs...&lt;5&gt;it isn't (no cpio magic); looks like an initrd                  [rootfs_initcall(populate_rootfs)]Freeing initrd memory: 1024K              [rootfs_initcall(populate_rootfs)-&gt;free_initrd-&gt;free_initrd_mem-&gt;free_area]NetWinder Floating Point Emulator V0.97 (extended precision)  [module_init(fpe_init);]JFFS2 version 2.2. (NAND) 漏 2001-2006 Red Hat, Inc.    [module_init(init_jffs2_fs);]io scheduler noop registered                            [module_init(noop_init)-&gt;elv_register]io scheduler anticipatory registered (default)                      [module_init(as_init)-&gt;elv_register]io scheduler deadline registered                     [module_init(deadline_init)-&gt;elv_register]io scheduler cfq registered                                              [module_init(cfq_init)-&gt;elv_register]Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing enabled            [ module_init(serial8250_init)]s3c2440-uart.0: s3c2410_serial0 at MMIO 0x50000000 (irq = 70) is a S3C2440 [module_init(s3c24xx_serial_modinit)-&gt;s3c2440_serial_init-&gt;s3c2440-uart.1: s3c2410_serial1 at MMIO 0x50004000 (irq = 73) is a S3C2440  s3c2440_serial_probe-&gt;uart_add_one_port-&gt;s3c2440-uart.2: s3c2410_serial2 at MMIO 0x50008000 (irq = 76) is a S3C2440  uart_configure_port-&gt;uart_report_port]RAMDISK driver initialized: 2 RAM disks of 4096K size 1024 blocksize                                               [module_init(rd_init);]loop: module loaded                                                                                                               [module_init(loop_init);]S3C24XX NAND Driver, (c) 2004 Simtec Electronics                                          [module_init(s3c2410_nand_init);]s3c2440-nand s3c2440-nand: Tacls=3, 30ns Twrph0=7 70ns, Twrph1=3 30ns  [s3c2440_nand_probes-&gt;3c2410_nand_inithw]NAND device: Manufacturer ID: 0xec, Chip ID: 0x76 (Samsung NAND 64MiB 3,3V 8-bit) [ form above...-&gt;nand_scan_ident nand_get_flash_type]Scanning device for bad blocks   [s3c24xx_nand_probe-&gt;nand_scan -&gt;nand_scan_tail-&gt;chip-&gt;scan_bbt:..-&gt;create_bbt]Creating 4 MTD partitions on "NAND 64MiB 3,3V 8-bit":                       [s3c2410_nand_add_partition-&gt;add_mtd_partitions]0x00000000-0x00030000 : "Boot Agent"0x00030000-0x00200000 : "kernel"0x00200000-0x02000000 : "ramfs"0x02000000-0x04000000 : "extfs"ohci_hcd: 2006 August 04 USB 1.1 'Open' Host Controller (OHCI) Driverohci_hcd: block sizes: ed 64 td 64s3c2410-ohci s3c2410-ohci: s3c2410_start_hc:s3c2410-ohci s3c2410-ohci: S3C24XX OHCIs3c2410-ohci s3c2410-ohci: new USB bus registered, assigned bus number 1s3c2410-ohci s3c2410-ohci: irq 42, io mem 0x49000000s3c2410-ohci s3c2410-ohci: created debug filess3c2410-ohci s3c2410-ohci: OHCI controller states3c2410-ohci s3c2410-ohci: OHCI 1.0, NO legacy support registerss3c2410-ohci s3c2410-ohci: control 0x083 HCFS=operational CBSR=3s3c2410-ohci s3c2410-ohci: cmdstatus 0x00000 SOC=0s3c2410-ohci s3c2410-ohci: intrstatus 0x00000004 SFs3c2410-ohci s3c2410-ohci: intrenable 0x8000005a MIE RHSC UE RD WDHs3c2410-ohci s3c2410-ohci: hcca frame #001es3c2410-ohci s3c2410-ohci: roothub.a 02001202 POTPGT=2 NOCP NPS NDP=2(2)s3c2410-ohci s3c2410-ohci: roothub.b 00000000 PPCM=0000 DR=0000s3c2410-ohci s3c2410-ohci: roothub.status 00008000 DRWEs3c2410-ohci s3c2410-ohci: roothub.portstatus [0] 0x00000100 PPSs3c2410-ohci s3c2410-ohci: roothub.portstatus [1] 0x00000100 PPSusb usb1: default language 0x0409usb usb1: ueventusb usb1: usb_probe_deviceusb usb1: configuration #1 chosen from 1 choiceusb usb1: adding 1-0:1.0 (config #1, interface 0)usb 1-0:1.0: ueventhub 1-0:1.0: usb_probe_interfacehub 1-0:1.0: usb_probe_interface - got idhub 1-0:1.0: USB hub founds3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0xa006,0x2900,0x0000,c3c19a84,000f)hub 1-0:1.0: 2 ports detectedhub 1-0:1.0: standalone hubhub 1-0:1.0: no power switching (usb 1.0)hub 1-0:1.0: no over-current protectionhub 1-0:1.0: power on to power good time: 4mss3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0xa000,0x0000,0x0000,c3c19a40,0004)hub 1-0:1.0: local power source is goodhub 1-0:1.0: trying to enable port power on non-switchable hubs3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0x2303,0x0008,0x0001,c3c19a40,0000)s3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0x2303,0x0008,0x0002,c3c19a40,0000)hub 1-0:1.0: state 7 ports 2 chg 0000 evt 0000usb usb1: new device strings: Mfr=3, Product=2, SerialNumber=1usb usb1: Product: S3C24XX OHCIusb usb1: Manufacturer: Linux 2.6.24.4 ohci_hcdusb usb1: SerialNumber: s3c24xxs3c2410_udc: debugfs dir creation failed -19s3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0xa300,0x0000,0x0001,c3c6fe30,0004)s3c2410-ohci s3c2410-ohci: s3c2410_hub_control(c3c2b400,0xa300,0x0000,0x0002,c3c6fe30,0004)mice: PS/2 mouse device common for all mice                        [module_init(mousedev_init);]S3C24XX RTC, (c) 2004,2006 Simtec Electronics                       [module_init(s3c_rtc_init);]s3c2440-i2c s3c2440-i2c: slave address 0x10    [s3c2440_i2c_driver.s3c24xx_i2c_probe-&gt;s3c24xx_i2c_init]s3c2440-i2c s3c2440-i2c: bus frequency set to 390 KHz   [同上]s3c2440-i2c s3c2440-i2c: i2c-0: S3C I2C adapter                           [s3c2440_i2c_driver.s3c24xx_i2c_probe]S3C2410 Watchdog Timer, (c) 2004 Simtec Electronics   [module_init(watchdog_init);]s3c2410-wdt s3c2410-wdt: watchdog inactive, reset disabled, irq enabledTCP cubic registered          [module_init(cubictcp_register)-&gt;tcp_register_congestion_control]drivers/rtc/hctosys.c: unable to open rtc device (rtc0)   [late_initcall(rtc_hctosys)]RAMDISK: Compressed image found at block 0  [kernel_init-&gt;prepare_namespace-&gt;initrd_load-&gt;rd_load_image-&gt;identify_ramdisk_image]VFS: Mounted root (ext2 filesystem).      [kernel_init-&gt;prepare_namespace-&gt;mount_root-&gt;mount_block_root-&gt;do_mount_root]Freeing init memory: 108Kselected clock c0239b70 (pclk) quot 26, calc 115740  /*以下内容为busybox产生*/selected clock c0239b70 (pclk) quot 26, calc 115740init started: BusyBox v1.10.1 (2008-04-19 15:27:01 CST)selected clock c0239b70 (pclk) quot 26, calc 115740starting pid 225, tty '': '/etc/init.d/rcS'Open ARM AKAE-www.linuxforum.net Start mdev...mount: mounting sysfs on /sys failed: Device or resource busyselected clock c0239b70 (pclk) quot 26, calc 115740starting pid 236, tty '/dev/console': '-/bin/sh 'BusyBox v1.10.1 (2008-04-19 15:27:01 CST) built-in shell (msh)Enter 'help' for a list of built-in commands.


--------------------------------------------------------------------------------

18 .Uart devices register and driver select
1.machine和cpu的检测与uart设备名的设置 

CPU S3C2440A (id 0x32440001) [setup_arch-&gt;paging_init-&gt;devicemaps_init-&gt;mdesc-&gt;smdk2410_map_io-&gt;s3c24xx_init_io]
   mdesc是SMDK2410,smdk2410_map_io-&gt;s3c24xx_init_io根据cpuid设置arm/plat-s3c24xx的全局变量cpu.然后mdk2410_map_io
调用s3c24xx_init_uarts(smdk2410_uartcfgs, ARRAY_SIZE(smdk2410_uartcfgs));通过(cpu-&gt;init_uarts)(cfg, no);注册cpu特的定的uart资源. cpu_ids在arch/arm/plat-s3c24xx/cpu.c中,其中2440a的uart初始化函数是:
void __init s3c244x_init_uarts(struct s3c2410_uartcfg *cfg, int no)
{
    s3c24xx_init_uartdevs("s3c2440-uart", s3c2410_uart_resources, cfg, no);
}
void __init s3c24xx_init_uartdevs(char *name,
                  struct s3c24xx_uart_resources *res,
                  struct s3c2410_uartcfg *cfg, int no)
{
    struct platform_device *platdev;
    struct s3c2410_uartcfg *cfgptr = uart_cfgs;
    struct s3c24xx_uart_resources *resp;
    int uart;

    memcpy(cfgptr, cfg, sizeof(struct s3c2410_uartcfg) * no);

    for (uart = 0; uart &lt; no; uart++, cfg++, cfgptr++) {
        platdev = s3c24xx_uart_src[cfgptr-&gt;hwport];

        resp = res + cfgptr-&gt;hwport;

        s3c24xx_uart_devs[uart] = platdev;  /*uart的platform设备*/

        platdev-&gt;name = name;   /*platform 设备名称初始化为 "s3c2440-uart" */
        platdev-&gt;resource = resp-&gt;resources;
        platdev-&gt;num_resources = resp-&gt;nr_resources;

        platdev-&gt;dev.platform_data = cfgptr;
    }

    nr_uarts = no;
}
然后arch_initcall(s3c_arch_init);-&gt; platform_add_devices(s3c24xx_uart_devs, nr_uarts);注册设备到
platform_bus_type.

2.console 设备初始化

selected clock c0239b70 (pclk) quot 26, calc 115740 [console_initcall(s3c24xx_serial_initconsole)-&gt;register_console-&gt;console.setup-&gt;s3c24xx_serial_console.setup(s3c24xx_serial_console_setup)-&gt;uart_set_options-&gt;s3c24xx_serial_set_termios-&gt;s3c24xx_serial_getclk]console [ttySAC1] enabled                             [console_initcall(s3c24xx_serial_initconsole)-&gt;register_console] 先是根据内核命令行选择并配置一个uart的驱动:static int s3c24xx_serial_initconsole(void)
{
    struct s3c24xx_uart_info *info;
    struct platform_device *dev = s3c24xx_uart_devs[0]; /*上面已经初始化了*/
    ......
    } else if (strcmp(dev-&gt;name, "s3c2440-uart") == 0) {
        info = s3c2440_uart_inf_at;  /*根据设备名称(通过cpu设这的,见上面第一节分析*/
    }
    ........
    s3c24xx_serial_console.data = &amp;s3c24xx_uart_drv; /*选择uart驱动: ttySACx, 204,64-66*/
    s3c24xx_serial_init_ports(info);

    register_console(&amp;s3c24xx_serial_console);
    return 0;
}
然后再根据命令行参数选择uart端口和波特率:
void register_console(struct console *console) /*s3c24xx_serial_console*/
{
    ......
    for (i = 0; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[0];
            i++) {
        if (strcmp(console_cmdline[i].name, console-&gt;name) != 0)
            continue;
        if (console-&gt;index &gt;= 0 &amp;&amp;
            console-&gt;index != console_cmdline[i].index)
            continue;
        if (console-&gt;index &lt; 0)
            console-&gt;index = console_cmdline[i].index;
        if (console-&gt;setup &amp;&amp;
            console-&gt;setup(console, console_cmdline[i].options) != 0) /*options中存的是波特率*/
            break;
        console-&gt;flags |= CON_ENABLED;
        console-&gt;index = console_cmdline[i].index; /*我们的选择是ttySAC1*/
        if (i == selected_console) {
            console-&gt;flags |= CON_CONSDEV;
            preferred_console = selected_console;
        }
        break;
    }
.............
}

3.uart设备驱动初始化

Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing enabled [ module_init(serial8250_init)]
s3c2440-uart.0: s3c2410_serial0 at MMIO 0x50000000 (irq = 70) is a S3C2440 
s3c2440-uart.1: s3c2410_serial1 at MMIO 0x50004000 (irq = 73) is a S3C2440 
s3c2440-uart.2: s3c2410_serial2 at MMIO 0x50008000 (irq = 76) is a S3C2440 
上面三行信息就是uart初始化的信息,具体是在uart_report_port这个函数内打印的.但是通过什么路径确时费了番周折.串口初始化就是
module_init(s3c24xx_serial_modinit)
static int __init s3c24xx_serial_modinit(void)
{
    int ret;

    ret = uart_register_driver(&amp;s3c24xx_uart_drv); /*选择uart驱动: ttySACx, 204,64-66,设备名称s3c2410_serial*/
    if (ret &lt; 0) {
        printk(KERN_ERR "failed to register UART driver\n");
        return -1;
    }
    s3c2400_serial_init();  /*这里有4个cpu的串口初始化函数,到底那个可以成功?*/
    s3c2410_serial_init();  /*这个在配置里选上了*/
    s3c2412_serial_init();
    s3c2440_serial_init();  /*这个也在配置里选上了*/
    return 0;
}
只从打印信息看,当然是选择了2440那个,下面从代码里找这个根据:
static inline int s3c2410_serial_init(void)
{
    return s3c24xx_serial_init(&amp;s3c2410_serial_drv, &amp;s3c2410_uart_inf);
}
static inline int s3c2440_serial_init(void)
{
    return s3c24xx_serial_init(&amp;s3c2440_serial_drv, &amp;s3c2440_uart_inf);
}
static struct platform_driver s3c2410_serial_drv = {
    .probe        = s3c2410_serial_probe,
    .remove        = s3c24xx_serial_remove,
    .suspend    = s3c24xx_serial_suspend,
    .resume        = s3c24xx_serial_resume,
    .driver        = {
        .name    = "s3c2410-uart",
        .owner    = THIS_MODULE,
    },
};
static struct platform_driver s3c2440_serial_drv = {
    .probe        = s3c2440_serial_probe,
    .remove        = s3c24xx_serial_remove,
    .suspend    = s3c24xx_serial_suspend,
    .resume        = s3c24xx_serial_resume,
    .driver        = {
        .name    = "s3c2440-uart",
        .owner    = THIS_MODULE,
    },
};
上面两个初始化函数其实都是调用:
static int s3c24xx_serial_init-&gt;
int platform_driver_register(struct platform_driver *drv)
{
    drv-&gt;driver.bus = &amp;platform_bus_type;
    if (drv-&gt;probe)
        drv-&gt;driver.probe = platform_drv_probe;
    ......
    return driver_register(&amp;drv-&gt;driver);
}
driver_register-&gt;bus_add_driver-&gt;
int bus_add_driver(struct device_driver *drv)
{  
    ......
    if (drv-&gt;bus-&gt;drivers_autoprobe) { /*默认是autoprobe*/
        error = driver_attach(drv);
        if (error)
            goto out_unregister;
    }
  ......
}
driver_attach-&gt;bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach);-&gt;
static int __driver_attach(struct device * dev, void * data)
{
    struct device_driver * drv = data;
    .......
    if (!dev-&gt;driver) /*这里就能找到在第一节中注册的uart dev*/
        driver_probe_device(drv, dev);
    }
    .....
}
int driver_probe_device(struct device_driver * drv, struct device * dev)
{
    int ret = 0;
    if (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))
        goto done;
    ret = really_probe(dev, drv); /* -&gt; dev-&gt;bus-&gt;probe(dev)或者drv-&gt;probe(dev),这个bus没有probe*/
    ....
}
这里终于找到判定一个设备的驱动的条件:platform_bus_type -&gt;platform_match-&gt;就是一个字符创的比较,看设备和驱动的名字是否一致:
strncmp(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE)
翻翻上面注册的名字,当然是2440的驱动胜出. 所以probe就调用了:
s3c2440_serial_probe-&gt;uart_add_one_port-&gt;uart_report_port.

4. uart设备注册后对console设备的影响(register_console只是早期注册给内核printk的)
第二节谈到console的注册:
static int s3c24xx_serial_initconsole(void)
{
    struct platform_device *dev = s3c24xx_uart_devs[0]; /*上面已经初始化了*/
    ......
    s3c24xx_serial_console.data = &amp;s3c24xx_uart_drv; /*选择uart驱动: ttySACx, 204,64-66*/
    register_console(&amp;s3c24xx_serial_console);
    return 0;
}
static struct console s3c24xx_serial_console =
{
    .name        = S3C24XX_SERIAL_NAME,
    .device        = uart_console_device, /*找到此console对应的tty*/
    .flags        = CON_PRINTBUFFER,
    .index        = -1,
    .write        = s3c24xx_serial_console_write,
    .setup        = s3c24xx_serial_console_setup
    .data =  &amp;s3c24xx_uart_drv; 
};
static struct uart_driver s3c24xx_uart_drv = {
    .owner        = THIS_MODULE,
    .dev_name    = "s3c2410_serial",
    .nr        = 3,
    .cons        = S3C24XX_SERIAL_CONSOLE,
    .driver_name    = S3C24XX_SERIAL_NAME,
    .major        = S3C24XX_SERIAL_MAJOR,
    .minor        = S3C24XX_SERIAL_MINOR,
};
这个console只提供了最少的接口供printk使用.见register_console-&gt;release_console_sem.

然后,在第三节谈到的uart设备初始化中:
static int __init s3c24xx_serial_modinit(void)
{
    int ret;

    ret = uart_register_driver(&amp;s3c24xx_uart_drv); /*初始化s3c24xx_uart_drv-&gt;tty_driver*/
     /*初始化tty_driver后uart_console_device就能找到对应tty设备了*/
   ...
}
static inline int s3c2440_serial_init-&gt;s3c24xx_serial_init(&amp;s3c2440_serial_drv, &amp;s3c2440_uart_inf)-&gt; __driver_attach -&gt;...-&gt;really_probe内,将注册的uart platform_device设备进行进一步初始化:dev-&gt;driver = drv;要注意s3c2440_serial_drv是platform_driver,而不是uart_driver:s3c24xx_uart_drv().
--
少说话，多做事！

※ 修改:·fzylijun886 于 May 19 23:33:12 修改本文·[FROM: 59.66.123.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.66.123.*]
 【文章标题】：嵌入式系统 Boot Loader 技术内幕 【文章地址】：https://bbs.byr.cn/article/Embedded_System/391 【创建时间】：2008-05-22 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: 嵌入式系统 Boot Loader 技术内幕
发信站: 北邮人论坛 (Thu May 22 11:45:47 2008), 站内

本文详细地介绍了基于嵌入式系统中的 OS 启动加载程序 ―― Boot Loader 的概念、软件设计的主要任务以及结构框架等内容。
1. 引言

在专用的嵌入式板子运行 GNU/Linux 系统已经变得越来越流行。一个嵌入式 Linux 系统从软件的角度看通常可以分为四个层次： 

1. 引导加载程序。包括固化在固件(firmware)中的 boot 代码(可选)，和 Boot Loader 两大部分。 

2. Linux 内核。特定于嵌入式板子的定制内核以及内核的启动参数。 

3. 文件系统。包括根文件系统和建立于 Flash 内存设备之上文件系统。通常用 ram disk 来作为 root fs。 

4. 用户应用程序。特定于用户的应用程序。有时在用户应用程序和内核层之间可能还会包括一个嵌入式图形用户界面。常用的嵌入式 GUI 有：MicroWindows 和 MiniGUI 懂。 

引导加载程序是系统加电后运行的第一段软件代码。回忆一下 PC 的体系结构我们可以知道，PC 机中的引导加载程序由 BIOS(其本质就是一段固件程序)和位于硬盘 MBR 中的 OS Boot Loader（比如，LILO 和 GRUB 等）一起组成。BIOS 在完成硬件检测和资源分配后，将硬盘 MBR 中的 Boot Loader 读到系统的 RAM 中，然后将控制权交给 OS Boot Loader。Boot Loader 的主要运行任务就是将内核映象从硬盘上读到 RAM 中，然后跳转到内核的入口点去运行，也即开始启动操作系统。 

而在嵌入式系统中，通常并没有像 BIOS 那样的固件程序（注，有的嵌入式 CPU 也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由 Boot Loader 来完成。比如在一个基于 ARM7TDMI core 的嵌入式系统中，系统在上电或复位时通常都从地址 0x00000000 处开始执行，而在这个地址处安排的通常就是系统的 Boot Loader 程序。 

本文将从 Boot Loader 的概念、Boot Loader 的主要任务、Boot Loader 的框架结构以及 Boot Loader 的安装等四个方面来讨论嵌入式系统的 Boot Loader。 



 


2. Boot Loader 的概念

简单地说，Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。 

通常，Boot Loader 是严重地依赖于硬件而实现的，特别是在嵌入式世界。因此，在嵌入式世界里建立一个通用的 Boot Loader 几乎是不可能的。尽管如此，我们仍然可以对 Boot Loader 归纳出一些通用的概念来，以指导用户特定的 Boot Loader 设计与实现。 

1. Boot Loader 所支持的 CPU 和嵌入式板

每种不同的 CPU 体系结构都有不同的 Boot Loader。有些 Boot Loader 也支持多种体系结构的 CPU，比如 U-Boot 就同时支持 ARM 体系结构和MIPS 体系结构。除了依赖于 CPU 的体系结构外，Boot Loader 实际上也依赖于具体的嵌入式板级设备的配置。这也就是说，对于两块不同的嵌入式板而言，即使它们是基于同一种 CPU 而构建的，要想让运行在一块板子上的 Boot Loader 程序也能运行在另一块板子上，通常也都需要修改 Boot Loader 的源程序。 

2. Boot Loader 的安装媒介（Installation Medium）

系统加电或复位后，所有的 CPU 通常都从某个由 CPU 制造商预先安排的地址上取指令。比如，基于 ARM7TDMI core 的 CPU 在复位时通常都从地址 0x00000000 取它的第一条指令。而基于 CPU 构建的嵌入式系统通常都有某种类型的固态存储设备(比如：ROM、EEPROM 或 FLASH 等)被映射到这个预先安排的地址上。因此在系统加电后，CPU 将首先执行 Boot Loader 程序。 

下图1就是一个同时装有 Boot Loader、内核的启动参数、内核映像和根文件系统映像的固态存储设备的典型空间分配结构图。 


图1 固态存储设备的典型空间分配结构
 

3. 用来控制 Boot Loader 的设备或机制

主机和目标机之间一般通过串口建立连接，Boot Loader 软件在执行时通常会通过串口来进行 I/O，比如：输出打印信息到串口，从串口读取用户控制字符等。 

4. Boot Loader 的启动过程是单阶段（Single Stage）还是多阶段（Multi-Stage）

通常多阶段的 Boot Loader 能提供更为复杂的功能，以及更好的可移植性。从固态存储设备上启动的 Boot Loader 大多都是 2 阶段的启动过程，也即启动过程可以分为 stage 1 和 stage 2 两部分。而至于在 stage 1 和 stage 2 具体完成哪些任务将在下面讨论。 

5. Boot Loader 的操作模式 (Operation Mode)

大多数 Boot Loader 都包含两种不同的操作模式："启动加载"模式和"下载"模式，这种区别仅对于开发人员才有意义。但从最终用户的角度看，Boot Loader 的作用就是用来加载操作系统，而并不存在所谓的启动加载模式与下载工作模式的区别。 

启动加载（Boot loading）模式：这种模式也称为"自主"（Autonomous）模式。也即 Boot Loader 从目标机上的某个固态存储设备上将操作系统加载到 RAM 中运行，整个过程并没有用户的介入。这种模式是 Boot Loader 的正常工作模式，因此在嵌入式产品发布的时侯，Boot Loader 显然必须工作在这种模式下。 

下载（Downloading）模式：在这种模式下，目标机上的 Boot Loader 将通过串口连接或网络连接等通信手段从主机（Host）下载文件，比如：下载内核映像和根文件系统映像等。从主机下载的文件通常首先被 Boot Loader 保存到目标机的 RAM 中，然后再被 Boot Loader 写到目标机上的FLASH 类固态存储设备中。Boot Loader 的这种模式通常在第一次安装内核与根文件系统时被使用；此外，以后的系统更新也会使用 Boot Loader 的这种工作模式。工作于这种模式下的 Boot Loader 通常都会向它的终端用户提供一个简单的命令行接口。 

像 Blob 或 U-Boot 等这样功能强大的 Boot Loader 通常同时支持这两种工作模式，而且允许用户在这两种工作模式之间进行切换。比如，Blob 在启动时处于正常的启动加载模式，但是它会延时 10 秒等待终端用户按下任意键而将 blob 切换到下载模式。如果在 10 秒内没有用户按键，则 blob 继续启动 Linux 内核。 

6. BootLoader 与主机之间进行文件传输所用的通信设备及协议

最常见的情况就是，目标机上的 Boot Loader 通过串口与主机之间进行文件传输，传输协议通常是 xmodem／ymodem／zmodem 协议中的一种。但是，串口传输的速度是有限的，因此通过以太网连接并借助 TFTP 协议来下载文件是个更好的选择。 

此外，在论及这个话题时，主机方所用的软件也要考虑。比如，在通过以太网连接和 TFTP 协议来下载文件时，主机方必须有一个软件用来的提供 TFTP 服务。 

在讨论了 BootLoader 的上述概念后，下面我们来具体看看 BootLoader 的应该完成哪些任务。 



 


3. Boot Loader 的主要任务与典型结构框架

在继续本节的讨论之前，首先我们做一个假定，那就是：假定内核映像与根文件系统映像都被加载到 RAM 中运行。之所以提出这样一个假设前提是因为，在嵌入式系统中内核映像与根文件系统映像也可以直接在 ROM 或 Flash 这样的固态存储设备中直接运行。但这种做法无疑是以运行速度的牺牲为代价的。 

从操作系统的角度看，Boot Loader 的总目标就是正确地调用内核来执行。 

另外，由于 Boot Loader 的实现依赖于 CPU 的体系结构，因此大多数 Boot Loader 都分为 stage1 和 stage2 两大部分。依赖于 CPU 体系结构的代码，比如设备初始化代码等，通常都放在 stage1 中，而且通常都用汇编语言来实现，以达到短小精悍的目的。而 stage2 则通常用C语言来实现，这样可以实现给复杂的功能，而且代码会具有更好的可读性和可移植性。 

Boot Loader 的 stage1 通常包括以下步骤(以执行的先后顺序)： 

硬件设备初始化。 


为加载 Boot Loader 的 stage2 准备 RAM 空间。 


拷贝 Boot Loader 的 stage2 到 RAM 空间中。 


设置好堆栈。 


跳转到 stage2 的 C 入口点。 


Boot Loader 的 stage2 通常包括以下步骤(以执行的先后顺序)： 

初始化本阶段要使用到的硬件设备。 


检测系统内存映射(memory map)。 


将 kernel 映像和根文件系统映像从 flash 上读到 RAM 空间中。 


为内核设置启动参数。 


调用内核。 
3.1 Boot Loader 的 stage1

3.1.1 基本的硬件初始化 

这是 Boot Loader 一开始就执行的操作，其目的是为 stage2 的执行以及随后的 kernel 的执行准备好一些基本的硬件环境。它通常包括以下步骤（以执行的先后顺序）： 

1． 屏蔽所有的中断。为中断提供服务通常是 OS 设备驱动程序的责任，因此在 Boot Loader 的执行全过程中可以不必响应任何中断。中断屏蔽可以通过写 CPU 的中断屏蔽寄存器或状态寄存器（比如 ARM 的 CPSR 寄存器）来完成。 

2． 设置 CPU 的速度和时钟频率。 

3． RAM 初始化。包括正确地设置系统的内存控制器的功能寄存器以及各内存库控制寄存器等。 

4． 初始化 LED。典型地，通过 GPIO 来驱动 LED，其目的是表明系统的状态是 OK 还是 Error。如果板子上没有 LED，那么也可以通过初始化 UART 向串口打印 Boot Loader 的 Logo 字符信息来完成这一点。 

5． 关闭 CPU 内部指令／数据 cache。 

3.1.2 为加载 stage2 准备 RAM 空间 

为了获得更快的执行速度，通常把 stage2 加载到 RAM 空间中来执行，因此必须为加载 Boot Loader 的 stage2 准备好一段可用的 RAM 空间范围。 

由于 stage2 通常是 C 语言执行代码，因此在考虑空间大小时，除了 stage2 可执行映象的大小外，还必须把堆栈空间也考虑进来。此外，空间大小最好是 memory page 大小(通常是 4KB)的倍数。一般而言，1M 的 RAM 空间已经足够了。具体的地址范围可以任意安排，比如 blob 就将它的 stage2 可执行映像安排到从系统 RAM 起始地址 0xc0200000 开始的 1M 空间内执行。但是，将 stage2 安排到整个 RAM 空间的最顶 1MB(也即(RamEnd-1MB) - RamEnd)是一种值得推荐的方法。 

为了后面的叙述方便，这里把所安排的 RAM 空间范围的大小记为：stage2_size(字节)，把起始地址和终止地址分别记为：stage2_start 和 stage2_end(这两个地址均以 4 字节边界对齐)。因此： 


stage2_end＝stage2_start＋stage2_size
 


另外，还必须确保所安排的地址范围的的确确是可读写的 RAM 空间，因此，必须对你所安排的地址范围进行测试。具体的测试方法可以采用类似于 blob 的方法，也即：以 memory page 为被测试单位，测试每个 memory page 开始的两个字是否是可读写的。为了后面叙述的方便，我们记这个检测算法为：test_mempage，其具体步骤如下： 

1． 先保存 memory page 一开始两个字的内容。 

2． 向这两个字中写入任意的数字。比如：向第一个字写入 0x55，第 2 个字写入 0xaa。 

3． 然后，立即将这两个字的内容读回。显然，我们读到的内容应该分别是 0x55 和 0xaa。如果不是，则说明这个 memory page 所占据的地址范围不是一段有效的 RAM 空间。 

4． 再向这两个字中写入任意的数字。比如：向第一个字写入 0xaa，第 2 个字中写入 0x55。 

5． 然后，立即将这两个字的内容立即读回。显然，我们读到的内容应该分别是 0xaa 和 0x55。如果不是，则说明这个 memory page 所占据的地址范围不是一段有效的 RAM 空间。 

6． 恢复这两个字的原始内容。测试完毕。 

为了得到一段干净的 RAM 空间范围，我们也可以将所安排的 RAM 空间范围进行清零操作。 

3.1.3 拷贝 stage2 到 RAM 中 

拷贝时要确定两点：(1) stage2 的可执行映象在固态存储设备的存放起始地址和终止地址；(2) RAM 空间的起始地址。 

3.1.4 设置堆栈指针 sp 

堆栈指针的设置是为了执行 C 语言代码作好准备。通常我们可以把 sp 的值设置为(stage2_end-4)，也即在 3.1.2 节所安排的那个 1MB 的 RAM 空间的最顶端(堆栈向下生长)。 

此外，在设置堆栈指针 sp 之前，也可以关闭 led 灯，以提示用户我们准备跳转到 stage2。 

经过上述这些执行步骤后，系统的物理内存布局应该如下图2所示。 

3.1.5 跳转到 stage2 的 C 入口点 

在上述一切都就绪后，就可以跳转到 Boot Loader 的 stage2 去执行了。比如，在 ARM 系统中，这可以通过修改 PC 寄存器为合适的地址来实现。 


图2 bootloader 的 stage2 可执行映象刚被拷贝到 RAM 空间时的系统内存布局
 

3.2 Boot Loader 的 stage2 

正如前面所说，stage2 的代码通常用 C 语言来实现，以便于实现更复杂的功能和取得更好的代码可读性和可移植性。但是与普通 C 语言应用程序不同的是，在编译和链接 boot loader 这样的程序时，我们不能使用 glibc 库中的任何支持函数。其原因是显而易见的。这就给我们带来一个问题，那就是从那里跳转进 main() 函数呢？直接把 main() 函数的起始地址作为整个 stage2 执行映像的入口点或许是最直接的想法。但是这样做有两个缺点：1)无法通过main() 函数传递函数参数；2)无法处理 main() 函数返回的情况。一种更为巧妙的方法是利用 trampoline(弹簧床)的概念。也即，用汇编语言写一段trampoline 小程序，并将这段 trampoline 小程序来作为 stage2 可执行映象的执行入口点。然后我们可以在 trampoline 汇编小程序中用 CPU 跳转指令跳入 main() 函数中去执行；而当 main() 函数返回时，CPU 执行路径显然再次回到我们的 trampoline 程序。简而言之，这种方法的思想就是：用这段 trampoline 小程序来作为 main() 函数的外部包裹(external wrapper)。 

下面给出一个简单的 trampoline 程序示例(来自blob)： 


.text

.globl _trampoline
_trampoline:
    bl    main
    /* if main ever returns we just call it again */
    b    _trampoline
 


可以看出，当 main() 函数返回后，我们又用一条跳转指令重新执行 trampoline 程序――当然也就重新执行 main() 函数，这也就是 trampoline(弹簧床)一词的意思所在。 

3.2.1初始化本阶段要使用到的硬件设备 

这通常包括：（1）初始化至少一个串口，以便和终端用户进行 I/O 输出信息；（2）初始化计时器等。 

在初始化这些设备之前，也可以重新把 LED 灯点亮，以表明我们已经进入 main() 函数执行。 

设备初始化完成后，可以输出一些打印信息，程序名字字符串、版本号等。 

3.2.2 检测系统的内存映射（memory map） 

所谓内存映射就是指在整个 4GB 物理地址空间中有哪些地址范围被分配用来寻址系统的 RAM 单元。比如，在 SA-1100 CPU 中，从 0xC000,0000 开始的 512M 地址空间被用作系统的 RAM 地址空间，而在 Samsung S3C44B0X CPU 中，从 0x0c00,0000 到 0x1000,0000 之间的 64M 地址空间被用作系统的 RAM 地址空间。虽然 CPU 通常预留出一大段足够的地址空间给系统 RAM，但是在搭建具体的嵌入式系统时却不一定会实现 CPU 预留的全部 RAM 地址空间。也就是说，具体的嵌入式系统往往只把 CPU 预留的全部 RAM 地址空间中的一部分映射到 RAM 单元上，而让剩下的那部分预留 RAM 地址空间处于未使用状态。 由于上述这个事实，因此 Boot Loader 的 stage2 必须在它想干点什么 (比如，将存储在 flash 上的内核映像读到 RAM 空间中) 之前检测整个系统的内存映射情况，也即它必须知道 CPU 预留的全部 RAM 地址空间中的哪些被真正映射到 RAM 地址单元，哪些是处于 "unused" 状态的。 

(1) 内存映射的描述 

可以用如下数据结构来描述 RAM 地址空间中的一段连续(continuous)的地址范围：


typedef struct memory_area_struct {
    u32 start; /* the base address of the memory region */
    u32 size; /* the byte number of the memory region */
    int used;
} memory_area_t;
 


这段 RAM 地址空间中的连续地址范围可以处于两种状态之一：(1)used=1，则说明这段连续的地址范围已被实现，也即真正地被映射到 RAM 单元上。(2)used=0，则说明这段连续的地址范围并未被系统所实现，而是处于未使用状态。 

基于上述 memory_area_t 数据结构，整个 CPU 预留的 RAM 地址空间可以用一个 memory_area_t 类型的数组来表示，如下所示： 


memory_area_t memory_map[NUM_MEM_AREAS] = {
    [0 ... (NUM_MEM_AREAS - 1)] = {
        .start = 0,
        .size = 0,
        .used = 0
    },
};
 


(2) 内存映射的检测 

下面我们给出一个可用来检测整个 RAM 地址空间内存映射情况的简单而有效的算法： 


/* 数组初始化 */
for(i = 0; i &lt; NUM_MEM_AREAS; i++)
    memory_map[i].used = 0;

/* first write a 0 to all memory locations */
for(addr = MEM_START; addr &lt; MEM_END; addr += PAGE_SIZE)
    * (u32 *)addr = 0;

for(i = 0, addr = MEM_START; addr &lt; MEM_END; addr += PAGE_SIZE) {
     /*
      * 检测从基地址 MEM_START+i*PAGE_SIZE 开始,大小为
* PAGE_SIZE 的地址空间是否是有效的RAM地址空间。
      */
     调用3.1.2节中的算法test_mempage()；
     if ( current memory page isnot a valid ram page) {
        /* no RAM here */
        if(memory_map[i].used )
            i++;
        continue;
    }
    
    /*
     * 当前页已经是一个被映射到 RAM 的有效地址范围
     * 但是还要看看当前页是否只是 4GB 地址空间中某个地址页的别名？
     */
    if(* (u32 *)addr != 0) { /* alias? */
        /* 这个内存页是 4GB 地址空间中某个地址页的别名 */
        if ( memory_map[i].used )
            i++;
        continue;
    }
    
    /*
     * 当前页已经是一个被映射到 RAM 的有效地址范围
     * 而且它也不是 4GB 地址空间中某个地址页的别名。
     */
    if (memory_map[i].used == 0) {
        memory_map[i].start = addr;
        memory_map[i].size = PAGE_SIZE;
        memory_map[i].used = 1;
    } else {
        memory_map[i].size += PAGE_SIZE;
    }
} /* end of for (…) */
 


在用上述算法检测完系统的内存映射情况后，Boot Loader 也可以将内存映射的详细信息打印到串口。 

3.2.3 加载内核映像和根文件系统映像 

(1) 规划内存占用的布局 

这里包括两个方面：(1)内核映像所占用的内存范围；（2）根文件系统所占用的内存范围。在规划内存占用的布局时，主要考虑基地址和映像的大小两个方面。 

对于内核映像，一般将其拷贝到从(MEM_START＋0x8000) 这个基地址开始的大约1MB大小的内存范围内(嵌入式 Linux 的内核一般都不操过 1MB)。为什么要把从 MEM_START 到 MEM_START＋0x8000 这段 32KB 大小的内存空出来呢？这是因为 Linux 内核要在这段内存中放置一些全局数据结构，如：启动参数和内核页表等信息。 

而对于根文件系统映像，则一般将其拷贝到 MEM_START+0x0010,0000 开始的地方。如果用 Ramdisk 作为根文件系统映像，则其解压后的大小一般是1MB。 

（2）从 Flash 上拷贝 

由于像 ARM 这样的嵌入式 CPU 通常都是在统一的内存地址空间中寻址 Flash 等固态存储设备的，因此从 Flash 上读取数据与从 RAM 单元中读取数据并没有什么不同。用一个简单的循环就可以完成从 Flash 设备上拷贝映像的工作： 

 
while(count) {
    *dest++ = *src++; /* they are all aligned with word boundary */
    count -= 4; /* byte number */
};
 


3.2.4 设置内核的启动参数 

应该说，在将内核映像和根文件系统映像拷贝到 RAM 空间中后，就可以准备启动 Linux 内核了。但是在调用内核之前，应该作一步准备工作，即：设置 Linux 内核的启动参数。 

Linux 2.4.x 以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。启动参数标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。每个标记由标识被传递参数的 tag_header 结构以及随后的参数值数据结构来组成。数据结构 tag 和 tag_header 定义在 Linux 内核源码的include/asm/setup.h 头文件中： 


/* The list ends with an ATAG_NONE node. */
#define ATAG_NONE    0x00000000

struct tag_header {
    u32 size; /* 注意，这里size是字数为单位的 */
    u32 tag;
};
……
struct tag {
    struct tag_header hdr;
    union {
        struct tag_core        core;
        struct tag_mem32    mem;
        struct tag_videotext    videotext;
        struct tag_ramdisk    ramdisk;
        struct tag_initrd    initrd;
        struct tag_serialnr    serialnr;
        struct tag_revision    revision;
        struct tag_videolfb    videolfb;
        struct tag_cmdline    cmdline;

        /*
         * Acorn specific
         */
        struct tag_acorn    acorn;

        /*
         * DC21285 specific
         */
        struct tag_memclk    memclk;
    } u;
};
 


在嵌入式 Linux 系统中，通常需要由 Boot Loader 设置的常见启动参数有：ATAG_CORE、ATAG_MEM、ATAG_CMDLINE、ATAG_RAMDISK、ATAG_INITRD等。 

比如，设置 ATAG_CORE 的代码如下： 


params = (struct tag *)BOOT_PARAMS;

    params-&gt;hdr.tag = ATAG_CORE;
    params-&gt;hdr.size = tag_size(tag_core);

    params-&gt;u.core.flags = 0;
    params-&gt;u.core.pagesize = 0;
    params-&gt;u.core.rootdev = 0;

    params = tag_next(params);
 


其中，BOOT_PARAMS 表示内核启动参数在内存中的起始基地址，指针 params 是一个 struct tag 类型的指针。宏 tag_next() 将以指向当前标记的指针为参数，计算紧临当前标记的下一个标记的起始地址。注意，内核的根文件系统所在的设备ID就是在这里设置的。 

下面是设置内存映射情况的示例代码： 


for(i = 0; i &lt; NUM_MEM_AREAS; i++) {
        if(memory_map[i].used) {
            params-&gt;hdr.tag = ATAG_MEM;
            params-&gt;hdr.size = tag_size(tag_mem32);

            params-&gt;u.mem.start = memory_map[i].start;
            params-&gt;u.mem.size = memory_map[i].size;
            
            params = tag_next(params);
        }
}
 


可以看出，在 memory_map［］数组中，每一个有效的内存段都对应一个 ATAG_MEM 参数标记。 

Linux 内核在启动时可以以命令行参数的形式来接收信息，利用这一点我们可以向内核提供那些内核不能自己检测的硬件参数信息，或者重载(override)内核自己检测到的信息。比如，我们用这样一个命令行参数字符串"console=ttyS0,115200n8"来通知内核以 ttyS0 作为控制台，且串口采用 "115200bps、无奇偶校验、8位数据位"这样的设置。下面是一段设置调用内核命令行参数字符串的示例代码： 


char *p;

    /* eat leading white space */
    for(p = commandline; *p == ' '; p++)
        ;

    /* skip non-existent command lines so the kernel will still
    * use its default command line.
     */
    if(*p == '\0')
        return;

    params-&gt;hdr.tag = ATAG_CMDLINE;
    params-&gt;hdr.size = (sizeof(struct tag_header) + strlen(p) + 1 + 4) &gt;&gt; 2;

    strcpy(params-&gt;u.cmdline.cmdline, p);

    params = tag_next(params);
 


请注意在上述代码中，设置 tag_header 的大小时，必须包括字符串的终止符'\0'，此外还要将字节数向上圆整4个字节，因为 tag_header 结构中的size 成员表示的是字数。 

下面是设置 ATAG_INITRD 的示例代码，它告诉内核在 RAM 中的什么地方可以找到 initrd 映象(压缩格式)以及它的大小： 


    params-&gt;hdr.tag = ATAG_INITRD2;
    params-&gt;hdr.size = tag_size(tag_initrd);
    
    params-&gt;u.initrd.start = RAMDISK_RAM_BASE;
    params-&gt;u.initrd.size = INITRD_LEN;
    
    params = tag_next(params);
 


下面是设置 ATAG_RAMDISK 的示例代码，它告诉内核解压后的 Ramdisk 有多大（单位是KB）： 


params-&gt;hdr.tag = ATAG_RAMDISK;
params-&gt;hdr.size = tag_size(tag_ramdisk);
    
params-&gt;u.ramdisk.start = 0;
params-&gt;u.ramdisk.size = RAMDISK_SIZE; /* 请注意，单位是KB */
params-&gt;u.ramdisk.flags = 1; /* automatically load ramdisk */
    
params = tag_next(params);
 


最后，设置 ATAG_NONE 标记，结束整个启动参数列表： 


static void setup_end_tag(void)
{
    params-&gt;hdr.tag = ATAG_NONE;
    params-&gt;hdr.size = 0;
}
 


3.2.5 调用内核 

Boot Loader 调用 Linux 内核的方法是直接跳转到内核的第一条指令处，也即直接跳转到 MEM_START＋0x8000 地址处。在跳转时，下列条件要满足： 

1． CPU 寄存器的设置： 

R0＝0； 


R1＝机器类型 ID；关于 Machine Type Number，可以参见 linux/arch/arm/tools/mach-types。 


R2＝启动参数标记列表在 RAM 中起始基地址； 


2． CPU 模式： 

必须禁止中断（IRQs和FIQs）； 


CPU 必须 SVC 模式； 


3． Cache 和 MMU 的设置：

MMU 必须关闭； 


指令 Cache 可以打开也可以关闭； 


数据 Cache 必须关闭； 
如果用 C 语言，可以像下列示例代码这样来调用内核： 


void (*theKernel)(int zero, int arch, u32 params_addr) = (void (*)(int, int, u32))KERNEL_RAM_BASE;
……
theKernel(0, ARCH_NUMBER, (u32) kernel_params_start);
 


注意，theKernel()函数调用应该永远不返回的。如果这个调用返回，则说明出错。 



 


4. 关于串口终端

在 boot loader 程序的设计与实现中，没有什么能够比从串口终端正确地收到打印信息能更令人激动了。此外，向串口终端打印信息也是一个非常重要而又有效的调试手段。但是，我们经常会碰到串口终端显示乱码或根本没有显示的问题。造成这个问题主要有两种原因：(1) boot loader 对串口的初始化设置不正确。(2) 运行在 host 端的终端仿真程序对串口的设置不正确，这包括：波特率、奇偶校验、数据位和停止位等方面的设置。 

此外，有时也会碰到这样的问题，那就是：在 boot loader 的运行过程中我们可以正确地向串口终端输出信息，但当 boot loader 启动内核后却无法看到内核的启动输出信息。对这一问题的原因可以从以下几个方面来考虑： 

(1) 首先请确认你的内核在编译时配置了对串口终端的支持，并配置了正确的串口驱动程序。 

(2) 你的 boot loader 对串口的初始化设置可能会和内核对串口的初始化设置不一致。此外，对于诸如 s3c44b0x 这样的 CPU，CPU 时钟频率的设置也会影响串口，因此如果 boot loader 和内核对其 CPU 时钟频率的设置不一致，也会使串口终端无法正确显示信息。 

(3) 最后，还要确认 boot loader 所用的内核基地址必须和内核映像在编译时所用的运行基地址一致，尤其是对于 uClinux 而言。假设你的内核映像在编译时用的基地址是 0xc0008000，但你的 boot loader 却将它加载到 0xc0010000 处去执行，那么内核映像当然不能正确地执行了。 



 


5. 结束语

Boot Loader 的设计与实现是一个非常复杂的过程。如果不能从串口收到那激动人心的"uncompressing linux.................. done, booting the kernel……"内核启动信息，恐怕谁也不能说："嗨，我的 boot loader 已经成功地转起来了！"。


原文链接：<a target="_blank" href="http://goodzyz.blog.hexun.com/3907400_d.html">http://goodzyz.blog.hexun.com/3907400_d.html</a>
--
I remember my grandson asked me the other day, he said: "Grandpa, were you a hero in the great war?"
"No,"I replied,"But I served in a company of heroes."
有一天我的小孙子问我“爷爷，你是大战中的英雄吗？我回答：不......但我与英雄们一同服役。
 北邮嵌入式系统论坛欢迎大家！<a target="_blank" href="http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System">http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System</a>  
北邮嵌入式系统协会 群号：60600133 

※ 修改:·Winters101 于 May 22 11:48:19 修改本文·[FROM: 59.64.186.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 【文章标题】：发个ubuntu的软件升级源 【文章地址】：https://bbs.byr.cn/article/Embedded_System/359 【创建时间】：2008-05-18 【作者】：tjfmail 【评论】：0 【内容】：发信人: tjfmail (PE_passion &amp; energy), 信区: Embedded_System
标  题: 发个ubuntu的软件升级源
发信站: 北邮人论坛 (Sun May 18 21:48:16 2008), 站内

deb <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy main multiverse restricted universe
deb <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-backports main multiverse restricted universe
deb <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-proposed main multiverse restricted universe
deb <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-security main multiverse restricted universe
deb <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-updates main multiverse restricted universe
deb-src <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy main multiverse restricted universe
deb-src <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-backports main multiverse restricted universe
deb-src <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-proposed main multiverse restricted universe
deb-src <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-security main multiverse restricted universe
deb-src <a target="_blank" href="http://debian.ustc.edu.cn/ubuntu/">http://debian.ustc.edu.cn/ubuntu/</a> hardy-updates main multiverse restricted universe 
--
莫听穿林打叶声,何妨吟啸且徐行;
竹杖芒鞋轻胜马,谁怕!一蓑烟雨任平生

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 
【文章标题】：某工程师关于“ 嵌入式Linux入门 ”的建议 【文章地址】：https://bbs.byr.cn/article/Embedded_System/381 【创建时间】：2008-05-20 【作者】：myibm 【评论】：0 【内容】：发信人: myibm (SUN), 信区: Embedded_System
标  题: 某工程师关于“ 嵌入式Linux入门 ”的建议
发信站: 北邮人论坛 (Tue May 20 13:16:41 2008), 站内

      资料来源：西安邮电大学 西邮Linux兴趣小组 maillist
      对于嵌入式Linux入门，如果有一定基础，可以从驱动开始；如果没有基础，我个人建议还是从应用程序开始。因为从应用程序开始是最容易的，也是最直观的。而驱动程序运行在内核态，驱动本身的结构就比较复杂，如果要彻底弄明白驱动的运行机制，必定牵涉内核，对于高年级的学生恐怕问题会少一些，而对于低年级的学生，问题估计较多。我曾经遇到过一些初学者，就是一入门就栽了，失去了信心，当然这只是少数。不过，如果在遇到问题之后，能够得到即时、正确的点化，那就是好事了。
      既然您决定讲驱动，那就从内核模块开始。在PC上就可以进行的虚拟设备实验，如基于内存的内核模块。可以考虑从模块的结构、编译、插入、卸载等方面进行阐述。
      驱动模块无非分字符驱动、块设备驱动和网络驱动三大类。但是一定要让学生知道，任何一个系统，特别是嵌入式系统，并且在目前的嵌入式Linux产品开发中，最简单、最重要、最多、最复杂的也是字符设备驱动，从IO驱动到串口驱动、到USB驱动等等，广义上都是字符驱动。让学生最好专注于字符设备驱动，因为一个嵌入式设备，网卡一般一块，FLASH一般也是一块（也包括几块组成的FLASH组），但是这两方面，基本都有完善的驱动，如网卡驱动有很
多，块设备驱动，硬件层已经有通用接口，不管是NOR FLASH还是NAND FLASH，文件系统层更是有了非常多、非常成熟的文件系统，如JFFS2、YAFFS、YAFFS2、EXT2、EXT3、ROMFS、CRAMFS等等，无需我们再去研究，学会应用即可。而除此之外的其它设备，如AD、DA、CAN、RS485等等，都是需要根据应用来进行设计的，这才是一个产品区别于其它产品的重点，更是市场价值增值点。
      另外呢，也是前一点引申为而来的，学习Linux，准备做产品的话，不要把Linux当成了终极目标（当然，这是对应用而言的），要有只是把Linux当成一个平台的思想。更重要的还在各种产品所需求的专业技术，如通信方面像CAN、RS485、GPRS等等，或者工业控制方面，IO控制、实时特性等等。Linxu博大精深，研究起来永无止境，但是在产品中，只要到了一个产品够用就可以了（当然，多一些更好，要视人而定）。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.235.232.*]
 
【文章标题】：弱弱的问一下,下载的bootloader文件没有mcp文件,如何用ads来编 【文章地址】：https://bbs.byr.cn/article/Embedded_System/246 【创建时间】：2008-05-14 【作者】：seuamos 【评论】：1 【内容】：发信人: seuamos (amos), 信区: Embedded_System
标  题: 弱弱的问一下,下载的bootloader文件没有mcp文件,如何用ads来编译之
发信站: 北邮人论坛 (Wed May 14 10:37:11 2008), 站内

我用ads每次只能打开vivi中的其中一个文件,

在ads建了一个mcp文件,然后再把vivi中的文件一个一个加进来?然后再编译?
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 121.248.10.*]
 

【文章标题】：自由软件运动5.24-5.31 【文章地址】：https://bbs.byr.cn/article/Embedded_System/380 【创建时间】：2008-05-20 【作者】：tjfmail 【评论】：0 【内容】：发信人: tjfmail (PE_passion &amp; energy), 信区: Embedded_System
标  题: 自由软件运动5.24-5.31
发信站: 北邮人论坛 (Tue May 20 08:46:56 2008), 站内

Richard Stallman在1983年发起了自由软件运动。经过25年的发展，自由软件已经在各个领域取得了巨大的成功。在我们的日常生活和工作中，自由软件已经 成为不可或缺的一部分。
为了帮助中国自由软件社区，甚至整个IT产业充分理解自由软件，哲思自由软件社区将于2008年5月24日－5月31日在北京、上海和西安三地分别 举办"2008年哲思自由软件峰会"。参加此次峰会的演讲嘉宾有：Richard Stallman、倪光南、霍亮、王星耀、Akira Urushibata、李欣、徐继哲等。峰会的赞助商是SUN，Intel和新浪网；峰会的合作伙伴是：自由软件基金会、GNU工程、互动在线、华章公 司、TechWeb、China-Pub、CSDN、清华大学、Unix-Center.net、ChinaUnix.net等。
哲思自由软件峰会是开放式活动，参会者不需提前报名，免费参加。欢迎大家踊跃参加哲思自由软件峰会！
关于哲思自由软件峰会的详细信息请访问哲思自由软件社区网站：<a target="_blank" href="http://www.zeuux.org">http://www.zeuux.org</a>。
http://www.zeuux.org/campaign/zeuux-freedom-summit-2008.cn.html
徐继哲
哲思自由软件社区
[Beijing, China May 15, 2008 ZEUUX Free Software Community] What is Free Software? Free software is a matter of the users' freedom to run, copy, distribute, study, change and improve the software. More precisely, it refers to four kinds of freedom, for the users of the software: 
0.The freedom to run the program, for any purpose (freedom 0). 
1.The freedom to study how the program works, and adapt it to your needs (freedom 1). Access to the source code is a precondition for this. 
2.The freedom to redistribute copies so you can help your neighbor (freedom 2). 
3.The freedom to improve the program, and release your improvements to the public, so that the whole community benefits (freedom 3). Access to the source code is a precondition for this. 
Richard Stallman launched the Free Software Movement in 1983. Through the evolution of 25 years, Free Software has achieved great the successes in many fields and has been an essential part of our living and working.
To help China Free Software community or even the whole IT industry to understand what is Free Software, ZEUUX Free Software Community will hold the ZEUUX Free Software Summit 2008 in Beijing, Shanghai and Xi'an from May 24 to May 31, 2008. Speakers attending this summit are Richard Stallman, Ni Guangnan, Leon Huo, Sin-Yaw Wang, Akira Urushibata, Li Xin, Bill Xu and so on. The patrons of the summit are Sun Mirosystem and Intel, and SINA.com. The cooperators are Free Software Foundation, GNU Project, Hoodong.com, HZ Books, Techweb.com.cn, China-Pub.com, CSDN.net, Tsinghua University, Unix-Center.net, ChinaUnix.net and so on.
ZEUUX Free Software Summit is an open conference. It is no need to sign up and anyone can join it without fees. It's pleased for anyone to join the ZEUUX Free Software Summit 2008.
For more details of ZEUUX Free Software Summit 2008, please refer to the website of ZEUUX Free Software Community, <a target="_blank" href="http://www.zeuux.org.">http://www.zeuux.org.</a>
http://www.zeuux.org/campaign/zeuux-freedom-summit-2008.html
Bill Xu
ZEUUX Free Software Community
--
莫听穿林打叶声,何妨吟啸且徐行;
竹杖芒鞋轻胜马,谁怕!一蓑烟雨任平生

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 

【文章标题】：[合集] [转帖]不要一辈子靠技术生存 【文章地址】：https://bbs.byr.cn/article/Embedded_System/393 【创建时间】：2008-05-22 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: [合集] [转帖]不要一辈子靠技术生存
发信站: 北邮人论坛 (Thu May 22 11:56:00 2008), 站内

☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Thu May 15 00:07:01 2008)  提到:

来源：世界经理人 
　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊). 

一、 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事 市场开发，跑腿的人，没有前途。 

　　不知道你是不是知道，咱们中国有相当大的一部分软件公司，他们的软件开发团队都小的可怜，甚至只有1-3个人，连一个项目小组都算不上，而这样的团队却要承担一个软件公司所有的软件开发任务，在软件上线和开发的关键阶段需要团队的成员没日没夜的加班，还需要为测试出的BUG和不能按时提交的软件模块功能而心怀忐忑，有的时候如果你不幸加入现场开发的团队你则需要背井离乡告别你的女友，进行封闭开发，你平时除了编码之外就是吃饭和睡觉（有钱的公司甚至请个保姆为你做饭，以让你节省出更多的时间来投入到工作中，让你一直在那种累了就休息，不累就立即工作的状态） 

　　更可怕的是，会让你接触的人际关系非常单一，除了有限的技术人员之外你几乎见不到做其他行业工作和职位的人，你的朋友圈子小且单一，甚至破坏你原有的爱情（想象一下，你在外地做现场开发2个月以上，却从没跟女友见过一面的话，你的女友是不是会对你呲牙裂嘴）。 

　　也许你拿到了所谓的白领的工资，但你却从此失去享受生活的自由，如果你想做技术人员尤其是开发人员，我想你很快就会理解，你多么想在一个地方长期待一段时间，认识一些朋友，多一些生活时间的愿望。 

　　比之于我们的生活和人际关系及工作，那些从事售前和市场开发的朋友，却有比我们多的多的工作之外的时间，甚至他们工作的时间有的时候是和生活的时间是可以兼顾的，他们可以通过市场开发，认识各个行业的人士，可以认识各种各样的朋友，他们比我们坦率说更有发财和发展的机会，只要他们跟我们一样勤奋。（有一种勤奋的普通人，如果给他换个地方，他马上会成为一个勤奋且出众的人。） 

二、在学习技术的时候千万不要认为如果做到技术最强，就可以成为100%受尊重的人。 

　　有一次一个人在面试项目经理的时候说了这么一段话：我只用最听话的人，按照我的要求做只要是听话就要，如果不听话不管他技术再好也不要。随后这个人得到了试用机会，如果没意外的话，他一定会是下一个项目经理的继任者。 

　　朋友们你知道吗？不管你技术有多强，你也不可能自由的腾出时间象别人那样研究一下Linux源码，甚至写一个Linux样的杰作来表现你的才能。你需要做的就是按照要求写代码，写代码的含义就是都规定好，你按照规定写，你很快就会发现你昨天写的代码，跟今天写的代码有很多类似，等你写过一段时间的代码，你将领略：复制，拷贝，粘贴那样的技术对你来说是何等重要。（如果你没有做过1年以上的真正意义上的开发不要反驳我）。 

　　如果你幸运的能够听到市场人员的谈话，或是领导们的谈话，你会隐约觉得他们都在把技术人员当作编码的机器来看，你的价值并没有你想象的那么重要。而在你所在的团队内部，你可能正在为一个技术问题的讨论再跟同事搞内耗，因为他不服你，你也不服他，你们都认为自己的对，其实你们两个都对，而争论的目的就是为了在关键场合证明一下自己比对方技术好，比对方强。（在一个项目开发中，没有人愿意长期听别人的，总想换个位置领导别人。） 

三、你更不要认为，如果我技术够好，我就自己创业，自己有创业的资本，因为自己是搞技术的。 

　　如果你那样认为，真的是大错特错了，你可以做个调查在非技术人群中，没有几个人知道C#与JAVA的，更谈不上来欣赏你的技术是好还是不好。一句话，技术仅仅是一个工具，善于运用这个工具为别人干活的人，却往往不太擅长用这个工具来为自己创业，因为这是两个概念，训练的技能也是完全不同的。 

　　创业最开始的时候，你的人际关系，你处理人际关系的能力，你对社会潜规则的认识，还有你明白不明白别人的心，你会不会说让人喜欢的话，还有你对自己所提供的服务的策划和推销等等，也许有一万，一百万个值得我们重视的问题，但你会发现技术却很少有可能包含在这一万或一百万之内，如果你创业到了一个快成功的阶段，你会这样告诉自己：我干吗要亲自做技术，我聘一个人不就行了，这时候你才真正会理解技术的作用，和你以前做技术人员的作用。 

[小结] 

　　基于上面的讨论，我奉劝那些学习技术的朋友，千万不要拿科举考试样的心态去学习技术,对技术的学习几近的痴迷，想掌握所有所有的技术，以让自己成为技术领域的权威和专家，以在必要的时候或是心里不畅快的时候到网上对着菜鸟说自己是前辈。 

　　技术仅仅是一个工具，是你在人生一个阶段生存的工具，你可以一辈子喜欢他，但最好不要一辈子靠它生存。 

　　掌握技术的唯一目的就是拿它找工作（如果你不想把技术当作你第二生命的话），就是干活。所以你在学习的时候千万不要去做那些所谓的技术习题或是研究那些帽泡算法，最大数算法了，什么叫干活？ 

　　就是做一个东西让别人用，别人用了，可以提高他们的工作效率，想象吧，你做1万道技术习题有什么用？只会让人觉得酸腐，还是在学习的时候，多培养些自己务实的态度吧，比如研究一下当地市场目前有哪些软件公司用人，自己离他们的要求到底有多远，自己具体应该怎么做才可以达到他们的要求。等你分析完这些，你就会发现，找工作成功，技术的贡献率其实并没有你原来想象的那么高。 

　　不管你是学习技术为了找工作还是创业，你都要对技术本身有个清醒的认识，在中国不会出现BILL GATES，因为，中国目前还不是十分的尊重技术人才，还仅仅的停留在把软件技术人才当作人才机器来用的尴尬境地。（如果你不理解，一种可能是你目前仅仅从事过技术工作，你的朋友圈子里技术类的朋友占了大多数，一种可能是你还没有工作，但喜欢读比尔。盖茨的传记）。


☆─────────────────────────────────────☆
   PtwCJ (鲜的每日C|头像不是我，我是长毛贼~~) 于  (Thu May 15 00:15:47 2008)  提到:

题目还不错


☆─────────────────────────────────────☆
   pan903 (盼统一) 于  (Thu May 15 08:52:04 2008)  提到:

有些道理


☆─────────────────────────────────────☆
   vvf (目标160！) 于  (Thu May 15 09:08:28 2008)  提到:

不错，有点启发


☆─────────────────────────────────────☆
   wfm8326 (xmm) 于  (Thu May 15 09:26:46 2008)  提到:

体会生活现实


☆─────────────────────────────────────☆
   shevsnba (我心飞翔) 于  (Thu May 15 10:42:36 2008)  提到:

有点启发


☆─────────────────────────────────────☆
   bluebear (bluebear) 于  (Thu May 15 10:44:33 2008)  提到:

现实如此！


☆─────────────────────────────────────☆
   flyingmiao (amiao) 于  (Thu May 15 11:00:28 2008)  提到:

路不同而已，没有对错


☆─────────────────────────────────────☆
   huanqing (超级无敌小松鼠) 于  (Thu May 15 11:10:10 2008)  提到:

顶，感觉说的很有道理，深有同感~


☆─────────────────────────────────────☆
   lmb198716 (流浪の风) 于  (Thu May 15 11:20:31 2008)  提到:

个人觉得技术是个踏脚石，尤其是对没背景没后台的普通人~~但职业生涯最终还是要进入金融或者管理行业，不能做一辈子的技术


☆─────────────────────────────────────☆
   Winters101 (Winters) 于  (Thu May 15 11:22:44 2008)  提到:

是啊，有背景有后台谁还去做技术啊？就是有一张能说会道的嘴的人也不会去做技术啊。做技术的都是一些。。。人
【 在 lmb198716 (流浪の风) 的大作中提到: 】
: 个人觉得技术是个踏脚石，尤其是对没背景没后台的普通人~~但职业生涯最终还是要进入金融或者管理行业，不能做一辈子的技术 




☆─────────────────────────────────────☆
   shine0134 (shinebupt) 于  (Thu May 15 11:36:01 2008)  提到:

支持，得自己去领悟


☆─────────────────────────────────────☆
   yihang (Goodluckfly) 于  (Thu May 15 12:24:12 2008)  提到:


【 在 lmb198716 的大作中提到: 】
: 个人觉得技术是个踏脚石，尤其是对没背景没后台的普通人~~但职业生涯最终还是要进入金融或者管理行业，不能做一辈子的技术 

嗯，技术对很多人来说也只能年轻的时候搞一下，老了就吃不消了
技术也是一种至少饿不着的本领


☆─────────────────────────────────────☆
   xiaocangMM (小苍MM) 于  (Thu May 15 12:39:38 2008)  提到:

连某些导师都…………
况乎资本家？


☆─────────────────────────────────────☆
   losting (the veils) 于  (Thu May 15 13:49:22 2008)  提到:

貌似真实情况差不多就是这样的~~~


☆─────────────────────────────────────☆
   keceel (keceel) 于  (Thu May 15 14:23:50 2008)  提到:

跟我想的一样，在中国的企业里，至少现在这种情况还是非常普遍的！


☆─────────────────────────────────────☆
   zhyie (zhyie) 于  (Thu May 15 14:49:22 2008)  提到:

写得很中肯


☆─────────────────────────────────────☆
   wangkunyyxf (鱼鱼) 于  (Thu May 15 16:22:10 2008)  提到:

同感


☆─────────────────────────────────────☆
   labi (猫猫) 于  (Thu May 15 16:24:00 2008)  提到:

学习了。


☆─────────────────────────────────────☆
   advanceroot (我即我) 于  (Thu May 15 16:25:42 2008)  提到:

本来就是件谁爱谁选择，谁承担自己选择后果的问题，没有对错。
但实在看不过眼，总有些这种人胡乱忽悠，不知目的何在。
说白了不就是你认为做技术赚得钱性价比太低么。
国内软件业的浮躁就是因为总存在这种只知道摇头呐喊的人。
大家都不做工程师，谁去做工程师？
国外上年纪的工程师多了去了，工程师的经验支撑着知识经济啊，并且好多创新不在技术领域扎实10年以上根本出不来。国内都被US的技术忽悠，被人家牵着走，想过为什么吗？照搂住的说法，就是大家都做非技术，养家糊口，技术让别人干就行了。这行吗？
国内现在还比不了，一方面是国内起步晚，工程师大都还算年轻，另一方面产业环境也比较浮躁。但以后会变好的。

楼主的话中暗含两个意思：
1。谁赚钱多，赚钱轻松就是生存得好 
2。技术让哪些傻子做吧，我管赚钱就好了

还有那句“冒泡算法”，我问下，你连冒泡算法都不学，你能把“技术仅仅是一个工具，是你在人生一个阶段生存的工具”吗？


☆─────────────────────────────────────☆
   sambob (喜欢逛) 于  (Thu May 15 17:07:24 2008)  提到:

已经算不错了，lz似乎还没看过更多北航、北理、西电之类的同学还达不到这个层次呢，去看看兵器、航天、航空企业就知道这已经很好了，他们不但是机器，而且基本没法跳槽，工资低的没法形容，我认识一个05级北理的师姐（硕士），在一航工作三年每月才拿到4500，而且没法跳槽（他们没有养老保险，只拿退休金），升上去也没希望。。。在航天企业就更加了，有的部门工资的确不低，但是他们加班绝对是所有外企比不上的，没有周末、没有假期、没有加班工资（这些企业完全不用遵守法律，国家也基本不管，太恐怖了）不知出于那个位置的为国家做贡献的人是怎么忍受的，估计他们看这个问题是会觉得我们北邮的已经很幸福了把


☆─────────────────────────────────────☆
   yegle (一阁|博学之人|奇峰怪石,秀山丽水) 于  (Thu May 15 17:09:55 2008)  提到:

赞QMD！

【 在 sambob (喜欢逛) 的大作中提到: 】
: 已经算不错了，lz似乎还没看过更多北航、北理、西电之类的同学还达不到这个层次呢，去看看兵器、航天、航空企业就知道这已经很好了，他们不但是机器，而且基本没法跳槽，工资低的没法形容，我认识一个05级北理的师姐（硕士），在一航工作三年每月才拿到4500，而且没法跳 




☆─────────────────────────────────────☆
   AirJay (★六灵寺★AirJay★彩云之男★) 于  (Thu May 15 17:18:50 2008)  提到:

有一些道理


☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Thu May 15 18:35:47 2008)  提到:

没看到是转贴么？怎么都冲我来了～～
我不否认这篇帖子有一定的片面性，不过你说的也有问题。
1.国外做技术的都是喜欢技术，国内则普遍不是
2.国外做技术的薪水高，国内则是技术水平很高但工资不成比例，性价比较低
3.公司里确实普遍做的是重复性的工作，其实想法比技术更重要
过多的就不说了，希望您说话讲求点方法，别这么愤青：）
【 在 advanceroot 的大作中提到: 】
: 本来就是件谁爱谁选择，谁承担自己选择后果的问题，没有对错。 
: 但实在看不过眼，总有些这种人胡乱忽悠，不知目的何在。 
: 说白了不就是你认为做技术赚得钱性价比太低么。 
: ................... 



☆─────────────────────────────────────☆
   flyingmiao (amiao) 于  (Thu May 15 18:39:14 2008)  提到:

爬到这页，我发现这帖也变成技术帖了。
见仁见智。
如果衡量职业的标准只是待遇之类的话，我只能说此类人有些悲哀了。


☆─────────────────────────────────────☆
   macboat (Tea) 于  (Thu May 15 19:17:20 2008)  提到:

任正非 柳传志 唐骏 比尔盖茨 杰克韦尔奇 ……
做技术可以让人快乐并产生价值   只是原创没到那个境界罢了


☆─────────────────────────────────────☆
   teamo (云漫天涯) 于  (Thu May 15 19:25:38 2008)  提到:

恩，很关心IT界人士40岁之后都干嘛去了
【 在 fzylijun886 (北邮人) 的大作中提到: 】
: 来源：世界经理人  
: 　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊).  
: 一、 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事 市场开发，跑腿的人，没有前途。  
: ................... 



☆─────────────────────────────────────☆
   freshman (freshman) 于  (Thu May 15 19:43:47 2008)  提到:


【 在 macboat 的大作中提到: 】
: 任正非 柳传志 唐骏 比尔盖茨 杰克韦尔奇 …… 
: 做技术可以让人快乐并产生价值   只是原创没到那个境界罢了 

兄弟，先问问你自己，你崇拜这些人，是因为他们有着很牛的技术创造了相当了不起的产品呢？ 还是因为他们实实在在的缔造了一个个伟大的企业。



☆─────────────────────────────────────☆
   zzg1987102 (明日帝国) 于  (Thu May 15 20:19:36 2008)  提到:

纠正一点 不是中国能否出比尔盖茨的问题  而在于 盖茨的成功并不是完全依赖技术，而是他鹰一般的市场眼光！


☆─────────────────────────────────────☆
   dracula (天灾骨钟) 于  (Thu May 15 20:27:55 2008)  提到:

很好呵  打一开始就是这么想的 


☆─────────────────────────────────────☆
   a1010 (比目鱼~~) 于  (Thu May 15 20:51:54 2008)  提到:

天下熙熙皆为利来



☆─────────────────────────────────────☆
   huahua1860 (CH.F.Y) 于  (Thu May 15 21:28:03 2008)  提到:

怎么可能一辈子做技术呢？现在还好，等年龄大了，自己想做也做不了了，当然得转了
【 在 fzylijun886 的大作中提到: 】
: 来源：世界经理人  
: 　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊).  
: 一、 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事 市场开发，跑腿的人，没有前途。  
: ................... 



☆─────────────────────────────────────☆
   Robert728999 (Robert) 于  (Thu May 15 22:20:03 2008)  提到:

我喜欢技术~更喜欢北邮人~


☆─────────────────────────────────────☆
   romi (romi 爱生活) 于  (Thu May 15 23:17:59 2008)  提到:

我理解的做技术的是能够掌控整个项目并有能力创新的人
LZ说的那是匠，我们应该学习成为家


☆─────────────────────────────────────☆
   ttallen (秋天以北) 于  (Fri May 16 00:27:45 2008)  提到:

lz感觉象大一的新生....


☆─────────────────────────────────────☆
   tjfmail (INTEL) 于  (Fri May 16 08:25:21 2008)  提到:

说得很好，技术仅仅是一种技能。如果想获得大的成功，必须发展其他能力


☆─────────────────────────────────────☆
   jackie84 (一刀★九段) 于  (Fri May 16 09:51:17 2008)  提到:

言之有理


☆─────────────────────────────────────☆
   DragonBone (龙骨^星兰) 于  (Fri May 16 12:49:48 2008)  提到:

说得有道理


☆─────────────────────────────────────☆
   landiya (landiya) 于  (Fri May 16 13:14:50 2008)  提到:

自古以来权利阶层都是使用知识分子,但是从骨子里看不起他们
现在也一样,做技术的人要想提高自己的社会地位,还是要跳出做技术的圈子

【 在 fzylijun886 的大作中提到: 】
: 来源：世界经理人  
: 　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己， 


☆─────────────────────────────────────☆
   renter (renter) 于  (Fri May 16 13:59:18 2008)  提到:

强烈同意！！
国外的环境好得多！！

【 在 fzylijun886 的大作中提到: 】
: 没看到是转贴么？怎么都冲我来了～～ 
: 我不否认这篇帖子有一定的片面性，不过你说的也有问题。 
: 1.国外做技术的都是喜欢技术，国内则普遍不是 
: ................... 



☆─────────────────────────────────────☆
   Shin (能和你牵手我是幸福的) 于  (Fri May 16 14:21:45 2008)  提到:

“朋友们你知道吗？不管你技术有多强，你也不可能自由的腾出时间象别人那样研究一下Linux源码，甚至写一个Linux样的杰作来表现你的才能。你需要做的就是按照要求写代码，写代码的含义就是都规定好，你按照规定写，你很快就会发现你昨天写的代码，跟今天写的代码有很多类似，等你写过一段时间的代码，你将领略：复制，拷贝，粘贴那样的技术对你来说是何等重要。（如果你没有做过1年以上的真正意义上的开发不要反驳我）。”

这作者也好意思号称自己做过多年开发。。。。冷笑。。。  



☆─────────────────────────────────────☆
   inoman (inoman) 于  (Fri May 16 15:43:03 2008)  提到:

LS的难道就是LZ说的那种人？！



☆─────────────────────────────────────☆
   wowo (我) 于  (Fri May 16 16:20:02 2008)  提到:

不能全靠技术 但是技术不可少


☆─────────────────────────────────────☆
   Shin (能和你牵手我是幸福的) 于  (Fri May 16 16:29:44 2008)  提到:

从帖子中就能看出来作者在技术上不过是个井底之蛙而已，这样的人根本没资格宣扬技术无用论
【 在 inoman 的大作中提到: 】
: LS的难道就是LZ说的那种人？！ 



☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Fri May 16 17:17:33 2008)  提到:

不好意思，我已经研二了～～
【 在 ttallen 的大作中提到: 】
: lz感觉象大一的新生.... 



☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Fri May 16 17:18:45 2008)  提到:

听口气感觉阁下是个牛人：）
【 在 Shin 的大作中提到: 】
: 从帖子中就能看出来作者在技术上不过是个井底之蛙而已，这样的人根本没资格宣扬技术无用论 



☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Fri May 16 19:58:05 2008)  提到:

民工还不一样活吗,难道就每个人都走管理,都年薪几十万?各人有各人的路嘛,我还就愿意做一辈子技术,当然,中年和青年不是一种做法


☆─────────────────────────────────────☆
   ljxalex (花轩无间) 于  (Fri May 16 20:57:24 2008)  提到:

美国销售员的淘汰率是98%
  不知道中国是怎么样


☆─────────────────────────────────────☆
   ws4021349 (风之吻) 于  (Fri May 16 23:29:59 2008)  提到:

怎么说呢.觉得技术是很重要.
原帖中可取之处是说明,除了技术外,大的交往圈子,人际关系,人脉也相当重要


☆─────────────────────────────────────☆
   guying (宙斯) 于  (Sat May 17 11:53:26 2008)  提到:

国外的财团最希望看到的就是中国人全部都是技术初级人员，全部都是浮躁的，不能安心钻研技术的人。
而中国科技牛人很多数都在国外给他们效力，被他们包养。
中国核心技术的积贫积弱，难道一个北邮人不值得一辈子投身技术吗？

如果只想挣钱，上不上大学似乎没啥用，倒爷挣的更多些。


☆─────────────────────────────────────☆
   SandFlee (龙之弈) 于  (Sat May 17 22:58:13 2008)  提到:


【 在 romi 的大作中提到: 】
: 我理解的做技术的是能够掌控整个项目并有能力创新的人 
: LZ说的那是匠，我们应该学习成为家 
匠
家
很有道理！



☆─────────────────────────────────────☆
   golf1985 (巴渝人家|魔文字之以德服人) 于  (Sun May 18 10:42:21 2008)  提到:

嗯，有点道理。


☆─────────────────────────────────────☆
   GAARA (我爱罗★九段) 于  (Sun May 18 11:54:10 2008)  提到:


【 在 fzylijun886 的大作中提到: 】
: 来源：世界经理人  
: 　　我现在是自己做，但我此前有多年在从事软件开发工作，当回过头来想一想自己，觉得特别想对那些初学JAVA/DOT。NET技术的朋友说点心里话，希望你们能从我们的体会中，多少受点启发(也许我说的不好，你不赞同但看在我真心的份上别扔砖头啊).  
: 一、 在中国你千万不要因为学习技术就可以换来稳定的生活和高的薪水待遇，你千万更不要认为哪些从事 市场开发，跑腿的人，没有前途。  
: ................... 

totally bullshit



☆─────────────────────────────────────☆
   sweetfly (mession) 于  (Sun May 18 12:40:11 2008)  提到:

      我想首先，无论如何，人存活在这个社会中，首先要解决的基本生活问题。对于我们而已，这种基本的技能就是我们的技术了。如果不静心学技术而一味的强调管理的规划，其实我倒是觉得有点本末倒置了。
    另外，管理确实很重要，但是管理才能的体现也并不是一朝一夕可以学到手的，包括各种能力，很多人都说，以后要做怎样怎样的管理，如果现在都不储备出一些管理的系统知识，即使机会来了，机会也不会属于你了。
    我觉得，就咱们学校这个环境，首先是技术学到位，然后发展自己的综合能力，如同文章中提到的为人处世，说话做事，这些能力锻炼出来了。技术也会陪你走一辈子的。
  


☆─────────────────────────────────────☆
   yyn110 (Rory) 于  (Sun May 18 14:57:28 2008)  提到:

那就是说做市场的人职业前景更好咯？？？干吗辛辛苦苦学技术？？
PS:实在不善于或不喜欢和人交往的除外


☆─────────────────────────────────────☆
   andy520 (andy) 于  (Sun May 18 16:21:46 2008)  提到:

在我们这种学校 我觉得有技术是一个跳板 是你进入一个行业的前提 进去之后你可以有自己其他的发展 喜欢技术的就继续技术 不喜欢的就转 


☆─────────────────────────────────────☆
   wangtaoer (王小颠) 于  (Sun May 18 18:17:41 2008)  提到:

写这个帖子的人很浮躁，难成大器。。坚定完毕


☆─────────────────────────────────────☆
   tjfmail (PE_passion &amp; energy) 于  (Sun May 18 19:21:35 2008)  提到:

好贴，顶上十大


☆─────────────────────────────────────☆
   flyingmiao (amiao) 于  (Sun May 18 19:51:51 2008)  提到:

废话什么，都别做技术吧，咱就更值钱了，哈哈
玩笑

其实这篇文章的大多数论点是有其道理的
只是适用的人群的问题，以及他表现出的心态问题

首先，就技术上的论断...作者也太嫩了...研究冒泡排序，最大数算法...让我汗一下...

其次，这片文章表现出的是一种浮躁的心态，就像一个刚学了一点皮毛的人看着别人NB了，就羡慕的不得了，想着各种转行。
很多人认为，计算机领域就是那么简单，什么C，C++，JAVA...各种语言学会就完了。但情况是，计算机领域也是一个非常需要基础和积累的领域，当然更离不开实践。这个领域几十年的积累和知识的爆炸，不是一朝一夕就能得道成仙的。
技术没有好好的积累，是没有办法做好的。语言什么的，不过是工具，有没有人想过，同是技术人员，差距也是那么的大，无论效率，成果还是待遇，例子我想不用举。没有踏踏实实的一步一个脚印的走过来，是达不到一定境界的。
技术人员最忌的就是浮躁。

另外，不要拿金字塔的基座去比金字塔尖。也要看到市场销售管理领域的塔基上有多少分母，也要看到人家金子塔尖付出了多少努力。

以其想当然的做白日梦以为自己换个金字塔就会是金字塔尖，不如好好爬自己的金字塔
以其羡慕别人，不如做好自己的事，将自己的事做到最好
没有最好的工作，只有最适合自己的工作
如果不喜欢做技术，当然要换行，不转行等死么


☆─────────────────────────────────────☆
   heyjude (heyjude ) 于  (Sun May 18 19:52:52 2008)  提到:

原文作者
就是在乱曰
还大言不惭

人各有志
作者就想着怎么去“管理”别人吧！
你知道什么是管理吗？


☆─────────────────────────────────────☆
   heyjude (heyjude ) 于  (Sun May 18 19:56:11 2008)  提到:


【 在 advanceroot 的大作中提到: 】
: 本来就是件谁爱谁选择，谁承担自己选择后果的问题，没有对错。 
: 但实在看不过眼，总有些这种人胡乱忽悠，不知目的何在。 
: 说白了不就是你认为做技术赚得钱性价比太低么。 
: ................... 
赞！


☆─────────────────────────────────────☆
   lw176493876 (爱我还是他) 于  (Sun May 18 19:58:45 2008)  提到:

还是很有技术含量哈


☆─────────────────────────────────────☆
   falcom (缘随风起) 于  (Sun May 18 20:29:08 2008)  提到:

分析得很有道理,不是所有人都合适做技术,也不是所有人都合适做经理人.个人认为做技术的人心不能浮躁,同时头要抬起来,手要放下去.

【 在 flyingmiao 的大作中提到: 】
: 废话什么，都别做技术吧，咱就更值钱了，哈哈 
: 玩笑 
: [color=#DC143C]其实这篇文章的大多数论点是有其道理的 
: ................... 



☆─────────────────────────────────────☆
   flyingmiao (amiao) 于  (Sun May 18 20:34:03 2008)  提到:


【 在 falcom 的大作中提到: 】
: 分析得很有道理,不是所有人都合适做技术,也不是所有人都合适做经理人.个人认为做技术的人心不能浮躁,同时头要抬起来,手要放下去. 

头要抬起来,手要放下去.
===
说得好



☆─────────────────────────────────────☆
   oygwnv (温水里的青蛙 || 北邮鲨帮漏网之鱼) 于  (Sun May 18 21:22:02 2008)  提到:

知道中国为什么这么落后吗
一是事实情况,就像作者说的
二是中国人的普遍态度:被动的承受,就像作者做的
注意:作者!=楼主

不过我真的很同意说的事实
但是是否采取作者的态度,见仁见智了


☆─────────────────────────────────────☆
   liaoruo (廖若) 于  (Mon May 19 00:09:05 2008)  提到:


【 在 advanceroot 的大作中提到: 】
: 本来就是件谁爱谁选择，谁承担自己选择后果的问题，没有对错。 
: 但实在看不过眼，总有些这种人胡乱忽悠，不知目的何在。 
: 说白了不就是你认为做技术赚得钱性价比太低么。 
: ................... 
顶，正和我意...!


☆─────────────────────────────────────☆
   zld (老A) 于  (Mon May 19 08:24:26 2008)  提到:

过来人的经验，估计我也得经历，避免不了的一些想法


☆─────────────────────────────────────☆
   baoyibao (我的若谷，你在哪里？) 于  (Mon May 19 10:15:50 2008)  提到:

题目很赞，不过其中的言语或多或少都有些对错吧。
其实，技术就像练拳，如果你连最基本的拳法都不会的话，有那些深厚的内功好像也会被打得很惨。接着，才是管理，有了基本的武功底子，剩下的就靠自己的修炼和打拼了。当然，你必须得一个人闭关修炼，静心提升内功。于是，你就失去了和他人切磋的机会，自己就显得有些与世隔绝了。等哪日大功告成了，你便可以开个武馆，管理他人人练功了。但是，不是所有人都有这样的耐心从头到尾地练下去。可能有一些人会不时地觉得别人的拳法套路比较好，于是三心二意，结果啥都没学成。还有一些人可能觉得练武太辛苦，就转而去经商了，这也不错，或许某天会发现自己是个经商的能人呢。当然，最幸运的便是那些一开始就有人传授内功与其的人了，他们从开始便占有了优势，因为别人需要很多努力才有的东西他瞬间就有了。他们只要稍微练练功法，便可以独步江湖了。
    所以，关键就看自己是不是适合“练武”，自己有没有“练武”的坚持，不要说自己武功没练到家就说“练武”无用。当然，一些牛人（比如黄蓉）他也只会纸上谈兵，却是能够当个“管理者”，因为他懂得很多，功夫知识面很广，可以教别人练武。


☆─────────────────────────────────────☆
   wanghuan (wanghuan) 于  (Mon May 19 13:46:20 2008)  提到:

垃圾帖子。只对凡人有用，凡人能灵活运用一门技术已经了不起了，但是对于大牛来说，根本不玩楼主所说的“技术”的，那玩意不值得花宝贵的时间。

真正搞技术的才是王道，只是这“技术”不是楼主说的技术，楼主说的技术只是技术民工搞得。大牛去搞C#？你是在侮辱大牛吧？


☆─────────────────────────────────────☆
   Kratos (是我杀了前任战神) 于  (Mon May 19 15:02:09 2008)  提到:


【 在 wanghuan 的大作中提到: 】
: 垃圾帖子。只对凡人有用，凡人能灵活运用一门技术已经了不起了，但是对于大牛来说，根本不玩楼主所说的“技术”的，那玩意不值得花宝贵的时间。 
: 真正搞技术的才是王道，只是这“技术”不是楼主说的技术，楼主说的技术只是技术民工搞得。大牛去搞C#？你是在侮辱大牛吧？ 

恩。。民工和大牛不是一个概念。。
不过我连民工都当不了
所以注定不会干这行了


☆─────────────────────────────────────☆
   kissmusic (老工) 于  (Mon May 19 17:56:03 2008)  提到:

很中肯 至少在中国来说


☆─────────────────────────────────────☆
   charlieX (苍蝇) 于  (Mon May 19 18:28:20 2008)  提到:

但是，有一门本事，总是不会饿的。


☆─────────────────────────────────────☆
   corn929 (corn) 于  (Mon May 19 18:39:43 2008)  提到:

要做管理首先要懂得包容，懂得知人善用，懂得集合精英谋求利益最大化。
一个对技术人员有如此偏见的人，谁能指望他做得好管理呢？


☆─────────────────────────────────────☆
   PtwCJ (鲜的每日C|头像不是我，我是长毛贼~~) 于  (Mon May 19 21:19:43 2008)  提到:

大体翻了翻，发现很多人还是太浮躁了.....


☆─────────────────────────────────────☆
   qxyzqxyz (强制得分) 于  (Mon May 19 22:34:45 2008)  提到:

大牛都搞什么技术，望不吝赐教。
【 在 wanghuan 的大作中提到: 】
: 垃圾帖子。只对凡人有用，凡人能灵活运用一门技术已经了不起了，但是对于大牛来说，根本不玩楼主所说的“技术”的，那玩意不值得花宝贵的时间。 
: 真正搞技术的才是王道，只是这“技术”不是楼主说的技术，楼主说的技术只是技术民工搞得。大牛去搞C#？你是在侮辱大牛吧？ 



☆─────────────────────────────────────☆
   yuangang28 (yuangang28) 于  (Wed May 21 19:58:48 2008)  提到:

说的很真切，到社会上，就是这样


 【文章标题】：ARM的开发步骤 【文章地址】：https://bbs.byr.cn/article/Embedded_System/392 【创建时间】：2008-05-22 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: ARM的开发步骤
发信站: 北邮人论坛 (Thu May 22 11:49:40 2008), 站内

 
1． 做个最小系统板：如果你从没有做过ARM的开发，建议你一开始不要贪大求全，把所有的应用都做好，因为ARM的启动方式和dsp或单片机有所不同，往往会遇到各种问题，所以建议先布一个仅有Flash,SRAM或SDRAM、CPU、JTAG、和复位信号的小系统板，留出扩展接口。使最小系统能够正常运行，你的任务就完成了一半，好在ARM的外围接口基本都是标准接口，如果你已有这些硬件的布线经验，这对你来讲是一件很容易的事情。

2． 写启动代码，根据硬件地址先写一个能够启动的小代码，包括以下部分：
初始化端口，屏蔽中断，把程序拷贝到SRAM中;完成代码的重映射；配置中断句柄，连接到C语言入口。也许你看到给你的一些示例程序当中，bootloader会有很多东西，但是不要被这些复杂的程序所困扰，因为你不是做开发板的，你的任务就是做段小程序，让你的应用程序能够运行下去
3． 仔细研究你所用的芯片的资料，尽管ARM在内核上兼容，但每家芯片都有自己的特色，编写程序时必须考虑这些问题。尤其是女孩子，在这儿千万别有依赖心理，总想拿别人的示例程序修改，却越改越乱。
4． 多看一些操作系统程序，在ARM的应用开放源代码的程序很多，要想提高自己，就要多看别人的程序，linux,uc/os-II等等这些都是很好的原码。
6.如果你是作硬件，每个厂家基本上都有针对该芯片的DEMO板原理图。先将原理图消化。这样你以后做设计时，对资源的分配心中有数。器件的DATSHEET一定要好好消化。
7.如果做软件最好对操作系统的机理要有所了解。当然这对软件工程师来说是小菜一碟。但如果是硬件出身的就有点费劲。 
问：做最小系统板是2层还是4层好？
答：只有AT91可以用两层板，其他的最少4层；44b0的地和电源处理好也可用两层板；
谈四层板和33欧电阻：
选用四层板不仅是电源和地的问题，高速数字电路对走线的阻抗有要求，二层板不好控制阻抗。33欧电阻一般加在驱动器端，也是起阻抗匹配作用的；布线时要先布数据地址线，和需要保证的高速线；
在高频的时候，PCB板上的走线都要看成传输线。传输线有其特征阻抗，学过传输线理论的都知道，当传输线上某处出现阻抗突变(不匹配)时，信号通过就会发生反射，反射对原信号造成干扰，严重时就会影响电路的正常工作。采用四层板时，通常外层走信号线，中间两层分别为电源和地平面，这样一方面隔离了两个信号层，更重要的是外层的走线与它们所靠近的平面形成称为“微带”(microstrip) 的传输线，它的阻抗比较固定，而且可以计算。对于两层板就比较难以做到这样。这种传输线阻抗主要于走线的宽度、到参考平面的距离、敷铜的厚度以及介电材料的特性有关，有许多现成的公式和程序可供计算。
33欧电阻通常串连放在驱动的一端(其实不一定33欧，从几欧到五、六十欧都有，视电路具体情况) ，其作用是与发送器的输出阻抗串连后与走线的阻抗匹配，使反射回来(假设解收端阻抗没有匹配) 的信号不会再次反射回去(吸收掉)，这样接收端的信号就不会受到影响。接收端也可以作匹配，例如采用电阻并联，但在数字系统比较少用，因为比较麻烦，而且很多时候是一发多收，如地址总线，不如源端匹配易做。
这里梭说的高频，不一定是时钟频率很高的电路，是不是高频不止看频率，更重要是看信号的上升下降时间。通常可以用上升(或下降) 时间估计电路的频率，一般取上升时间倒数的一半，比如如果上升时间是1ns，那么它的倒数是1000MHz，也就是说在设计电路是要按500MHz的频带来考虑。有时候要故意减慢边缘时间，许多高速IC其驱动器的输出斜率是可调的
构造嵌入式Linux 
Linux自身具备一整套工具链，容易自行建立嵌入式系统的开发环境和交叉运行环境，并且可以跨越嵌入式系统开发中的仿真工具（ICE）的障碍。内核的完全开放使人们可以自己设计和开发出真正的硬实时系统，软实时系统在Linux中也容易得到实现。强大的网络支持使得可以利用Linux的网络协议栈将其开发成为嵌入式的TCP/IP网络协议栈。 
　　Linux提供了完成嵌入功能的基本内核和所需要的所有用户界面，它是多面的。它能处理嵌入式任务和用户界面。 
　　一个小型的嵌入式Linux系统只需要下面三个基本元素： 
　　* 引导工具 
　　* Linux微内核，由内存管理、进程管理和事务处理构成 
　　* 初始化进程 
　　如果要让它能干点什么且继续保持小型化，还得加上： 
　　* 硬件驱动程序 
　　* 提供所需功能的一个或更多应用程序。 
　　再增加功能，或许需要这些： 
　　* 一个文件系统（也许在ROM或RAM）中 
　　* TCP/IP网络堆栈 
　　下面我们就从精简内核、系统启动、驱动程序将、X-Window换成MicroWindows四个步骤介绍嵌入式Linux的实际开发。 
　　精简内核 
　　构造内核的常用命令包括：make config、dep、clean、mrproper、zImage、bzImage、modules、modules_install。命令说明略。 
　　现在举个例子说明一下： 
　　我使用的是 Mandrake内附的 2.2.15。我没有修改任何一行程序码，完全只靠修改组态档得到这些数据。 
　　首先，使用 make config 把所有可以拿掉的选项都拿得。 
　　不要 floppy；不要SMP、MTRR；不要 Networking、SCSI；把所有的 block device 移除，只留下 old IDE device；把所有的 character device 移除；把所有的 filesystem 移除，只留下 minix；不要 sound 支援。相信我，我己经把所有的选项都移除了。这样做之后，我得到了一个 188K 的核心。 
　　还不够小吗? OK，再加上一招，请把下列两个档案中的 -O3,-O2 用 -Os 取代。 
　　./Makefile 
　　./arch/i386/kernel/ 
　　Makefile 
　　这样一来，整个核心变小了 9K，成为 179K。 
　　不过这个核心恐怕很难发挥 Linux 的功能，因此我决定把网络加回去。把General中的 network support 加回去，重新编译，核心变成 189 K。10K就加上个 TCP/IP stack，似乎是很上算的生意。 
　　有stack没有driver也是枉然，所以我把 embedded board常用的RTL8139的driver加回去，195K。 
　　如果你需要 DOS 档案系统，那大小成为 213K。如果 minix 用 ext2 换代，则大小成长至 222K。 
　　Linux所需的内存大约在600K～800K之间。1MB内存就可能可以开机了，但不太有用，因为连载入C程序库都有困难。2MB内存应该就可以做点事了，但要到 4MB以上才可以执行一个比较完整的系统。 
　　因为Linux 的filesystem 相当大，大约在 230K 左右，占了 1/3 的体积。内存管理占了80K，和核心其它部分的总和差不多。TCP/IP stack 占了65K，驱动程序占了120K。SysV IPC占了 21K，必要的话可以拿掉，核心档应该可以再小个10K左右。 
　　如果要裁剪核心大小，应该动那里呢? 答案很明显，当然是文件系统。Linux 的 VFS简化了档案系统的设计，buffer cache, directory cache增加了系统的效率。但这些embedded系统根本就用处不大。如果可以把它们拿掉，核心可以马上缩小 20K 左右。如果跳过整个 VFS，直接将文件系统写成一个 driver 的型式，应该可以将 230K缩减至50K左右。整个核心缩到100K左右。 
　　系统启动 
　　系统的启动顺序及相关文件仍在核心源码目录下，看以下几个文件： 
　　./arch/$ARCH/boot/ 
　　bootsect.s 
　　./arch/$ARCH/boot/setup.s 
　　./init/main.c 
　　bootsect.S 及 setup.S 
　　这个程序是Linux kernel的第一个程序，包括了Linux自己的bootstrap程序，但是在说明这个程序前，必须先说明一般IBM PC开机时的动作(此处的开机是指“打开PC的电源”)。 
　　一般PC在电源一开时，是由内存中地址FFFF:0000开始执行(这个地址一定在ROM BIOS中，ROM BIOS一般是在FEOOOh到FFFFFh中)，而此处的内容则是一个jump指令，jump到另一个位于ROM BIOS中的位置，开始执行一系列的动作。 
　　紧接着系统测试码之后，控制权会转移给ROM中的启动程序(ROM bootstrap routine)。这个程序会将磁盘上的第零轨第零扇区读入内存中，至于读到内存的哪里呢? --绝对位置07C0:0000(即07C00h处)，这是IBM系列PC的特性。而位于Linux开机磁盘的boot sector上的，正是Linux的bootsect程序。 
　　把大家所熟知的MS DOS 与Linux的开机部分做个粗浅的比较。MS DOS 由位于磁盘上boot sector的boot程序负责把IO.SYS载入内存中，而IO.SYS则负有把DOS的kernel --MSDOS.SYS载入内存的重任。而Linux则是由位于boot sector 的bootsect程序负责把setup及Linux的kernel载入内存中，再将控制权交给setup。 
　　驱动程序 
　　在Linux系统里，设备驱动程序所提供的这组入口点由一个结构来向系统进行说明。 
　　设备驱动程序所提供的入口点，在设备驱动程序初始化的时候向系统进行登记，以便系统在适当的时候调用。Linux系统里，通过调用register_chrdev 向系统注册字符型设备驱动程序。 
　　在Linux里，除了直接修改系统核心的源代码，把设备驱动程序加进核心里以外，还可以把设备驱动程序作为可加载的模块，由系统管理员动态地加载它，使之成为核心的一部分。也可以由系统管理员把已加载的模块动态地卸载下来。Linux中，模块可以用C语言编写，用gcc编译成目标文件（不进行链接，作为*.o文件存在）。为此需要在gcc命令行里加上-c的参数。在成功地向系统注册了设备驱动程序后（调用register_chrdev成功后），就可以用mknod命令来把设备映射为一个特别文件。其它程序使用这个设备的时候，只要对此特别文件进行操作就行了。 
　　将X-Window换成MicroWindows 
　　MicroWindows是使用分层结构的设计方法。允许改变不同的层来适应实际的应用。在最底一层，提供了屏幕、鼠标/触摸屏和键盘的驱动，使程序能访问实际的硬件设备和其它用户定制设备。在中间一层，有一个轻巧的图形引擎，提供了绘制线条、区域填充、绘制多边形、裁剪和使用颜色模式的方法。在最上一层，提供了不同的API给图形应用程序使用。这些API可以提供或不提供桌面和窗口外形。目前，MicroWindows支持Windows Win32/WinCE GDI和Nano-X API。这些API提供了Win32和X窗口系统的紧密兼容性，使得别的应用程序可以很容易就能移植到MicroWindows上。 
　　何谓嵌入式系统 
　　嵌入式系统被定义为：以应用为中心、以计算机技术为基础、软件硬件可裁剪、适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。 
　　嵌入式系统是面向用户、面向产品、面向应用的，如果独立于应用自行发展，则会失去市场。嵌入式处理器的功耗、体积、成本、可靠性、速度、处理能力、电磁兼容性等方面均受到应用要求的制约，这些也是各个半导体厂商之间竞争的热点。嵌入式处理器的应用软件是实现嵌入式系统功能的关键。软件要求固化存储，软件代码要求高质量、高可靠性，系统软件(OS)的高实时性是基本要求。 
　　在制造工业、过程控制、通讯、仪器、仪表、汽车、船舶、航空、航天、军事装备、消费类产品等方面均是嵌入式计算机的应用领域。 

--
I remember my grandson asked me the other day, he said: "Grandpa, were you a hero in the great war?"
"No,"I replied,"But I served in a company of heroes."
有一天我的小孙子问我“爷爷，你是大战中的英雄吗？我回答：不......但我与英雄们一同服役。
 北邮嵌入式系统论坛欢迎大家！<a target="_blank" href="http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System">http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System</a>  
北邮嵌入式系统协会 群号：60600133 


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.186.*]
 【文章标题】：基于ARM的嵌入式TCP/IP协议的实现 【文章地址】：https://bbs.byr.cn/article/Embedded_System/390 【创建时间】：2008-05-22 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: 基于ARM的嵌入式TCP/IP协议的实现
发信站: 北邮人论坛 (Thu May 22 11:31:13 2008), 站内

在网络应用日益普遍的今天，越来越多的嵌入式设备实现Ｉｎｔｅｒｎｅｔ网络化。ＴＣＰ／ＩＰ协议是一种目前被广泛采用的网络协议。嵌入式Ｉｎｔｅｒｎｅｔ的技术核心是在嵌入式系统中部分或完整地实现ＴＣＰ／ＩＰ协议。由于ＴＣＰ／ＩＰ协议比较复杂，而目前嵌入式系统中大量应用低速处理器，受内存和速度限制，有必要将ＴＣＰ／ＩＰ协议简化。

图1 协议处理

１ ＴＣＰ／ＩＰ协议的实现

嵌入式ＴＣＰ／ＩＰ协议一般实现：ＡＲＰ／ＲＡＲＰ、ＩＰ、ＩＣＭＰ、ＴＣＰ、ＵＤＰ、ＨＴＴＰ、ＳＭＴＰ、ＦＴＰ、ＴＥＬＮＥＴ等协议，协议处理的主要流程如图１所示。

１．１ ＴＣＰ协议的实现

工业控制领域传输层采用ＴＣＰ协议、不用ＵＤＰ协议，是考虑到实时监控系统中传输量并不大，而可靠性要求较高。ＴＣＰ协议是面向连接的、端对端的可靠通信协议。它采用了许多机制来保证可靠传输，应用于嵌入式系统显得过于复杂。

ＴＣＰ协议数据传输可分为三个阶段：建立连接、传输数据和断开连接。它的实现过程可以用状态机来描述。建立连接有两种方法，即主动打开和被动打开。服务器端是一种被动打开，它一直在侦听连接请求；而客户端是一种主动打开，它发送连接请求以建立连接。研究发现，如果ＴＣＰ层的上层实现服务器端的应用，可以将标准ＴＣＰ状态机建立连接过程中客户端建立连接的状态机部分简化掉。同理，如果应用是基于客户端的，可以将服务器端建立连接的状态机部分简化掉。断开连接有两种方式：一是主动断开连接；另一是被动断开连接。被动断开连接的处理较为简单，但标准ＴＣＰ协议的主动断开连接的状态机部分过于复杂。经过实验发现，在需要主动断开连接的时候，发送一个Ｆｉｎ数据报；接收到对Ｆｉｎ数据报的确认后，再发送一个Ｒｅｓｅｔ数据报，即可顺利完成一次主动断开连接。

标准的ＴＣＰ协议使用慢启动的滑动窗口机制。滑动窗口是一种在流量控制和网络传输效率之间折中的方案。它允许发送方在等待一个确认之前发送多个窗口，其确认是一种批量的确认。研究滑动窗口协议发现，滑动窗口的一个极限情况，是只使用单个窗口，就变成了一种简单确认的处理方法。使用该方法后，所有的处理只是对单个数据报的发送和确认，节约了系统的资源，也使维护更加方便。为了协议的兼容性，需要通信的另一方也使用简单确认方法。因为如果对方使用较大的窗口，就可能造成处理器被淹没。这个问题可以通过设置待发送数据报的ＴＣＰ头部的Ｗｉｎｄｏｗｓ字段的大小解决。

在上述基础上，简化实现ＴＣＰ协议的流程图如图２所示。其中“不同状态的相应处理”指根据接收到的ＴＣＰ报文准备待发送数据报并将其发送到以太网上。这部分根据ＴＣＰ所处的不同状态，所做的处理是不一样的。

１．２ ＩＰ协议

ＩＰ协议是ＴＣＰ／ＩＰ的基础，为不同网络的主机之间发送数据报的操作序列提供无连接服务。通过在数据报前添加ＩＰ协议头，使每个数据报具有寻址能力。嵌入式系统只把ＩＰ作为传输工具，进行简化以完成主要的操作。得到ＩＰ包后，检验ＩＰ头部的版本、目的地址、校验和正确否，解析出协议类型字段，由此交给相应的高层协议处理。发送ＩＰ包时，将缓冲区内的源地址与目的地址互换，设置校验和，然后交给下层协议处理。不符合要求，则将此包丢弃。ＩＰ包最大可以为６５ＫＢ，可以分段传输，而在嵌入式系统里根本无法容纳如此大的数据包，因此一般不支持分段传输。所以限制ＭＣＵ发送和接收数据包的方式以避免分段传输，从而减少程序复杂度。

    １．３ 其它协议

ＡＲＰ协议为３２位ＩＰ地址到对应的４８位以太网地址之间提供动态映射。嵌入式系统中仅响应ＡＲＰ请求，发送ＡＲＰ回答包。请求者广播出包含ＡＲＰ请求的以太帧、目的以太网地址为全１的广播地址。本机收到后，由目的ＩＰ地址发现自己是目的主机，发送一个ＡＲＰ回答。ＩＣＭＰ通过ＩＰ协议传输其报文。ＩＰ协议是无连接的，它无法将报文和错误信息传到最初的主机，ＩＣＭＰ将状态信息和错误信息发送到发报文的主机。

２ 前端设备的系统设计

ＴＣＰ／ＩＰ协议扩展到工业控制级，将企业内部计算机网络应用于工业现场实时信息的发布和显示，通过Ｉｎｔｅｒｎｅｔ浏览器对现场工业信息进行动态监视。下面是笔者在某公司一分布式监控系统中的应用实例。基于ＴＣＰ／ＩＰ协议的前端设备系统软件结构如图３。前端嵌入式设备处理器是Ｓａｍｓｕｎｇ公司的Ｓ３Ｃ４５１０Ｂ（ＡＲＭ核）。该芯片是用在基于以太网系统的高性价比、高性能的１６／３２位ＲＩＳＣ微控制器。通信部分采用ＢＮＣ接口方式，信号输出经耦合隔离变压器由ＲＪ４５接头联入集线器，此外还设计了液晶显示和键盘输入当地接口功能。

在ＴＣＰ／ＩＰ协议中多处用到超时和重发机制。这种机制对于确保两个或多个彼此独立的通信结点从通信错误或故障状态自动恢复到正常状态是非常有效的，但也增加了软件结构的复杂性。因为对超时的处理通常独立于正常程序流程，也就是与正常的程序流程异步。要实现的ＴＣＰ／ＩＰ协议软件中有四处要用到定时器：第一是在ＡＲＰ高速缓存的维护中，被添加到ＡＲＰ高速缓存中的表项在一段时间后要置为无效；第二是在等待对发出的ＡＲＰ请求返回响应时，可能会在指定的超时时间内还未收到返回的响应；第三是在ＩＰ组装收到分片时，由于部分分片在一定时间内没有收到而丢弃整个ＩＰ包；第四是在ＴＣＰ等待接收方对数据段的确认时。如果在指定时间内还未收到对某个数据段的确认，需重新发送。从上述可见，要实现的定时器具备以下特点：

·对定时的精度要求都不是很高，基本都是秒级的精度。这样，完全可以稍滞后一些来处理定时器超时，不把超时处理放在时钟中断处理程序中。

    ·对同一类超时处理可以由同一处理程序来完成，只是传入到相应的处理程序中的参数不同而已。例如一个ＡＲＰ高速缓存中的表项超时时，需要将其置为无效，可以统一用一个处理程序，参数中放入相应的表项地址即可。

首先，定义一定时器的数据结构，如图４所示。每一类超时都是由一个超时控制块和其所属的一个由超时事件项组成的链表管理。整个链表按超时事件将要发生的时间顺序排列，先发生的超时事件排列在前。超时控制块中的ｈｅａｄ＿ｐｔｒ用以指向一个超时事件项链表的首项；ｔｉｍｅｏｕｔ＿ｐｒｏｃｅｓｓ是超时事件发生时处理程序的入口地址。在每个超时事件项中，ｎｅｘｔ＿ｐｔｒ指向链表中的下一项；ｒｅｌａｔｉｖｅ＿ｔｉｍｅ是本表项的超时事件相对于上一表项的超时事件发生的相对时间。所以某个表项表示的超时事件距离当前的时间是它以前所有表项（包括自身）中的ｒｅｌａｔｉｖｅ＿ｔｉｍｅ的和。ｒｅｌａｔｉｖｅ＿ｔｉｍｅ的基本单位是ｇｒａｎｕｌａｒｉｔｙ。

    定时器任务使用一个信号量作同步。信号量有两个变量：ｃｏｕｎｔ和ｗａｉｔｉｎｇ＿ｔａｓｋ。ｃｏｕｎｔ对事件计数，当ｃｏｕｎｔ大于０时，表示有ｃｏｕｎｔ个事件发生并等待处理；当ｃｏｕｎｔ小于０时，表示有某个任务在等待事件的发生，此时ｗａｉｔｉｎｔ＿ｔａｓｋ保存相应任务控制块的地址。信号量有两个操作：ｓｅｍ＿ｕｐ和ｓｅｍ＿ｄｏｗｎ。ｓｅｍ＿ｕｐ首先使ｃｏｕｎｔ加１，然后看ｃｏｕｎｔ是否为０，若为０表示有任务在等待，通过ｗａｉｔｉｎｇ＿ｔａｓｋ中记录的任务控制块的地址把等待任务的状态设为就绪，否则返回。ｓｅｍ＿ｄｏｗｎ首先使ｃｏｕｎｔ减１然后看ｃｏｕｎｔ是否小于０，若小于０会使当前任务成为等待状态并引发任务管理器对任务的调度，否则返回。

每当时钟中断服务程序计数到ｇｒａｎｕｌａｒｉｔｙ个时钟中断，给定时器任务使用的信号灯作ｓｅｍ＿ｕｐ操作。当定时器任务被调度执行时，它遍历每一个超时控制块，对每一个超时控制块作如图５所示的处理，最后对信号灯调用ｓｅｍ＿ｄｏｗｎ。

原文链接：<a target="_blank" href="http://goodzyz.blog.hexun.com/5177569_d.html">http://goodzyz.blog.hexun.com/5177569_d.html</a>

--
I remember my grandson asked me the other day, he said: "Grandpa, were you a hero in the great war?"
"No,"I replied,"But I served in a company of heroes."
有一天我的小孙子问我“爷爷，你是大战中的英雄吗？我回答：不......但我与英雄们一同服役。
 北邮嵌入式系统论坛欢迎大家！<a target="_blank" href="http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System">http://forum.byr.edu.cn/wForum/board.php?name=Embedded_System</a>  
北邮嵌入式系统协会 群号：60600133 

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 

【文章标题】：ubuntu下使用kermit协议,通过串口传送文件 【文章地址】：https://bbs.byr.cn/article/Embedded_System/383 【创建时间】：2008-05-20 【作者】：tjfmail 【评论】：0 【内容】：发信人: tjfmail (PE_passion &amp; energy), 信区: Embedded_System
标  题: ubuntu下使用kermit协议,通过串口传送文件
发信站: 北邮人论坛 (Tue May 20 17:58:30 2008), 站内

这几天都在用unbuntu下的minicom与主板交互，总是出问题，这篇文章从另一个方面解决了，这种问题。还是听不错的。

(1) minicom

首先使用minicom就是一个错误，然后钻牛角尖了，想法设法去使用minicom，其实一开始就应该抛弃使用minicom，转用别的工具。u-boot的官方网站已经说很清楚了。看这里：

http://www.denx.de/wiki/view/DULG/UBootCmdGroupDownload#Section_5.9.5.3.

minicom is another popular serial communication program. Unfortunately, many users have reported problems using it with U-Boot and Linux, especially when trying to use it for serial image download. It's use is therefore discouraged.

(2)c-kermit

使用c-kermit就完全没有问题。编写一个Kermit的配置文件:

~/.kermrc:
set line /dev/ttyS0
set speed 115200
set carrier-watch off
set handshake none
set flow-control none
robust
set file type bin
set file name lit
set rec pack 1000
set send pack 1000
set window 5

c-kermit可以从 <a target="_blank" href="http://www.columbia.edu/kermit/">http://www.columbia.edu/kermit/</a>  下载。

(3)具体使用方法

使用以下命令：

connect

可以连上开发板，这一些与minicom是一样的，而且感觉速度更快些。

(4)切换

按下 Ctrl + \  , 再按 C 可以跳回kermit。

跳回串口控制，可以输入c,即 connect即可。

(5)发送文件

kermit中输入connect后,转入了u-boot串口界面。

输入Loadb 0x00300000,启动开发板上的kermit协议。

按下 Ctrl + \  , 再按 C, 切换到kermit。

输入命令：send /home/share/uImage.pkg

kermit开始传送，并且显示一个传送界面，并动态显示传送进度。

传送完毕后，输入 C ，即 connect 命令，回到u-boot的串口界面。

使用u-boot命令，启动内核。

完毕！

(6)速度比较：Linux下的kermit 快很多

不知道为什么，在相同的开发板并且不改任何代码的情况下，使用 Windows的超级终端传送文件，明显没有linux下用kermit传送文件传得快。虽然超级终端比较好用些，但是Linux的Kermit也不差，而且速度明显比超级终端快多了，建议大家用用Linux下的kermit软件。
--
莫听穿林打叶声,何妨吟啸且徐行;
竹杖芒鞋轻胜马,谁怕!一蓑烟雨任平生

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 

【文章标题】：[转]我的25年嵌入式生涯 (转载) 【文章地址】：https://bbs.byr.cn/article/Embedded_System/421 【创建时间】：2008-05-23 【作者】：pooh1949 【评论】：0 【内容】：发信人: pooh1949 (pooh1949), 信区: Embedded_System
标  题: [转]我的25年嵌入式生涯
发信站: 北邮人论坛 (Fri May 23 22:50:29 2008), 站内

【 以下文字转载自 Circuit 讨论区 】
发信人: xxl (软盘), 信区: Circuit
标  题: [转]我的25年嵌入式生涯
发信站: 北邮人论坛 (Sun Nov  4 18:51:29 2007), 站内

        杂谈：我的25年嵌入式生涯
                                文/周立功

        《程序员》杂志的编辑约我写一篇命题作文，想了几天都无从下手不知道写什么才好。在这篇文章里，我不打算将创业的艰辛与喜悦重新回忆一遍，我确实不想去误导大家，因为我所处的年代是一个物质缺乏的年代，成功相对来说要容易得多。每个人的成长经历都有其个性化的东西，每个人的成功创业经验虽然有一些可以遵循的普遍规律，但一般来说都很难复制，成功需要不断地创新。
        对于今天很多的年轻人来说，一味注重技术至上的观念刻骨铭心，其实很多时候努力并非一定有回报。事实上，有不少出类拔萃的人才往往做出来的产品就是卖不掉，因为设计者压根儿就不了解用户的需求和心理以及产品功能的恰当定义，而总想在同事及其老板面前卖弄自己的技术和产品功能。其实有很多思维性的东西恰恰是很多人所忽视的，因为从一开始的出发点就错了，怎么可能取得辉煌的成绩呢？所以有时拥有卓越的技术并不一定代表人生的成功，很多企业就是死在一些自命不凡的“卓越人才”手中。

它山之石可以攻玉，减少“阶段0”的开发
        有所“创造”确实是人人期待的，令人瞩目的发明虽然激动人心却谈何容易，人们时常将盖茨没有任何爆炸性的发明作为茶余饭后的笑料，我们不妨从另外一个角度去探索微软的成功奥妙从而为我们所用。
        确实不假，盖茨的DOS源代码是从帕特森手上“买”来的。这些年来，我收集了世界各地中英文版有关微软的专著来比较研究，大家仅仅注意到盖茨为建立整个行业架构标准的远见，并叹服盖茨深得市场运作经验的精髓，我认为这些研究成果都是后来者研究微软成功经验，是“牵强附会”不可复制的理论总结。
        当初微软公司还仅仅是一家很稚嫩的公司，可以说生存下去是盖茨作为老板唯一的使命。事实上，正当盖茨决定动手来写IBM所要的OS时，原计划在一年左右完成，但IBM公司只给了他几个月的时间。尽管帕特森的QDOS并不完善错误百出，但为了履行对IBM的承诺，盖茨购买了QDOS改贴标签后卖给了IBM公司。盖茨对此心知肚明，因为他知道如果用一年的时间来做OS的开发，他将失去与巨人IBM的合作机会，那是一种浪费。付一小部分的技术费用没有关系，只要能获得Know-how，获得更高的利润就好了。通过支付权利金引入技术，然后以模仿的方式学习他人的技术，再改造成符合IBM需要即可。
        “买”――只要有现成的就不需要自己开发，这就是盖茨的过人之处，而且恰恰是很多人忽视的地方，值得我们所有人学习和仿效。盖茨就是由于没有“阶段0”，从而大幅度地降低开发风险。
        当年，我是一个人单枪匹马借了2.15万元出来创业的，可以说是负资产，后来才开始有伙伴注资6万元。没有经验怎么办？我有一个非常好习惯，读书从不拘泥于他人的观点，也满足于人云亦云，否则那就是听别人讲故事，那不是您的东西，有入宝山空手而归。我认为，要想成功就必须“研究”成功者的轨迹，向成功者学习。
        下面我会把我“第一桶金”的故事告诉你，这也是尽量减少“阶段0”开发一个非常典型的例子。
        当年，《羊城晚报》几乎每天都有半版广告刊登信息台（听歌、悄悄话等）广告，一打听广告费每天几十万。当时相信不少人在利用公费电话在拨打这些信息台。后来我送货到客户那里发现电话机都外加了一个铁壳并上了一把锁，从看到那一幕开始，我决定做电话加密码锁，锁长途电话0字头，手机、BB机、信息台的9字头。通过朋友介绍，福州某公司有这个技术，于是我打了一个试探性的电话，使用5000元购买方案和源代码，对方非常爽快地同意了。我生怕有变立即坐飞机到福州去，很快就见到了郑新建工程师，他原来在福州某公司工作，我见到他的时候已经离开了福州某公司，但仍然自己写一些产品解决方案，通过福州某公司销售。买到方案与源代码之后，我立即带样机到各地去做测试，发现这台样机兼容性太差，而且市场已经开始在卖的产品也存在同样的问题，我想只要解决好兼容性的问题，如果在任何地区交换机局域网都能够使用，那就是最好的产品不愁没有市场。
        我当时既没有资金也没有生产和销售经验，到底怎么将技术变成市场上所需要的产品呢？那是因为我找到了生产电话分线器的广州市白云区百新电器厂的老板陈国亮，由他生产和销售，每销售一台产品给我提成。以这个项目为起点，我们使用PIC单片机的数量很快就达到了每月100K以上，一年以后Microchip香港公司经理Andi主动找上门来将当时的广州强力电子研究所发展成为了授权分销商。
        毫不否认盖茨的远见和判断力是微软至关重要的核心竞争力，但盖茨也绝非天才，否则盖茨就不会在浏览器上输给网景了，尽管微软使用的很多技术都不是微软所发明的，但毫不妨碍微软独步天下。

注重核心技术，其余的外包
        通过创业以来第一个项目的成功，我深深地体会到商业模式比技术本身更重要。
        通过十多年的努力，我们设计的“铁将军（Steel Mate）”品牌汽车防盗器、汽车倒车雷达不仅成为了全世界范围的“隐性冠军”，而且为GE等世界著名汽车厂商售前市场提供配套产品，与此同时我们为智能卡酒店门锁厂商设计与制造的各种智能卡门锁控制模块在国内也一直处于第一名的地位。
        他们为何能够取得与众不同的成功呢？其最大的长处就是产品创意与制造、简约时尚风格的工业设计、模具制造技术以及精心打造的销售渠道，这些厂商深刻明白“注重核心技术做自己擅长的，其余的外包分段取利”的基本道理，而对于我来说就是“智慧出租”，通过与强者合作获得双赢。
        通过这些成功经验的积累，我们开始全力以赴注重发展核心技术，将自己不擅长的技术全部外包。比如，我们长期投资清华大学计算机系，并建立以陈渝博士后为主Linux内核开发团队，为公司底层的技术提供良好支撑，而我们自己则将精力集中于Linux驱动开发。这种分工合作、协同开发的模式赢得市场上宝贵的时间，并快速取得了应用成果。
        也许有程序员会关心JTAG开发工具问题，那也是一个“外包”的项目。当时，我们在网上发现了一个由计算机爱好者业余时间设计的H-JTAG，这是一个比较稳定的调试器软件，正好适合我们使用。于是我就同设计者联系，并决定由周立功单片机资助他继续开发，同时，其开发成果还免费提供给网上的用户下载，保证它作为一个自由软件。其实，无论是Linux还是H-JTAG都是开源软件，如果担心其它的同行因此受益而超越自己的话，难免需要在公司负担很多开发人员，面面俱到地做许多事实上是重复的开发工作。其实，我们的合作伙伴都是所在领域的专家，如果自己从头到尾去学习和开发，不仅抢了合作伙伴的饭碗，而且结果未必理想。这种情况下不但会延误宝贵的商机，而且还会影响与合作伙伴之间的关系。其实只要引入我们企业长期积累和制定的嵌入式系统工程管理思想和规范，即可得到自己想要的结果：“做你最擅长的，其余的外包”，类似这样的案例在周立功单片机将会越来越多。
        
专注与差异化生存
        1999年1月23日我离开了原公司，先后分别创立了广州周立功单片机发展有限公司与广州致远电子有限公司，分别从事贸易业务与产品制造。
        作为代理商通过为客户提供解决方案从而达到大批量销售芯片是代理行业惯常使用的手段，而实际上通过设计能够真正达到增值获得丰厚回报的代理商却少之又少。要知道过去公司的人才数量和资源是非常宝贵的，如果没有正确的战略，机会可能稍纵即逝。事实上创业开始的前几年，我们一共为用户设计了超过100个品类的产品，产品型号超过500种，可以说几乎涉及到了各行各业，但能够带来稳定而丰厚回报的案例几乎没有。我经过一段时间的思考和报表分析发现，目前公司的业务做得太多、太杂，没有将任何一个行业做精。于是我下定决心减少用户数量集中精力在1－2个行业做强、做大，直至成为顶尖的行业专家，坚持十年如一日重点做好汽车配套产品与智能卡门锁控制模块的开发。通过多年的精耕细作，我们通过为直接用户设计产品增值年销售单片机的数量已经超过了1000万片，无论是对用户还是对半导体公司来说，我们无疑是一家非常有价值的代理商。
        1999年5月，PHILIPS半导体公司邀请我去上海洽谈是否有意向代理LPC700单片机，当我拿到用户手册时离去上海的时间只有5天。当时公司不像现在有250位大学生，总共只有8个人，怎么办？我一边写商业计划书，一边与大家翻译用户手册、打字和贴图，面对机会就像抓住救命稻草一样加班加点，每天只休息3－5个小时。第5天我赶到上海东亚富豪酒店时，我将整整齐齐的材料放在了来自美国PHILIPS半导体公司2位经理的面前，包括吃饭在内仅仅只洽谈了2个小时，代理权就正式谈下来了。事后他们告诉我，就是因为我与众不同，专注且非常有个性。
        风雨变换诱惑莫测，人怕出名猪怕壮，这是常理！随后找上门来要求我们代理芯片的著名半导体公司不下10家。这时候，对于很多人来说不做什么就是一个艰难的选择。此时，我认为不管对方开出的条件多好，有冲突的就是不做，性能不突出的也不做，如果能够形成价值链互补，就一定要通过自己的努力和业绩表现主动去“求”半导体公司授权给我们，我就是这样取得了Keil、Catalyst、Sipex的代理权和信用额度。2004年SHARP半导体公司北京、日本、美国一共五位经理来到我的办公室要求我代理SHARP的ARM，帮助SHARP在中国推广以及制造用于全球销售的开发套件，我根本没有思考就一口回绝了，可以说SHARP给我的条件非常之好，特别是美国人觉得是非常不可思议的事情，作为商人这么好的赚钱机会都不要。为什么？我们之所以暂时“强大”，就是因为我们长期以来专注于发展PHILIPS半导体，集中精力对准焦点成为了小河里的大鱼，进而才引起了众人的关注。如果我们分散了精力，最后的结果一定会什么都不是！
        当决定专注的目标之后，接下来的就是想办法如何做得与众不同，这是一件不容易的事情。最重要的就是穷举用户最大的需求和竞争者最容易忽略之处，然后将其做到最好。
        为了推广好PHILIPS的单片机和ARM，我们定位于帮助初学者快速入门，至今一共编写出版了20多本专著，并将大部分版权全部捐献给了出版社用于降低成本，同时我也还会继续坚持将这项工作做下去、争取做得更好。邓小平有一句名言：“计算机要从娃娃抓起！”我认为，任何一个有远见的厂商，要想成功地推广嵌入式系统，一定要从在校大学生抓起，这必定是一件一举多得的好事。既能够提高企业的美誉度，又能获得市场占有率，还能为学生提供实践的理论基础。为何很少有厂商或者代理商心甘情愿去做？这不仅可帮助企业建立差异化，而且还能够给企业带来长远的利益，何乐而不为？
        比如说，至今在国内任何一家代理商的网站上几乎都找不到完整的芯片中文数据手册、用户手册与应用手册，不是我们的同行不知道其中的重要性。首先大家普遍认为这是半导体公司的份内之事，其次大家或许感到自己做好之后放到网站任由用户免费下载，会给其它代理商占了便宜。但很多人却始终不明白，这是满足用户需求制造公司服务差异化的最佳机会。
        于是我们决心从网站入手坚持长期投资，做中国最好的嵌入式系统专业技术网站，建立专业的技术支持与开发团队。特别是对于优质用户的服务，网站还专门开通了“快速绿色通道”，如果这样的用户遇到问题，都是由我、分公司经理及其相关服务部门的经理牵头负责实施“保姆式”的服务，我们实施的服务战略就是：“用有限的资源为有效的用户提供高质量的服务”。
        “你若亲近神，神就亲近你！” 2001年8月一篇来自PHILIPS内部刊物的报道《风险意味着机会》，我是被推上了“本地英雄”封底人物栏目的第一位亚洲代理商；2004年PHILIPS半导体公司又给我授予了“优秀卓越贡献奖”，来自全国各地的用户连续多年通过《亚洲资源》媒体将我们公司评选为“本地十大最受客户欢迎的分销商”。没有用户崇高的忠诚度和长期的大力支持，我们不可能从1999年以来连续多年销售单片机取得PHILIPS亚太区第一名的业绩。
        一个“人弃我取”的机会成就了我，尽管个人与团队的努力至关重要，但可以毫不掩饰地说，如果没有PHILIPS半导体经理的慧眼相马，一定是巧妇难为无米之炊，业界不会再有我的一席之地。
        在嵌入式系统应用技术方面与我们不相伯仲或者说比我们聪明能干的人才何止万千，为何只有少数人能够脱颖而出呢？就是因为想法太多、不专注，不能坚持在一个行业里面十年如一日地下苦功夫。但面对众多的竞争者和后来者，我每天都如履薄冰，不敢有丝毫的懈怠，每天坚持学习到深夜，因为唯有不断地学习和更新思维才有可能具备远见并及时规避可能出现的失误。

关注用户的需求
        其实维系企业生命的关键在于产品是否能够获得市场的青睐，我们要做的并非是成为技术的领先者，而是要将技术成果转化为迎合消费者需要的商品。
        八十年代是一个物质缺乏的年代，而今天的人们更加注重消费享受和情感的分享，这是任何人都无法否认的现实。我们公司刚开始做产品时，由于我个人偏爱蓝色，所以我凭着老板的权威将所有产品的外观全部都做成蓝色，其实当时也有不少的人向我提出改进意见，但我仍然还是无动于衷，为什么？就是因为我是做技术出身的，而且从创业初期开始一直都是依靠技术一路拼杀过来的，可以说过于迷信技术的力量，因此在很长的一段时间内，公司完全走的是研究的路子。而我却恰恰忽视了用户读产品的心理需求，以至于在产品推向市场之后一直都无法打开局面。
        当时，EasyPRO系列编程器面市的时候，其销售数量一年下来都不到500套，同时有用户表示对于产品的设计很不满意，这可以说是一次深刻的教训。于是我下定决心组建工业设计事业部，首先从EasyPRO系列通用编程器开始，亲自管理、研究和参与产品的外观设计，将原来的模具全部废掉重新设计。尽管是第一次设计，在产品的外观上没有做出非常杰出的效果，但无论如何，新产品外观比原有的产品出众得多。2005年10个月的时间里，EasyPRO系列通用编程器的销售数量达到了6000套。2006年我们又推出了SmartPRO系列智能型通用编程器，预计本年度销售编程器的总数量将超过10000套，而这些产品将带着我和我们公司跻身于国内编程器市场主流品牌之列。
        从那次深刻的教训以后，我明白好的外观设计可以凸现产品的魅力，让产品与环境融为一体，刺激消费者产生强烈的购买欲望。即使是普通产品，经过精心设计，也会成为一件时尚产品，甚至让人们觉得它就是一件艺术品，从这一点来说，时尚、新潮、艺术化的外观设计是塑造产品品牌形象的第一要素。
        从那以后，我开始改变产品简介、广告以及展示会的形象设计，为了配合新的形象，我们展开了大规模、全方位的宣传：一方面尽量多地为用户提供产品简介手册，同时通过大量的媒体广告，让用户认识并初步了解公司，从而迅速有效地提高了品牌知名度；另一方面组织各种全国巡回演讲、免费ARM技术培训活动和产品展示会，而且我们每次参加展示会都是投入4个摊位并进行特装展位设计，目的就是为了获得与用户积极沟通的机会。
        2003年暑假期间，周立功单片机投资80万元邀请了行业3位著名的嵌入式系统专家组成讲师团在全国10个城市主办了免费的ARM巡回演讲，提供了免费的午餐，可以说规模空前。这次巡讲中，共有8000多人参加了这次活动，随后公司趁热打铁推出了售价400元的EasyARM2104开发学习套件，第一个月生产的1000套在15天之内抢购一空，直到销售了15000套之后才因新产品的推出而停产。这次活动不仅收回了80万元的宣传费用，而且还直接或间接地影响了超过50万嵌入式相关人员，强有力地达到了品牌宣传的目的。在赢得丰厚利润回报的同时，也打造了嵌入式行业一次非常成功的“事件营销”经典案例，我深深地体会到“俘虏”用户的心是提升品牌的唯一途径。

全球化市场意识
        过去，一个公司可能需要等到10年之后才开始考虑是否全球化，而今天由于网络技术的发展，无论我们身处何地，世界各地的新信息仿佛就在眼前，谁也不会被边缘化了，所以今天成立公司明天就要准备全球销售。
        这几年ARM已经到了热得不得了的程度，很多人不以为然，其实这是一种必然趋势。事实上，我在美国PHILIPS半导体公司看到，美国1997年出版的《嵌入式系统》杂志就已经大量刊登OS与32位嵌入式系统开发工具等文章和广告。在美国硅谷主办的嵌入式系统展示会上，来自欧美的上千展位展现在我眼前的是各种各样嵌入式系统产品，中国厂商普遍展示的是蜂鸣器、继电器等低档元器件。我第一次身临其境地感受到了中美之间的差距究竟有多大。中国太需要懂得国际市场需求和游戏规则的人才和企业家了。
        同样是做USB分析仪，全球只有5家，我们自己的USB分析仪升级版在中国目前定价为3800元，这款产品原来的售价只有1800元，用户还认为太贵了。其实这样的产品在国内一年的销售数量也就200台，但是同样的情况在美国，一个小公司一年的销售额就能够到2000万美元，他们的单台最低售价不低于10000美元，以至于美国同行直接给我来电话，希望我在售价的基础上至少加一个0。
        中国企业不做全球化销售能行吗？不行！而且中国企业必须向价值链顶端攀升，否则我们只能做欧美消费品市场的廉价加工基地。

个性化的企业文化，帮助他人走向成功
        通过与用户合作所经历的共同成功过程中，用户将我教育成为了一个善良、上进、诚实、优秀的人才。我不仅懂得如何做自己最擅长事情的方式方法，而且也懂得了如何与用户、与员工分享成功的道理。一旦芯片销售数量增大成本下降就主动给用户降价，赢得了用户更长远的支持；公司效益提高了，年终就主动给员工涨工资、加奖金并对优秀员工提供购房津贴。由于公司的规模不大，我们一直以招聘二类本科应届生为主，在内部采取导师制的培养模式，为他们提供至少一年的严格训练，帮助他们规划职业生涯，想尽办法提供机会将他们培养成优秀的人才。这些年来不少公司打电话向我们公司挖人，关键人才从未出现过流失，至今跳槽的员工不超过12人，我深深地感到这就是我人生最大的快乐和财富，离开了支持我的用户和追随我的人才，我将变得一钱不值。
        为了保证企业的可持续发展所带来的人才困境，我与江西理工大学合作以五年为期开办了“3＋1”嵌入式系统应用开发特训班，与此同时还设立了每人3000元共10人的“周立功奖学金”资助那些动手能力极强而成绩中等的学生，开展校企无缝联接，培养嵌入式系统创新性开发人才的有益尝试，即就是从7个班中选拔30位爱好者用3年的时间修完所有课程，我们为每一位学生提供一台计算机、全套开发工具及其设计中所发生的一切费用，由我们组织著名专家开设专题讲座和课程，学校组织1位专职辅导员和2位指导教师，并由我们提供必要的津贴，然后用一年的时间专门做毕业设计，为此我们制定了严谨、细致的培训计划。
        这些年我们还不断赞助各省电子大赛、毕业设计大赛、创新设计大赛，捐赠了50所大学单片机创新实验室，以求扩大企业的知名度和广泛寻求人才的来源。

最后的话
        很多开发工程师以为这些都是老板或者经理们应该考虑的问题，与己无关，其实是大错而特错。作为一位优秀而卓越的开发人员，如果希望获得人生的完全成功和快乐，我们时刻需要明白，任何一个企业的可持续发展一定是群策群力的结果。
        1981年我经历了高考失败之后上了技校，1999年我作为劳动模范被保送上了大学，创业至今十多年来，往事依然历历在目，用户给予我的回报很多，很难在此一一完全道来，谨以此文与同行、用户分享和交流。
        这些年来，我陆续捐资资助教育、设立奖学金以及帮助家乡修建乡村水泥公路、祠堂等公益事业回馈社会。1990年的中秋节，我只身一人南下广东打工，不曾想到会有今天这样的成绩，我一直非常珍惜这来之不易的机会。
        作为一个嵌入式技术爱好者，我的愿望就是：“生命不息、奋斗不止！”力争为发展中国的嵌入式系统应用技术贡献自己的一份力量。

--

※ 修改:·pooh1949 于 Nov 10 20:12:33 修改本文·[FROM: 59.64.154.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.197.*]
 【文章标题】：[合集] 2.6.23内核中申请gpio中断的函数是什么? 【文章地址】：https://bbs.byr.cn/article/Embedded_System/496 【创建时间】：2008-05-31 【作者】：Winters101 【评论】：0 【内容】：发信人: Winters101 (Winters), 信区: Embedded_System
标  题: [合集] 2.6.23内核中申请gpio中断的函数是什么?
发信站: 北邮人论坛 (Sat May 31 09:06:04 2008), 站内

☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Wed May 28 11:45:38 2008)  提到:

原来2.4是set_GPIO_IRQ_type(11|FALLING_EDGE)使用起来非常方便,到了2.6.23反而找不到了


☆─────────────────────────────────────☆
   jklbupt (jklbupt) 于  (Wed May 28 16:59:38 2008)  提到:


我觉的这也和你要用的相关硬件CPU相关吧,做芯片级移植的时候可能就定了是那个函数了.比如XScale系列用的  pxa_gpio_mode();  set_irq_type(); 然后再用request_irq()即可 .我个看法,欢迎讨论.



【 在 lester98 的大作中提到: 】
: 原来2.4是set_GPIO_IRQ_type(11|FALLING_EDGE)使用起来非常方便,到了2.6.23反而找不到了 



☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Wed May 28 17:18:13 2008)  提到:

sorry.忘了说了,pxa270(arm/xscale)
我开始以为是static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
经过试验发现根本不行

这个也不对头,这个不是对gpio的,对gpio至少也得方向设为in,对GFER或GRER进行设置
我拿2.4的函数改一个试试吧


☆─────────────────────────────────────☆
   jklbupt (jklbupt) 于  (Wed May 28 17:48:02 2008)  提到:


我这边的板子上用pxa_gpio_mode();  设置管脚方向,set_irq_type(); 设置中断沿的类型.也许内核版本不一样,函数改的不同了,如果有源代码且你不是做芯片,板级移植的话,可以借鉴下代码中其他外围芯片GPIO中断是如何用的.



【 在 jklbupt 的大作中提到: 】
: 我觉的这也和你要用的相关硬件CPU相关吧,做芯片级移植的时候可能就定了是那个函数了.比如XScale系列用的  pxa_gpio_mode();  set_irq_type(); 然后再用request_irq()即可 .我个看法,欢迎讨论. 



☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Wed May 28 18:02:39 2008)  提到:

经过实践只用这个函数就行了,连gpio_mode都不用设了,明天来了我看看代码,把gpio设置成各种初始状态再调用这个函数试试,不知道这个是不是巧合


☆─────────────────────────────────────☆
   jklbupt (jklbupt) 于  (Wed May 28 18:24:58 2008)  提到:

这个最好分析下,我记的Xscale系列GPIO默认上电管脚是输入,所以不用设置.


☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Thu May 29 00:37:44 2008)  提到:

～～看kernel代码找相应函数就好了，实在不行自己写一个也可以：）


☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Thu May 29 10:14:10 2008)  提到:

原来调用chip.c中的set_irq_type()后会调用arch/arm/mach-pxa中的pxa_gpio_irq_type
就是很疑惑单独调用后者为什么不行,而且irq_desc是在前者中定义的,并未见初始化,怎么就能找到static struct irq_chip pxa_low_gpio_chip了呢?算了,这个就不研究了,暂时没有这个必要,能用就行了

2.6现在给封装的是更加易用了,不过也得你先适应


☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Thu May 29 10:27:41 2008)  提到:

我贴出来,有达人帮助琢磨一下吧

//#kernel/irq/chip.c
int set_irq_type(unsigned int irq, unsigned int type)
{
    struct irq_desc *desc;
    unsigned long flags;
    int ret = -ENXIO;

    if (irq &gt;= NR_IRQS) {
        printk(KERN_ERR "Trying to set irq type for IRQ%d\n", irq);
        return -ENODEV;
    }

    desc = irq_desc + irq;
    if (desc-&gt;chip-&gt;set_type) {
        spin_lock_irqsave(&amp;desc-&gt;lock, flags);
        ret = desc-&gt;chip-&gt;set_type(irq, type);
这句话就调用了下面深绿色的pxa_low_gpio_chip中的pxa_gpio_irq_type,怎么能调的到呢?很费解,是desc = irq_desc + irq起的作用吗?但desc只是个临时定义的局部变量啊,又不是全局的
        spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
    }
    return ret;
}

//#arch/arm/mach-pxa/irq.c
static struct irq_chip pxa_low_gpio_chip = {
    .name        = "GPIO-l",
    .ack        = pxa_ack_low_gpio,
    .mask        = pxa_mask_low_irq,
    .unmask        = pxa_unmask_low_irq,
    .set_type    = pxa_gpio_irq_type,
    .set_wake    = pxa_set_gpio_wake,
};


☆─────────────────────────────────────☆
   DusTin (老了) 于  (Thu May 29 12:52:57 2008)  提到:

个人理解：
成员都是函数指针，赋值的时候直接把函数指针地址赋给成员，调用的时候直接去那个地址运行，相当于回调函数
【 在 lester98 的大作中提到: 】
: 我贴出来,有达人帮助琢磨一下吧 
: //#kernel/irq/chip.c 
: [color=#228B22]int set_irq_type(unsigned int irq, unsigned int type) 
: ................... 



☆─────────────────────────────────────☆
   DusTin (老了) 于  (Thu May 29 13:01:51 2008)  提到:

irq_desc是个全局变量，加上irq的偏移就可以定位到对应的pxa_low_gpio_chip
在void __init pxa_init_irq(void)调用set_irq_chip(irq, &amp;pxa_low_gpio_chip);将以irq为偏移的irq_chip结构体放到irq_desc全剧变量中


☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Thu May 29 13:04:02 2008)  提到:

irq_desc + irq
记得是真正的irq地址


☆─────────────────────────────────────☆
   DusTin (老了) 于  (Thu May 29 13:13:52 2008)  提到:

struct irqdesc irq_desc[NR_IRQS];全剧变量
然后在
int set_irq_chip(unsigned int irq, struct irq_chip *chip)
{
    struct irq_desc *desc;
    unsigned long flags;

    if (irq &gt;= NR_IRQS) {
        printk(KERN_ERR "Trying to install chip for IRQ%d\n", irq);
        WARN_ON(1);
        return -EINVAL;
    }

    if (!chip)
        chip = &amp;no_irq_chip;

    desc = irq_desc + irq;
    spin_lock_irqsave(&amp;desc-&gt;lock, flags);
    irq_chip_set_defaults(chip);
    desc-&gt;chip = chip;
    spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);

    return 0;
}
把chip放进去
int set_irq_type(unsigned int irq, unsigned int type)
{
    struct irq_desc *desc;
    unsigned long flags;
    int ret = -ENXIO;

    if (irq &gt;= NR_IRQS) {
        printk(KERN_ERR "Trying to set irq type for IRQ%d\n", irq);
        return -ENODEV;
    }

    desc = irq_desc + irq;
    if (desc-&gt;chip-&gt;set_type) {
        spin_lock_irqsave(&amp;desc-&gt;lock, flags);
        ret = desc-&gt;chip-&gt;set_type(irq, type);
        spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
    }
    return ret;
}
直接调用相应的set_type
【 在 fzylijun886 的大作中提到: 】
: irq_desc + irq 
: 记得是真正的irq地址 



☆─────────────────────────────────────☆
   jklbupt (jklbupt) 于  (Thu May 29 13:32:58 2008)  提到:

上边大家说的很详细了.我补充点吧,即中断的初始化过程.
init/main.c                       start_kernel()
                                       |
arch/arm/kernel/irq.c              init_irq()
                                       |
init_arch_irq()即mainstone_init_irq()
在文件arch/arm/mach-pxa/mainstone.c
                                       |
arch/arm/mach-pxa/irq.c                pxa_init_irq()
                                                                    |
                                                                set_irq_chip()
                                                                        
另外函数指针的作用(赋值后)可以调用其他文件中的函数,包括用static声明的函数


☆─────────────────────────────────────☆
   jklbupt (jklbupt) 于  (Thu May 29 13:38:34 2008)  提到:

忘了说一下，这个是针对Xscale平台即mainstone系列的开发板，其他的平台（CPU）也是这个顺序。  


【 在 jklbupt 的大作中提到: 】
: 上边大家说的很详细了.我补充点吧,即中断的初始化过程. 
: init/main.c                       start_kernel() 
:                                        | 
: ................... 



☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Thu May 29 14:48:10 2008)  提到:

哦,我的这个眼睛啊
desc = irq_desc + irq
前者是这里定义的变量,irq_desc就是全局的嘛,真晕,谢谢楼上几位!


☆─────────────────────────────────────☆
   DusTin (老了) 于  (Thu May 29 14:51:09 2008)  提到:

这个结构体和那个全局变量用了相同的名字
struct irqdesc irq_desc[NR_IRQS];
struct irq_desc {
    irq_flow_handler_t    handle_irq;
    struct irq_chip        *chip;
    void            *handler_data;
    void            *chip_data;
    struct irqaction    *action;    /* IRQ action list */
    unsigned int        status;        /* IRQ status */

    unsigned int        depth;        /* nested irq disables */
    unsigned int        wake_depth;    /* nested wake enables */
    unsigned int        irq_count;    /* For detecting broken IRQs */
    unsigned int        irqs_unhandled;
    spinlock_t        lock;
#ifdef CONFIG_SMP
    cpumask_t        affinity;
    unsigned int        cpu;
#endif
#if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
    cpumask_t        pending_mask;
#endif
#ifdef CONFIG_PROC_FS
    struct proc_dir_entry    *dir;
#endif
    const char        *name;
} ____cacheline_aligned;
【 在 lester98 的大作中提到: 】
: 哦,我的这个眼睛啊 
: desc = irq_desc + irq 
: 前者是这里定义的变量,irq_desc就是全局的嘛,真晕,谢谢楼上几位! 



☆─────────────────────────────────────☆
   DusTin (老了) 于  (Thu May 29 14:51:51 2008)  提到:

呵呵，我一开始看了一眼也觉得奇怪
【 在 lester98 的大作中提到: 】
: 哦,我的这个眼睛啊 
: desc = irq_desc + irq 
: 前者是这里定义的变量,irq_desc就是全局的嘛,真晕,谢谢楼上几位! 



☆─────────────────────────────────────☆
   lester98 (奶瓶) 于  (Thu May 29 14:53:00 2008)  提到:


【 在 DusTin 的大作中提到: 】
: 这个结构体和那个全局变量用了相同的名字 
: ................... 

所以给看差了,本来很好理解的东西,我的眼睛就象筛子一样,把有用的信息给漏掉,主要我用了sourceInsight,一般的全局都是紫色的,这里我只从内核里挑了一部分代码看,估计没有那个全局变量的定义,所以sourceInsight把它当成原型了,就是绿色的了


☆─────────────────────────────────────☆
   Jorden (Mickey Mouse) 于  (Thu May 29 19:14:25 2008)  提到:

拜读


 【文章标题】：2.6.23内核中申请gpio中断的函数是什么? 【文章地址】：https://bbs.byr.cn/article/Embedded_System/462 【创建时间】：2008-05-28 【作者】：lester98 【评论】：0 【内容】：发信人: lester98 (奶瓶), 信区: Embedded_System
标  题: 2.6.23内核中申请gpio中断的函数是什么?
发信站: 北邮人论坛 (Wed May 28 11:45:38 2008), 站内

原来2.4是set_GPIO_IRQ_type(11|FALLING_EDGE)使用起来非常方便,到了2.6.23反而找不到了
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.150.*]
 

【文章标题】：有没有在ARM上使用winCE的介绍经验？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/406 【创建时间】：2008-05-23 【作者】：LoveMyBaby 【评论】：1 【内容】：发信人: LoveMyBaby (宝子), 信区: Embedded_System
标  题: 有没有在ARM上使用winCE的介绍经验？
发信站: 北邮人论坛 (Fri May 23 12:01:18 2008), 站内

如提
虚心请教！
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 125.33.185.*]
 
【文章标题】：【附件】推荐一本linux驱动的书 【文章地址】：https://bbs.byr.cn/article/Embedded_System/440 【创建时间】：2008-05-26 【作者】：DusTin 【评论】：1 【内容】：发信人: DusTin (老了), 信区: Embedded_System
标  题: 【附件】推荐一本linux驱动的书
发信站: 北邮人论坛 (Mon May 26 23:04:34 2008), 站内

在水木上看到有人推荐的，正在看，感觉不错，图比较多，比较容易理解，而且kernel里面有的驱动基本都涉及到了

<a href="/att/Embedded_System/0/440/350" target="_blank" color="blue">附件(2.9MB)  ce[1].Hall.Essential.Linux.Device.Drivers.Apr.2008.part1.rar</a>

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.228.*]

 
【文章标题】：来自嵌入式培训机构的完整学习计划 【文章地址】：https://bbs.byr.cn/article/Embedded_System/499 【创建时间】：2008-06-01 【作者】：tjfmail 【评论】：0 【内容】：发信人: tjfmail (PE_passion &amp; energy), 信区: Embedded_System
标  题: 来自嵌入式培训机构的完整学习计划
发信站: 北邮人论坛 (Sun Jun  1 13:33:04 2008), 站内

嵌入式系统工程师 培训计划

课程名称           主要内容
数据结构    
1.    数据结构的定义
2.    树与二叉树
3.    树遍历的实现
4.    数据结构的内部排序
网络编程    
1.    TCP/IP协议
2.    SOCKET协议
3.    QT
ARM体系结构    
1.    计算机体系结构
2.    ARM体系结构和指令集
3.    ARM启动代码原理分析
系统编程    
1.    I/O与文件系统
2.    操作系统
3.    进程
4.    信号
5.    线程
驱动程序设计    
1.    设备驱动的简介
2.    LINUX KERNEL模块
3.    字符设备驱动
4.    中断理论
5.    USB驱动程序设计
嵌入式应用开发    
1.    构建嵌入式LINUX系统
2.    SQLITE
3.    QTOPIA CORE

--

莫听穿林打叶声,何妨吟啸且徐行;
竹杖芒鞋轻胜马,谁怕!一蓑烟雨任平生


※ 修改:·Winters101 于 Jun  1 15:12:57 修改本文·[FROM: 59.64.186.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 

【文章标题】：[公告] Embedded_System 版开通附件功能 (转载) 【文章地址】：https://bbs.byr.cn/article/Embedded_System/434 【创建时间】：2008-05-26 【作者】：shaw1987 【评论】：0 【内容】：发信人: shaw1987 (恶魔小狮子的笨蛋赖皮豚---沙沙), 信区: Embedded_System
标  题: [公告] Embedded_System 版开通附件功能
发信站: 北邮人论坛 (Mon May 26 18:39:14 2008), 站内

【 以下文字转载自 Board_Management 讨论区 】
发信人: shaw1987 (恶魔小狮子的笨蛋赖皮豚---沙沙), 信区: Board_Management
标  题: [公告] Embedded_System 版开通附件功能
发信站: 北邮人论坛 (Mon May 26 18:39:04 2008), 站内

    经 Embedded_System 版版主申请，并由版面管理组讨论通过，
决定 Embedded_System 版开通附件功能。
    请在版规里加入可以上传的附件内容和类型。

    英文版名： Embedded_System
    中文版名： 嵌入式系统
    分    区： 学术科技
    附件类型:  图片/照片/文档/源代码


       
                                              北邮人论坛版面管理组

--
发信人: woshita (Zz镜涵), 信区: Joke
标  题: 。。。不知冷否。。
发信站: 北邮人论坛 (Tue Dec 11 23:29:05 2007), 站内


--关于脸部浮肿。。也就是大饼脸的医学术语——满月脸。。。很是诗意吧。。。


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.194.152]
 
【文章标题】：请教 MCU对FPGA动态配置方面的问题 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1884 【创建时间】：2008-10-27 【作者】：xiaoyeah 【评论】：1 【内容】：发信人: xiaoyeah (yeah), 信区: Embedded_System
标  题: 请教 MCU对FPGA动态配置方面的问题
发信站: 北邮人论坛 (Mon Oct 27 10:33:37 2008), 站内

有哪位大侠做过 MCU对FPGA动态配置 方面的工作的？
用MCU对Xilinx的FPGA进行Configuration
Slave Parallel (SelectMAP) Mode
而不是 外接PROM芯片 上电后可以在电配置FPGA

我最近在做这方面的事情，想请教一下。
--

※ 修改:·xiaoyeah 于 Oct 27 10:34:31 修改本文·[FROM: 203.86.43.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 203.86.43.*]
 
【文章标题】：CROSSTAR被取消在Embedded_System版的发文权限 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1906 【创建时间】：2008-10-27 【作者】：lester98 【评论】：0 【内容】：发信人: lester98 (奶瓶|单车旋风族之太阳风), 信区: Embedded_System
标  题: CROSSTAR被取消在Embedded_System版的发文权限
发信站: 北邮人论坛 (Mon Oct 27 12:10:04 2008), 站内

由于 CROSSTAR 在 Embedded_System 版的 签名与头像广告 行为，
被暂时取消在本版的发文权力 4 天。
                              版主:lester98
                              Mon Oct 27 12:09:29 2008

 
【文章标题】：【嵌入式小组第五次学习讨论会总结】 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1865 【创建时间】：2008-10-27 【作者】：sweetfly 【评论】：5 【内容】：发信人: sweetfly (mession), 信区: Embedded_System
标  题: 【嵌入式小组第五次学习讨论会总结】
发信站: 北邮人论坛 (Mon Oct 27 00:08:03 2008), 站内

       10月25日，嵌入式第五次学习讨论会在教三会议室举行，本次会议的主题为U-boot代码的分析，主讲人是来自北邮嵌入式方向的权威实验室----邝坚教授实验室的徐进同学。主讲内容如下：
         1）U-boot的作用及U-boot的两个阶段；
         2）U-boot的体系结构（主要介绍了U-boot代码主要目录结构）；
         3）U-boot移植所需要的各种头文件的配制；
         4）U-boot启动时所调用的主要函数的代码分析；
        随后一名小组成员演示了ATmel-9260开发板中U-boot和Linux内核的启动流程以及相关代码的分析；
        最后由负责技术的组员讲解了协会与intel公司合作项目的相关预备知识，主要是Moblin和MID。
       本次小组讨论，徐进同学的讲解，再配合U-boot代码具体分析，让许多初学者受益非浅，希望能有更多的同学参与到我们这个队伍之中！一起学习，一起交流，共同进步!

--

№☆♀fighting　for　you♂


※ 修改:·sweetfly 于 Oct 27 00:16:53 修改本文·[FROM: 118.229.138.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.138.*]
 
【文章标题】：[求助]BOPS是什么单位？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1915 【创建时间】：2008-10-27 【作者】：bupt7 【评论】：4 【内容】：发信人: bupt7 (雀巢冰爽茶(要绿的)), 信区: Embedded_System
标  题: [求助]BOPS是什么单位？
发信站: 北邮人论坛 (Mon Oct 27 14:06:57 2008), 站内

RT``
是DSP里数据处理速率的单位，例如定点处理能力为 14.4 BOPS等等``
但我不明白这里面的“B”是什么意思~
是billion么？但billion的话完全可以用"giga-"（G）来表示啊~~而且“G”以上是“T”（1024G）……
不知道“B”代表什么~~也许对于一些人来说是个很简单的问题，那就请你们别吝啬了，告诉我一下吧：）
--
水能载舟,亦能煮粥~

※ 修改:·bupt7 于 Oct 27 14:09:33 修改本文·[FROM: 124.207.46.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.207.46.*]
 
【文章标题】：linux嵌入式开发时先在PC开发，然后迁移到嵌入式是否可行？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1823 【创建时间】：2008-10-26 【作者】：gentleangel 【评论】：12 【内容】：发信人: gentleangel (北邮人), 信区: Embedded_System
标  题: linux嵌入式开发时先在PC开发，然后迁移到嵌入式是否可行？
发信站: 北邮人论坛 (Sun Oct 26 14:50:28 2008), 站内

貌似在PC上和在嵌入式上的linux源代码很多都类似
比如一个串口通信程序
在PC上用gcc编译运行OK
然后用arm-linux-gcc编译，在嵌入式上运行（可能需要修改头文件和一些调整）

这种思路是否可行呢？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.141.*]
 
【文章标题】：谁用VS2005通过网线连wince5.0调试啊？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1950 【创建时间】：2008-10-27 【作者】：luckyant 【评论】：0 【内容】：发信人: luckyant (12), 信区: Embedded_System
标  题: 谁用VS2005通过网线连wince5.0调试啊？
发信站: 北邮人论坛 (Mon Oct 27 23:31:46 2008), 站内

为啥我一直不成功呢~
.net的程序~
现在调试只能用模拟器~
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.8.*]
 
【文章标题】：[原创]嵌入式linux开发环境该如何搭建 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1889 【创建时间】：2008-10-27 【作者】：Lumpy 【评论】：5 【内容】：发信人: Lumpy (Lumpy), 信区: Embedded_System
标  题: [原创]嵌入式linux开发环境该如何搭建
发信站: 北邮人论坛 (Mon Oct 27 11:13:08 2008), 站内

开发环境这个不太好说,反正就是一个基本的linux系统加上你开发需要的软件,比如你要开发qt,就需要交叉编译器,tmake,libstdc++等等,开发不同的东西需要的环境也是不一样的

但是,对于入门的人来说,最基本的开发环境就是交叉编译环境,也就是linux系统+交叉编译器,这是最基本的.

linux系统一般用于开发的是fedora的比较多,原来redhat是最流行的,但是redhat早就停止更新版本,所以fedora以其继承人的身份,变成最流行的了,如果是开发qt的话suse也不错,因为trolltech公司用的环境就是suse.ubuntu现在比较流行,但是用于开发并不是很好,我尝试用过,遇到很多麻烦,虽然最后都能解决,但是对于新人来讲可能解决起来会更加麻烦.其他的linux系统了解就不是很多了.

当然,linux环境不仅仅只是安装的最基本的linux系统,还应该包括一系列的软件,比如常用的命令,make,sed.....常用的软件tftp,nfs.....常用的库libc libstdc++....一般发行版的linux都带有常用命令和库,但是常用软件,比如嵌入式开发中很常用的tftp server nfs 以及少部分的库就不一定有了,怎么办呢?方法非常简单,比如你想安装tftp server或者编译过程中提示你没有x86的libstdc++某个版本的库,你就到www.rpmfind.net或者是<a target="_blank" href="http://rpm.pbone.net/">http://rpm.pbone.net/</a>上面搜"tftp-server""libstdc++"就会搜到针对不同linux系统的rpm包,比如你用的是fedora8系统,就找到对应的rpm包,下载,再安装--rpm -ivh xxxx.rpm 就可以了

另外一个就是交叉编译器了,一般用的都是cross-tool或者eldk,他们都包含交叉编译的可执行文件,以及可能用到的一些头文件和交叉编译的库(同样是libstdc++,这里是arm指令的)cross-tool一般有各种版本,2.95.3;3.3;3.3.2;3.4.1;4.1等等,不同版本是有差别的,并不一定能兼容,同一个程序,用3.3的能编译通过,用3.4.1的就不一定能通过.一般来将我用3.3和3.3.2编译很少出现问题,但是对于比较新的内核,比如2.6.24,它们就显得比较老,编译就通过不了,这种情况下我用的是eldk

cross-tool和eldk都可以在网上免费下载到,cross-tool不需要制作,解压缩就可以了,eldk需要安装一下,安装过程也很简单,看看readme就可以了.安装完成之后,只有把交叉编译器可执行文件的路径放到PATH变量里就可以了,以后调用交叉编译器的时候,系统就能自动找到它们,比如
cross-tool:export PATH=$PATH:/usr/local/arm/3.3.2/bin
eldk: export PATH=$PATH:/usr/local/arm/eldk/usr/bin

至此,一个交叉编译环境就完成了
下面去编译一个内核为例
cd xxxxxx/linux-2.4.21
make menuconfig
make arch=arm CROSS_COMPILE=/usr/local/arm/3.3.2/bin/arm-linux-


--
2就一个字

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.161.*]
 
【文章标题】：【更新主贴】[已解决]求教嵌入式板子怎么ping虚拟机中的主机 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1747 【创建时间】：2008-10-23 【作者】：gentleangel 【评论】：29 【内容】：发信人: gentleangel (北邮人), 信区: Embedded_System
标  题: 【更新主贴】[已解决]求教嵌入式板子怎么ping虚拟机中的主机
发信站: 北邮人论坛 (Thu Oct 23 15:58:53 2008), 站内

问题症状：

主机，开发板各一台，主机和开发板用串口线，一条交叉线分别连接，串口线用于minicom，网线用于nfs挂载。主机上是windows+vmware虚拟机（ubuntu/red hat），虚拟机的eth0 ifconfig为192.168.0.100，开发板eth0 ifconfig为192.168.0.50

在minicom中连接开发板，进入开发板的系统，ping 主机不通，但主机的终端可以ping开发板。

原因是windows的防火墙阻挡了vmware中的minicom终端ping主机。

结论：

如果遇到网络问题，首先检查一下防火墙！！！！

找到问题的所在了
就是…………
windows的防火墙软件害的…………因为我的ubuntu是在vmware里面的，所以估计防火墙给屏蔽了vmware的网络通讯的东西……
关了防火墙就好了……
ft死我，浪费两天时间啊…………


不知道ubuntu哪里有问题，板子死活不能ping主机
因为电脑太新……米有串口，所以用pci串口卡
redhat不认识那个卡……所以用了ubuntu
ubuntu认识串口卡，但板子ping不到它……
它ping板子ok

问下怎么解决……
--

※ 修改:·gentleangel 于 Oct 25 13:02:17 修改本文·[FROM: 59.64.141.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.141.*]
 
【文章标题】：大家觉得uC/OS怎么样 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1926 【创建时间】：2008-10-27 【作者】：CardMaster 【评论】：6 【内容】：发信人: CardMaster (死循环（详见签名档）), 信区: Embedded_System
标  题: 大家觉得uC/OS怎么样
发信站: 北邮人论坛 (Mon Oct 27 16:27:41 2008), 站内

最近在研究中。。
--
int main(){while(true) std::cout&lt;&lt;"I love you";}

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.166.*]
 
【文章标题】：请问两道汇编题，非常感谢！ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1963 【创建时间】：2008-10-28 【作者】：kun 【评论】：0 【内容】：发信人: kun (kun), 信区: Embedded_System
标  题: 请问两道汇编题，非常感谢！
发信站: 北邮人论坛 (Tue Oct 28 10:42:04 2008), 站内

题目如下，请高手指点，不胜感激！！！！！

2.（10分）用8255A作打印机接口的硬件连接和驱动程序如下所示，8255A的入口地址为80H~83H，阅读此程序回答下列问题： ⑴ 所采用的数据控制（查询，中断，无条件传送）方式？（2）对程序中引号后面加上适当注释

Pearl 16:51:42
MOV AL,081H
      OUT 083H,AL；
      MOV BX,3000H
      MOV CX,64H
      MOV AL,0DH
      OUT 083H,AL；
      STT: IN AL,082H；
      AND AL,08H
      JNZ STT
      MOV AL,[BX]
      OUT 080H,AL；
      MOV AL,05H
      OUT 083H,AL
      NOP
      NOP
      MOV AL,0DH
      OUT 083H,AL
      INC BX
      DEX CX
      JNZ STT
      HLT

Pearl 16:52:09
某微机系统中使用1片8253，其端口地址为300H、301H、302H、303H，系统提供的计数脉冲频率为500KHz，CLK1由8253内其它计数器提供，对8253的初始化程序如下所示，阅读该程序，请完成： (1)各个计数器输出的定时信号周期或频率。
Pearl 16:52:24
MOV DX, 303
　　MOV AL, 36H
　　OUT DX, AL;通道0写控制字，16位二进制计数值，方式3
　　MOV DX, 300H
　　MOV AL, 0F4H
　　OUT DX, AL；给计数器0附初值低8位
      MOV AL, 01H
      OUT DX, AL ；给计数器0附初值高8位
      MOV DX,303H
　　MOV AL, 54H 
　　OUT DX, AL；计数器1，8位二进制计数方式二
　   MOV DX, 301H
　　MOV AL, 0AH
      OUT DX, AL；给计数器 1 附初值0AH

--

※ 修改:·kun 于 Oct 28 10:43:08 修改本文·[FROM: 59.41.164.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.41.164.*]
 
【文章标题】：请推荐一款2410的开发板 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1966 【创建时间】：2008-10-28 【作者】：unchangedme 【评论】：3 【内容】：发信人: unchangedme (Ma), 信区: Embedded_System
标  题: 请推荐一款2410的开发板
发信站: 北邮人论坛 (Tue Oct 28 14:14:08 2008), 站内


决定买一款基于s3c2410(x)的ARM开发板,请高手推荐一下.

要求:

板子稳定,不会老出问题.最好能有技术支持.

最好能有比较详细的实验教程以及某一个操作系统下的系统移植过程的详细说明和BSP编
写的教程.


非常感谢!

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 159.226.114.*]
 
【文章标题】：移植clean内核到全新2410教程 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1965 【创建时间】：2008-10-28 【作者】：lester98 【评论】：1 【内容】：发信人: lester98 (奶瓶|单车旋风族之太阳风), 信区: Embedded_System
标  题: 移植clean内核到全新2410教程
发信站: 北邮人论坛 (Tue Oct 28 14:13:18 2008), 站内

无意搜到的,分享一下
<a href="/att/Embedded_System/0/1965/353" target="_blank" color="blue">附件(338.2KB)  </a>
--
希望将来能用这句话做签名
I graduated from this school ,and survive

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.161.*]

 
【文章标题】：insmod挂载驱动模块的问题 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1993 【创建时间】：2008-10-29 【作者】：mac1314 【评论】：6 【内容】：发信人: mac1314 (NewBer), 信区: Embedded_System
标  题: insmod挂载驱动模块的问题
发信站: 北邮人论坛 (Wed Oct 29 09:46:15 2008), 站内

编译了一个驱动模块
insmod的时候提示  
--------------------------------------------------------------------------------------------
[root@localhost adp94xx-1.0.8-12.src]# insmod adp94xx.ko
insmod: error inserting 'adp94xx.ko': -1 Unknown symbol in module
--------------------------------------------------------------------------------------------
查看／var/log/messages
有如下描述：
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_remove_host
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_partsize
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_device_set_state
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_add_device
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_host_put
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_scan_host
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_add_host
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_adjust_queue_depth
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_unblock_requests
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_remove_device
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_block_requests
Oct 28 23:33:08 localhost kernel: adp94xx: Unknown symbol scsi_host_alloc
-----------------------------------------------------------------------------------------------------
why?
请指教
PS：  
kernel 2.6.16
挂在成功过一次，在/proc/modules文件中有记录
rmmod 后再insmod就没成功过
总是提示“格式非法”或者“未定义的符号 ”
驱动程序在编译的时候也有一些警告，但是编译可以通过，可声称.ko文件   
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.142.*]
 
【文章标题】：【嵌入式学习入门 一】嵌入式开发如何入门[原创] 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1836 【创建时间】：2008-10-26 【作者】：ccliu 【评论】：63 【内容】：发信人: ccliu (匆匆过客), 信区: Embedded_System
标  题: 【嵌入式学习入门 一】嵌入式开发如何入门[原创]
发信站: 北邮人论坛 (Sun Oct 26 17:15:22 2008), 站内

     如今，嵌入式行业发展十分迅速，从业人数激增的同时仍存在很大的人才需求，这是一个令人激动的行业，它的前景十分广阔。做为一个想要进入嵌入式开发领域的新手来说，静下心来了解一下入门所必须知道的一些事是十分有必要的。下面以嵌入式Linux系统开发为例，结合多位过来人的看法，和大家分享那些入门必要的事儿。
<b>嵌入式Linux系统开发与传统的桌面PC开发有什么不同？</b>
    嵌入式Linux系统开发就是定制特定用途的设备开发。既然是设备当然有软有硬，硬件不像PC机那样通用兼容，这就要示根据特定的需求构造自己的硬件。嵌入式Linux系统开发的底层软件因为硬件的不统一也呈现出非一致性，也要根据特定设备需求进行裁剪。
<b>嵌入式Linux系统开发的开发环境是什么样子的？作为一名嵌入式Linux系统开发者应当如何建立自己的开发环境？</b>
     嵌入式Linux系统开发采用的是交叉编译环境，如下图所示，所谓的交叉，是指在你熟悉的PC机和你的开发对像-----嵌入式目标系统之间交叉。传统的PC开发，通过开发工具得到的成果在PC上就能验证，不需转移到其它设备上验证，嵌入式系统开发则不一样，PC主机上的交叉编译工具开发所得的结果在PC上是运行不了的，你得把它放到嵌入式目标系统上去运行，进行调试。两者交叉连接的手段如图中所列出的几种常见手段，各有各的用途。

<a target="_blank" href="/att/Embedded_System/0/1836/2754"><img border="0" title="" src="/att/Embedded_System/0/1836/2754" alt="" class="resizeable"></a>
<b>工作环境搭建好了以后，一个系统开发可以分成好几个层次的开发，你是全盘通吃呢？还是选择感兴趣的一部分深入研究？</b>
以Linux操作系统为核心的嵌入式Linux系统所会涉及到的开发工作可以用下图所示的一个分层结构展示出来：大致可分为三层。
&amp;#61548;    底层软硬结合部分，引导装载程序和驱动程序的移植开发。做这一部分开发工作，要有硬件架构基础，如常见的X86、ARM、PPC的硬件知识，基本指令集。Linux驱动开发这不用多说，是一个选择方向。
&amp;#61548;    裁剪Linux内核，以Linux内核为基础构建嵌入式Linux系统特有的设备系统，这可看着是桌面PC上Linux的一个定制，因为桌面PC的许多功能在嵌入式设备上并不需要。这部分开发，操作系统的知识你得有点吧，Linux操作系统得会玩吧！
&amp;#61548;    上层应用开发，这一层的工作更多，开发者的目标是，桌面PC能有的应用，只要用户有需要，都可以移植到嵌入式设备上来实现。

<a target="_blank" href="/att/Embedded_System/0/1836/10212"><img border="0" title="" src="/att/Embedded_System/0/1836/10212" alt="" class="resizeable"></a>
    任何一门技术都是理论和实践的学习才能有效果。对嵌入式Linux系统开发更是这样，你只有一台PC也许是不够的。了解了上面所提及的一些事实后，试着动手实践一下吧，踏上你的嵌入式开发学习之路，一路肯定不会顺风的，不要闭门造车，有空多出去透透风风吧，如果你多参与一些嵌入式相关的技术社团或讨论小组，那里或许有热心的人会和你交流的，在交流中你会学得更快。
    以上没有谈到任何一点有关具体技术实现的方法和步骤，只是希望读者能了解到要做嵌入式Linux系统开发，你应该知道的一些事。个人观点，与大家分享一下，希望热心人多多交流，但愿拍砖的能轻点啊！
<img src="/img/ubb/em/4.gif" alt="em4" style="display:inline;border-style:none">
--

※ 修改:·lester98 于 Oct 27 10:05:19 修改本文·[FROM: 221.221.161.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.151.*]

 
【文章标题】：【网文】uboot1.1.6源码浅析 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1983 【创建时间】：2008-10-28 【作者】：zhwayne 【评论】：1 【内容】：发信人: zhwayne (d-will), 信区: Embedded_System
标  题: 【网文】uboot1.1.6源码浅析
发信站: 北邮人论坛 (Tue Oct 28 22:00:36 2008), 站内

http://haoyeren.blog.sohu.com/entry/6271645/
关于uboot部分源码分析，主要是针对makfile等编译文件的分析,讲得比较细,也很明白
对上次小组学习巩固和补充一下

--
踏踏实实 坚强 果断 勇敢

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.150.*]
 
【文章标题】：下载文件到flash，只能用仿真器吗？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2012 【创建时间】：2008-10-29 【作者】：staywithyou 【评论】：3 【内容】：发信人: staywithyou (太阳月亮), 信区: Embedded_System
标  题: 下载文件到flash，只能用仿真器吗？
发信站: 北邮人论坛 (Wed Oct 29 12:36:52 2008), 站内

rt
貌似现在公司做的板子，直接用串口控制，通过以太网口下载到flash就行了。。。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.254.28.*]
 
【文章标题】：谁搭建好了EVC啊，为什么我搭建好之后总是用不了啊！！ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1934 【创建时间】：2008-10-27 【作者】：lichehuo 【评论】：7 【内容】：发信人: lichehuo (忧郁门门主), 信区: Embedded_System
标  题: 谁搭建好了EVC啊，为什么我搭建好之后总是用不了啊！！
发信站: 北邮人论坛 (Mon Oct 27 20:53:26 2008), 站内

如题，看见同是北邮人的面子上帮帮我吧。雪地裸跪恳请高手指点。希望高手能将详细步骤告诉于我。我按照网上的步骤，先安装EVC，再安装SP，那些SDK我没安装，因为我电脑上有VS+SDK的环境。但是我用安装好的EVC去打开网上的工程总是说找不到afxer.h这个头文件。按照网上的解决办法还是不能解决。我哭啊。大侠们救命啊。<img src="/img/ubb/em/9.gif" alt="em9" style="display:inline;border-style:none">
--
只有看看那美丽的晚霞，我才能坚持向西走下去-------悟空！

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.156.*]
 
【文章标题】：有人用过zigbee么？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1792 【创建时间】：2008-10-24 【作者】：jugovic3 【评论】：11 【内容】：发信人: jugovic3 (jugovic3), 信区: Embedded_System
标  题: 有人用过zigbee么？
发信站: 北邮人论坛 (Fri Oct 24 16:24:44 2008), 站内

我现在的zigbee模块编译器可能有问题。打算换一个，有知道哪个公司出的比较好么？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.200.244.*]
 
【文章标题】：编译模块遇到点问题,帮忙看一下啊 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1977 【创建时间】：2008-10-28 【作者】：lester98 【评论】：12 【内容】：发信人: lester98 (奶瓶|单车旋风族之太阳风), 信区: Embedded_System
标  题: 编译模块遇到点问题,帮忙看一下啊
发信站: 北邮人论坛 (Tue Oct 28 21:12:01 2008), 站内

内核2.6.24

错误一: error: `gpio_devices_queue' undeclared (first use in this function)

可是我明明在前面定义了:
static DECLARE_WAIT_QUEUE_HEAD(gpio_devices_queue);
甚至把这个宏的定义也拷贝过来还是不行:
static wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name);

原来遇到过这个问题,忘了怎么解决的了,真晕

警告二: warning: `restore_flags' is deprecated (declared at include/linux/interrupt.h:233)
网上搜到类似错误在编译内核时出现很多,但是没有人能说明白是怎么回事

代码很普通
 unsigned long flags;
        save_flags(flags);
..............
            restore_flags(flags);


--
希望将来能用这句话做签名
I graduated from this school ,and survive

※ 修改:·lester98 于 Oct 28 21:15:16 修改本文·[FROM: 221.221.161.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.161.*]
 
【文章标题】：[建议][转帖]ARM开发系统选择 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2044 【创建时间】：2008-10-29 【作者】：staywithyou 【评论】：6 【内容】：发信人: staywithyou (太阳月亮), 信区: Embedded_System
标  题: [建议][转帖]ARM开发系统选择
发信站: 北邮人论坛 (Wed Oct 29 22:52:58 2008), 站内

很多ARM初学者都希望有一套自己能用的系统，但他们住住会产生一种错误认识就是认为处理器版本越高、性能越高越好，就象很多人认为ARM9与ARM7好，我想对于初学者在此方面以此入门还应该理智，开发系统的选择最终要看自己往嵌入式系统的那个方向上走，是做驱动开发还是应用，还是做嵌入式系统硬件层设计与板级测试。如果想从操作系统层面或应用层面上走，不管是驱动还是应用，那当然处理器性能越高越好了，但这个东西自学，有十分大的困难，不是几个月或半年或是一年二年能搞定的事。 
　在某种意义上请，ARM7与9的差别就是在某些功能指令集上丰富了些，主频提高一些而已，就比如286和386。对于用户来讲可能觉查不到什么，只能是感觉速度有些快而已。 
　　ARM7比较适合于那些想从硬件层面上走的人，因为ARM7系列处理器内部带MMU的很少，而且比较好控制，就比如S3C44B0来讲，可以很容易将Cache关了，而且内部接口寄存器很容易看明白，各种接口对于用硬件程序控制或AXD单步命令行指令都可以控制起来，基于51单片机的思想很容易能把他搞懂，就当成个32位的单片机，从而消除很多51工程师想转为嵌入式系统硬件ARM开发工程师的困惑，从而不会被业界某此不是真正懂嵌入式烂公司带到操作系统层面上去，让他们望而失畏，让业界更加缺少这方面的人才。 
而嵌入式系统不管硬件设计还是软件驱动方面都是十分注重接口这部分的，选择平台还要考察一个处理器的外部资源，你接触外部资源越多，越熟悉他们那你以后就业成功的机率就越高，这就是招聘时所说的有无“相关技能”，因为一个人不可能在短短几年内把所有的处理器都接触一遍，而招聘单位所用的处理器就可能是我们完全没有见过的，就拿台湾数十家小公司（市价几千万）的公司生产的ARM类处理器，也很好用，但这些东西通用性太差，用这些处理器的公司就只能招有相关工作经验的人了，那什么是相关工作经验，在硬件上讲的是外围接口设计，在软件上讲是操作系统方面相关接口驱动及应用开发经验。我从业近十年，2000年ARM出现，我一天始做ARM7,然后直接跑到了Xscale（这个板本在ARM10-11之间），一做就是五年，招人面试都不下数百人，在这些方面还是深有体会的。 
　　 
我个人认为三星的S3C44b0对初学者来说比较合适，为什么这么说哪？因为接口资源比较丰富，技术成熟，资料较多，应该十分适合于初学者，有问题可能很容易找人帮且解决，因为大多数人都很熟悉，就如同51类的单片机，有N多位专家级的人物可以给你帮忙，相关问题得以很快解答，所然业界认为这款ARM都做用得烂了，但对于初学者来，就却是件好事。 
因此开发系统的选择，要看自己的未来从来目标方向、要看开发板接口资源、还要看业界的通用性。

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 222.130.208.*]
 
【文章标题】：那编程器又是啥玩意。。。。。。。。。。。。。。。 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2031 【创建时间】：2008-10-29 【作者】：staywithyou 【评论】：4 【内容】：发信人: staywithyou (太阳月亮), 信区: Embedded_System
标  题: 那编程器又是啥玩意。。。。。。。。。。。。。。。
发信站: 北邮人论坛 (Wed Oct 29 17:53:25 2008), 站内

rt
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.254.28.*]
 
【文章标题】：大家都专攻啥OS？linux or VxWorks or WinCE or Win Mobil or Q 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2024 【创建时间】：2008-10-29 【作者】：staywithyou 【评论】：7 【内容】：发信人: staywithyou (太阳月亮), 信区: Embedded_System
标  题: 大家都专攻啥OS？linux or VxWorks or WinCE or Win Mobil or QNX or ucOS or Nuclues???
发信站: 北邮人论坛 (Wed Oct 29 17:17:30 2008), 站内

rt
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.254.28.*]
 
【文章标题】：请教，我insmod模块，报错？？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2041 【创建时间】：2008-10-29 【作者】：g84ch 【评论】：8 【内容】：发信人: g84ch (大当家), 信区: Embedded_System
标  题: 请教，我insmod模块，报错？？
发信站: 北邮人论坛 (Wed Oct 29 21:58:02 2008), 站内

No module found in object
insmod:cannot insert 'sim.o':Invalid module format (-1):Exec format error

这是什么原因啊？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.157.*]
 
【文章标题】：嵌入式软件技术的现状与发展动向 【文章地址】：https://bbs.byr.cn/article/Embedded_System/524 【创建时间】：2008-06-03 【作者】：tjfmail 【评论】：0 【内容】：发信人: tjfmail (PE_passion &amp; energy), 信区: Embedded_System
标  题: 嵌入式软件技术的现状与发展动向
发信站: 北邮人论坛 (Tue Jun  3 14:30:57 2008), 站内

嵌入式软件技术的现状与发展动向

    嵌入式系统是计算机的一种应用形式，通常指埋藏在宿主设备中的微处理机系统，此类计算机一般不被设备使用者在意，亦称埋藏式计算机，典型机种如微控制器、微处理器和DSP等。 
    <b>一、标志性的嵌入式产品已露头角。</b>
    计算机应用的普及、互联网技术的实用以及纳米微电子技术的突破，正有力推动着21世纪工业生产、商业活动、科学实验和家庭生活等领域自动化和信息化进程。全过程自动化产品制造、大范围电子商务活动、高度协同科学实验以及现代化家庭起居，为嵌入式产品造就了崭新而巨大的商机。除了沟通信息高速公路的交换机、路由器和Modem，构建CIMS所需的DCS和机器人以及规模较大的家用汽车电子系统。最有量产效益和时代特征的嵌入式产品应数因特网上的信息家电(Internet 
    Appliances),如Web可视电话、Web游戏机、Web 
    PDA(俗称电子商务、商务通)、WAP电话手机、以及多媒体产品，如STB(电视机顶盒)、DVD播放机、电子阅读机。
   <b> 二、嵌入式软件技术面临挑战</b>
    以信息家电为代表的互联网时代嵌入式产品，不仅为嵌入式市场展现了美好前景，注入了新的生命；同时也对嵌入式系统技术，特别是软件技术提出新的挑战。这主要包括：支持日趋增长的功能密度、灵活的网络联接、轻便的移动应用和多媒体的信息处理，此外，当然还需对付更加激烈的市场竞争。
    1.入式应用软件的开发需要强大的开发工具和操作系统的支持
    随着因特网技术的成熟、带宽的提高，ICP和ASP在网上提供的信息内容日趋丰富、应用项目多种多样。像电话手机、电话座机及电冰箱、微波炉等嵌入式电子设备的功能不再单一，电气结构也更为复杂。为了满足应用功能的升级，设计师们一方面采用更强大的嵌入式处理器如32位、64位RISC芯片或信号处理器DSP增强处理能力；同时还采用实时多任务编程技术和交叉开发工具技术来控制功能复杂性，简化应用程序设计、保障软件质量和缩短开发周期。 

    目前，国外商品化的嵌入式实时操作系统，已进入我国市场的，如WindRiver,、Microsoft、QNX和Nuclear等产品。我国自主开发的嵌入式系统软件产品如科银(CoreTek)公司的嵌入式软件开发平台DeltaSystem,它不仅包括DeltaCore嵌入式实时操作系统,而且还包括LamdaTools交叉开发工具套件,测试工具,应用组件等；此外，中科院也推出了Hopen嵌入式操作系统。
    2.网络成为必然趋势
    为适应嵌入式分布处理结构和应用上网需求，面向21世纪的嵌入式系统要求配备标准的一种或多种网络通信接口。针对外部联网要求，嵌入设备必需配有通信接口,相应需要TCP／IP协议簇软件支持；由于家用电器相互关联(如防盗报警，灯光能源控制，影视设备和信息终端交换信息)及实验现场仪器的协调工作等要求，新一代嵌入式设备还需具备IEEE1394、USB、CAN、Bluetooth或IrDA通信接口，同时也需要提供相应的通信组网协议软件和物理层驱动软件。为了支持应用软件的特定编程模式，如Web或无线Web编程模式，还需要相应的浏览器，如HTML、WML等。
    3.支持小型电子设备实现小尺寸、微功耗和低成本
    为满足这种特性，要求嵌入式产品设计者相应降低处理器的性能，限制内存容量和复用接口芯片。这就相应提高了对嵌入式软件设计技术要求。如，选用最佳的编程模型和不断改进算法，采用Java编程模式，优化编译器性能。因此既要软件人员有丰富经验，更需要发展先进嵌入式软件技术，如Java、Web和WAP等。
    4.提供精巧的多媒体人机界面
    嵌入式设备之所以为亿万用户乐于接受，重要因素之一是它们与使用者之间的亲和力，自然的人机交互界面，如司机操纵高度自动化的汽车主要还是通过习惯的方向盘、脚踏板和操纵杆。人们与信息终端交互要求以GUI屏幕为中心的多媒体界面。手写文字输入、语音拨号上网，收发电子邮件以及彩色图形、图像已取得初步成效。目前一些先进的PDA在显示屏幕上已实现汉字写入，短消息语音发布，但离掌式语言同声翻译还有很大距离。
  <b>  三、影响未来的若干软件新技术</b>
    如前所述，嵌入式系统设计师们已利用现行嵌入式软件技术和PC机积累技术迎接新一代嵌入式应用；同时，发展影响深远的若干新的软件技术。这些技术包括：行业性编程编口API规范，无线网络操作系统、IP构件库和嵌入式JAVA等。
    1.日趋流行的行业性开放系统和备受青睐的自由软件技术
    为了对付日趋激烈的国际市场竞争势态，设计技术共享和软件重用、构件兼容、维护方便和合作生产是增强行业性产品竞争能力的有效手段。近几年，一些地区和国家的若干行业协会纷纷制定嵌入式产品标准，特别是软件编程接口API规范。如，欧共体汽车产业联盟规定以OSEK标准作为开发汽车嵌入式系统的公用平台和应用编程接口(OSEK的名称来自于德文"车内电子设备的开放系统的接口)。OSEK规定了汽车控制器的通信规程、网络管理规则以及高效利用存贮器的嵌入式操作系统。虽然业界专家怀疑OSEK标准是否能马上投入使用，而WindRiver等嵌入式软件公司已宣布推出兼容的操作系统，MotoWorks，充分利用行业软件技术开放带来的大笔商业利益。我国数字产业联盟，也在制定本行业的开放式软件标准，提高中国数字产品的竞争能力。看来，走行业开放系统道路是加快嵌入式软件技术发展的捷径之一。 
    此外，值得指出，国际上自由软件运动的顺利发展，GPL概念正对嵌入式软件产业深远影响。嵌入式Linux多种原型的提出，和GNU软件开发工具软件的实用化进展，正为我国加快发展嵌入式软件技术提供了极好机遇和条件。
    2.无线网络操作系统初见端倪
    未来移动通信网络不仅能够提供丰富的多媒体数据业务，而且能够支持更多功能和更强的移终端设备。为了有效地发挥第三代移动通信系统的优势，许多设备厂商针对未来移动设备的特点努力开发无线网络操作系统。EPOC就是一例。
    3.IP构件库技术正在造就一个新兴的软件行业
    嵌入式系统实现的最高形式是单一芯片系统(SOC，System On 
    Chip)，而SOC的核技术是IP核(即知识产权核Intellectual Property 
    Kernels)构件。IP核有硬件核、软件核和固件核，硬件核主要指8/16/32/64位MPU核或DSP核。硬件提供商以数据软件库的形式，将其久经验证的处理器逻辑和芯片版图数据，供EDA工具调用在芯片上直接配置MPU/DSP功能单元；而软件核则是软件提供商将SOC所需的RTOS内核软件或其它功能软件，如通信协议软件，FAX功能软件等构件标准API方式和IP核构件形式供IDE和EDA工具调用制成FLASH或ROM可执行代码单元，加速SOC嵌入式系统定制或开发。目前一些嵌入式软件供应商纷纷把成熟的RTOS内核和功能扩展件，以软件IP核构件形式出售，如Microtec的VRTXoc 
    for ARM就是典型例子。正在兴启的IP构件软件技术正为一大批高智小型软件公司提供发展机遇。
    4.J2ME技术将对嵌入式软件的发展产生深远影响
    众所周知"一次编程，到处使用"JAVA软件概念原本就是针对网上嵌入式小设备提出的。几经周折，目前SUN公司已推出了J2ME(JAVA 2 Platform Micro Edition)针对信息家电的JAVA版本，其技术日趋成熟，开始投入使用。SUN公司JAVA虚拟机(JVM)技术的有序开放，使得JAVA软件真正实现跨平台运行，即JAVA应用小程序能够在带有JVM的任何硬软件系统上执行。这对实现瘦身上网的信息家电等网络设备十分有利。这一技术动向势必对嵌入式设备特别是上网设备软件编程技术产生重大影响，更值得业界人事关注。
    总结
    由于诸多原因，我国计算机行业未能赶上世界范围软件技术发展的前几次机遇；当我们意识到应组织发展本国软件产业时，微软已在PC软件上处世界垄断地位，我们只得在软件汉化小范围徘徊，对计算机系统软件虽偶有出击，总难冲出重围。二十一世纪之初，微软王国已从登峰造极走向地位下滑的后PC时代。后PC时代，既非PC信息设备大显神通的时代，嵌入式系统正是非PC设备的主体，由于其应用推广、领域特色突出，谁也无力独吞这一市场。互联网技术在世界范围的扩展和中国通信事业的高速发展，已为我国开发嵌入式产品造就了广大市场，此外我国是人口大国，素有软件智力优势。因此，我国软件同仁应该牢牢抓着这一大好机遇，找准出击点，在IP软件、JAVA应用和无线网络等新一轮嵌入式软件技术上，下大力，冲刺一翻，定能使我国软件技术大上一个台阶，对发展我国经济做出应有贡献。 


--

莫听穿林打叶声,何妨吟啸且徐行;
竹杖芒鞋轻胜马,谁怕!一蓑烟雨任平生


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.186.*]
 【文章标题】：建议版上使用ubuntu做嵌入式开发 【文章地址】：https://bbs.byr.cn/article/Embedded_System/509 【创建时间】：2008-06-02 【作者】：fzylijun886 【评论】：6 【内容】：发信人: fzylijun886 (北邮人), 信区: Embedded_System
标  题: 建议版上使用ubuntu做嵌入式开发
发信站: 北邮人论坛 (Mon Jun  2 01:07:46 2008), 站内

大家统一一下，有助于互相帮助：）
ps：用过ubuntu的人肯定知道，有很多爽的地方
--
少说话，多做事！

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.66.123.*]
 
【文章标题】：两个著名的嵌入式Linux博客 【文章地址】：https://bbs.byr.cn/article/Embedded_System/536 【创建时间】：2008-06-04 【作者】：myibm 【评论】：0 【内容】：发信人: myibm (SUN), 信区: Embedded_System
标  题: 两个著名的嵌入式Linux博客
发信站: 北邮人论坛 (Wed Jun  4 11:07:10 2008), 站内

陈俊宏：<a target="_blank" href="http://www.jollen.org/blog">http://www.jollen.org/blog</a>
黄敬群：<a target="_blank" href="http://blog.linux.org.tw/~jserv">http://blog.linux.org.tw/~jserv</a>

两个都是台湾网站，访问需要代理，enjoy yourself!
--

<a target="_blank" href="http://www.jollen.org/blog">http://www.jollen.org/blog</a><a target="_blank" href="http://blog.linux.org.tw/~jserv">http://blog.linux.org.tw/~jserv</a>
※ 修改:·myibm 于 Jun  4 11:31:40 修改本文·[FROM: 219.235.232.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.235.232.*]
 

【文章标题】：【原创】从segment fault得到更多信息 【文章地址】：https://bbs.byr.cn/article/Embedded_System/522 【创建时间】：2008-06-02 【作者】：DusTin 【评论】：0 【内容】：发信人: DusTin (老了), 信区: Embedded_System
标  题: 【原创】从segment fault得到更多信息
发信站: 北邮人论坛 (Mon Jun  2 20:50:41 2008), 站内

在我刚刚开始接触linux编程的时候认为segment fault简直就是灾难。。。为了检查错误原因要一步步排查，费时费力
其实在产生segment fault的时候，kernel把能提供给我们的信息都提供给我们了，而我们所要做的就是得到这些信息。
如果能在产生segment fault的时候得到寄存器的值，特别是PC的值就可以马上利用objdump反汇编锁定错误代码，为bug fix提供了方便。其实在产生错误的时候，kernel已经把寄存器的值保存好了，并留好接口让你去拿，拿不拿就看你了，呵呵

产生segment fault的时候，会产生一个SIGSEGV信号，我们所要做的就是在应用程序捕捉这个信号。
struct sigaction s;
s.sa_flags = SA_SIGINFO;
s.sa_sigaction = (void *) myhandler;
if (sigaction(SIGSEGV, &amp;s, (struct sigaction *) NULL)) {
    printf("Sigaction returned error = %d\n", errno);
    exit(0);
}

当捕获到这个信号之后就回去调用myhandler这个程序
static void myhandler(unsigned int sn, siginfo_t * si, struct ucontext *sc)
我们希望得到的信息就存放在这几个参数里面
sn为捕获的信号既SIGSEGV
以arm为例看一下后两个参数
typedef struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;

    union {
        int _pad[SI_PAD_SIZE];

        /* kill() */
        struct {
            pid_t _pid;        /* sender's pid */
            uid_t _uid;        /* sender's uid */
        } _kill;

        /* POSIX.1b timers */
        struct {
            unsigned int _timer1;
            unsigned int _timer2;
        } _timer;

        /* POSIX.1b signals */
        struct {
            pid_t _pid;        /* sender's pid */
            uid_t _uid;        /* sender's uid */
            sigval_t _sigval;
        } _rt;

        /* SIGCHLD */
        struct {
            pid_t _pid;        /* which child */
            uid_t _uid;        /* sender's uid */
            int _status;        /* exit code */
            clock_t _utime;
            clock_t _stime;
        } _sigchld;

        /* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
        struct {
            void *_addr; /* faulting insn/memory ref. */
        } _sigfault;

        /* SIGPOLL */
        struct {
            int _band;    /* POLL_IN, POLL_OUT, POLL_MSG */
            int _fd;
        } _sigpoll;
    } _sifields;
} siginfo_t;

struct sigcontext {
    unsigned long trap_no;
    unsigned long error_code;
    unsigned long oldmask;
    unsigned long arm_r0;
    unsigned long arm_r1;
    unsigned long arm_r2;
    unsigned long arm_r3;
    unsigned long arm_r4;
    unsigned long arm_r5;
    unsigned long arm_r6;
    unsigned long arm_r7;
    unsigned long arm_r8;
    unsigned long arm_r9;
    unsigned long arm_r10;
    unsigned long arm_fp;
    unsigned long arm_ip;
    unsigned long arm_sp;
    unsigned long arm_lr;
    unsigned long arm_pc;
    unsigned long arm_cpsr;
    unsigned long fault_address;
};

我就不分析这两个结构了，我们想要的东西都在里面了 自己去取吧 呵呵

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.134.*]
 
【文章标题】：IT人 必看 【文章地址】：https://bbs.byr.cn/article/Embedded_System/14340 【创建时间】：2014-01-07 【作者】：yyiyy99999 【评论】：1 【内容】：发信人: yyiyy99999 (VIvi), 信区: Embedded_System
标  题: IT人 必看
发信站: 北邮人论坛 (Tue Jan  7 16:05:44 2014), 站内

首个自动 回复 和查询职位的 IT 咨询平台.
回复 C   JAVA  云   QA 等 可 查询 各IT职位信息.

微信公共平台账号：ITnewmsg
每日 IT业内动态资讯
上班路上, 午餐后,傍晚闲暇.
让我们乐在其中：
IT人的亲身经历     （真人真事 ,讲述着 那些年我们拒过的offer）
IT行业公司发展      (动荡频频，该何去何从,未卜先知 看清脚下的路）
IT职位发布             （一线城市, 名企外企, 一跃而上 想占先机）
资源选取             （各大门户网站，专业论坛）    
乐在其中                 （欢迎IT 大牛 小牛 投稿讲述 自己的看法与经历，我们有专门的栏位）

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 114.240.103.*]
 
【文章标题】：[合集] skyeye简介 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3270 【创建时间】：2008-12-20 【作者】：lester98 【评论】：0 【内容】：发信人: lester98 (奶瓶|单车旋风族之太阳风), 信区: Embedded_System
标  题: [合集] skyeye简介
发信站: 北邮人论坛 (Sat Dec 20 23:24:12 2008), 站内

☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Sun May 11 08:22:51 2008)  提到:

SkyEye是一个开源软件(OpenSource Software)项目，中文名字是“天目”。SkyEye的目标是在通用的Linux和 Windows平台实现一个纯软件模拟集成开发环境，模拟常见的嵌入式计算机系统(这里我们假定“仿真”和“模拟”的意思基本相同)；可在SkyEye上运行Linux、uClinux以及uC/OS-II等多种嵌入式操作系统和各种系统软件（如TCP/IP，图形子系统，文件子系统等），并可对它们进行源码级的分析和测试。

SkyEye是一个指令级模拟器，可以模拟多种嵌入式开发板，可支持多种CPU指令集，在SkyEye上运行的操作系统意识不到它是在一个虚拟的环境中运行，而且开发人员可以通过SkyEye调试操作系统和系统软件。由于SkyEye的目标不是验证硬件逻辑，而是协助开发、调试和学习系统软件，所以在实现上SkyEye与真实的硬件环境相比还是有一定差别的。SkyEye在时钟节拍的时序上不保证与硬件完全相同，对软件透明的一些硬件模拟进行了一定的简化,这样带来的好处是SkyEye的执行效率更高。

在32位嵌入式CPU领域中，ARM系列CPU所占比重相当大，因此SkyEye首先选择了ARM CPU核作为模拟目标CPU核。目前在SkyEye上可运行并进行源码级调试Linux、uClinux、uC/OS-II操作系统和LwIP(一个著名的嵌入式TCP/IP实现)等系统软件。SkyEye可用于学习，分析，开发Linux、uclinux、uC/OS-II操作系统内核和TCP/IP实现，了解ARM嵌入式CPU编程。

SkyEye发展方向

skyEye将支持模拟更多的CPU、开发板和各种外设，提供详细的设计文档，已方便其它开发人员开发各种各样的硬件模拟。除了对SkyEye进一步完善以外，目前我们正在进行的工作是LCD模拟。

对于skyeye开发感兴趣的朋友,可直接与我联系yuchen@ATtsinghua.edu.cn

并看看skyeye的内部实现文档<a target="_blank" href="ftp://166.111.68.183/pub/embed/skye...ternal-v0.7.pdf">ftp://166.111.68.183/pub/embed/skye...ternal-v0.7.pdf</a>

目前SkyEye还在发展当中，还有许多不完善的地方，需要大家的支持！
 SkyEye配置选项

了解SkyEye配置选项，对理解skyeye模拟的硬件和在上skyeye上运行操作系统有帮助。SkyEye仿真的硬件配置和模拟执行行为由配置文件skyeye.conf中的选项确定。根据选项的功能，skyeye.conf的选项分为硬件配置选项和模拟执行选项。

目前skyeye.conf的配置定义如下：

一、基本CPU核配置选项

目前存在的选项有：arm7tdmi、arm720t、strongarm、xscale

格式为：

cpu: cpuname

注：cpuname表示一个代表cpu名字的字符串。

例如：
cpu: arm7tdmi

二、具体的开发板(包括CPU扩展)配置选项

目前存在的选项有：at91、ep7312、adsbitsy、pxa_lubbock

格式为：

mach: machinename

注：cpuname表示一个代表基于特定CPU的开发板名字的字符串。

例如：
mach: at91

三、内存组配置选项

一个内存组内的地址是连续的，类型分为RAM space, ROM space, mapped IO space

格式为：

mem_bank: map=M|I, type=RW|R, addr=0xXXXXXXXX, size=0xXXXXXXXX, file=imagefilename, boot=yes|no

map=M 表示 RAM/ROM space, map=I 表示 mapped IO space,
type=RW，且如果 map=M 则表示 RAM space, type=R，且如果map=M则表示ROM space
addr=0xXXXXXX 表示内存组的起始物理地址(32bit，16进制)
size=0xXXXXXX 表示内存组的大小(32bit，16进制)
file=imagefilename file的值imagefilename是一个字符串，实际上表示了一个文件，一般是一个可以执行的binary image格式的可执行程序或OS内核文件或则是一个binary image格式的根文件系统。如果存在这个文件，SkyEye会把文件的内容直接写到对应的仿真内存组地址空间中
boot=yes/no，如果boot=yes，则SkyEye会把仿真硬件启动后的第一条指令的地址定位到对应的内存组的起始地址。

四、网络芯片8019as的配置

格式为 nic info state=on/off mac=xx:xx:xx:xx:xx:xx ethmod=tuntap/vnet hostip=dd.dd.dd.dd

注：xx表示两位16进制数，dd表示两位10进制数
state表示仿真开始后,网络芯片是否开始工作
mac表示模拟的nic的mac地址
ethmod表示skyeye所处主机上的网络仿真方式, 目前有tuptap和vnet两种模式。tuntap是linux kernel
支持的一个点到点虚拟网络实现，vnet是skyeye实现的一个功能更多的一个基于虚拟HUB的网络。
hostip表示主机方与skyeye交互用的ip地址

例如：
net: state=on, mac=0:4:3:2:1:f, ethmod=tuntap, hostip=10.0.0.1

五、skyeye的UART控制选项

uart选项可以控制skyeye在另一个与某个串口连接的终端上输入/输出字符

格式：

uart: fd_in=indevname, fd_out=outdevname

fd_in=indevname indevname表示用于输入的设备文件名，其值为实际的串口设备文件/dev/ttySx
fd_out=outdevname outdevname表示用于输出的设备文件名，其值为实际的串口设备文件/dev/ttySx

例如：
uart: fd_in=/dev/ttyS0, fd_out=/dev/ttyS0

六、skyeye的log控制选项

log选项用于控制skyeye输出硬件系统的执行状态信息，包括每次执行指令时的执行指令值、寄存器值、各种硬件状态等。

格式：

log: logon=0|1, logfile=filename, start=number1, end=number2

logon=0|1，如果值等于0表示不进行记录，如果值等于1表示要进行记录
logfile=filename 其值是一个字符串，表示用于记录信息的文件名
start=number1 其值是一个&gt;=0的十进制整数，表示系统执行执行到第number条指令时开始进行记录
end =number 2其值是一个&gt;=0的十进制整数，表示系统执行执行到第number条指令时停止记录

例如：
log: logon=0, logfile=/tmp/sk1.log, start=100000, end=200000



☆─────────────────────────────────────☆
   fzylijun886 (北邮人) 于  (Sun May 11 08:25:06 2008)  提到:

注意: 以下说明是针对SkyEye 0.1.1以前版本, ucosii4skyeye1.4以前版本，最新软件的安装使用说明可参考最新软件包中的相关文件（installguide.txt, readme, SkyEye.README）

一 在windows环境下安装SkyEye1.      安装 cygwin
  Cygwin是一个在windows(包括windows98/windows2000/windowsXP)下的unix 工具集合，支持大多数GNU软件（如gcc，gdb，xfree86,bash,tetex，opengl，perl,python等）。许多以前在unix环境下的软件只需在cygwin环境下重新编译就可以运行了。SkyEye也是通过cygwin的支持实现了可同时在windows和linux上运行。

  目前最新的Cygwin版本为1.3.17(2002-11-28)，整个环境（包括所有的工具和xfree86有1.3GB）。大家可下载和安装最基本的环境，大约为200~400MB不等。目前国内提供下载的地址有：

ftp://202.38.97.230/netinst/Cygwin/

ftp://166.111.68.183/pub/Cygwin/

必须安装的子目录（sub category）: （把子目录旁边的”default”用鼠标点一下，直到变成”install”）

Archive

Base

Devel：包括gcc、make等编译工具

Libs

Net

Shells

Utils: 包括bzip2等实用工具

 

大家可选择较快的下载地址（希望更多的站点提供最新cygwin的ftp访问）。

必须通过cygwin提供的setup.exe进行安装，可根据安装提示一步一步进行，提供通过internet安装方式或本地安装方式。建议把cygwin整个安装包下载到本地再进行本地安装比较方便。如果无特殊需求，可简单按它的缺省安装方式安装最少数量的软件包。建议不要安装到c:\下。cygwin的问题和解答可参考cygwin FAQ。

2.      安装skyeye
1.       在cygwin环境下安装二进制skyeye

把二进制文件从linux或cygwin的根目录下解开既可使用。如果你选择把cygwin安装到的d:\cygwin目录下。则执行cygwin bash shell后的仿unix环境的根目录“/”实际上就是d:\cygwin目录。

把SkyEye-0.1 for cygwin二进制文件skyeye-0.1.bin.cygwin.1.3.17.tar.bz2下载并拷贝到d:\cygwin目录下后，在cygwin bash shell环境中的根目录“/”下就存在了文件skyeye-0.1.bin.cygwin.1.3.17.tar.bz2。然后在cygwin bash shell环境中的的根目录“/”下执行：

tar jxvf skyeye-0.1.bin.cygwin.1.3.17.tar.bz2

就把skyeye的执行文件安装到cygwin bash shell环境中“/usr/local/bin”下。

用户可试着在根目录下执行命令“skyeye”，如果出现了如下显示则表示安装成功。

2. 在cygwin环境下编译skyeye

如果自己想在cygwin环境下编译skyeye，则比较麻烦，可参考skyeye源码包中的说明文档buildskyeyeoncygwin.txt

3.      建立源码调试环境
A 建立uC/OS-II源码调试环境

注意：如果要重新编译，请选择ucosii for skyeye 1.0.1以上版本！

假设要把uC/OS-II源码调试环境建立在“/tmp/ucos/sourcecode”目录下。

把uC/OS-II for SkyEye VerA 源码 ucosii-verA-skyeye-1.0.tar.bz2或 uC/OS-II for SkyEye VerB源码 ucosii-verA-skyeye-1.0.tar.bz2解压到/tmp/ucos下：

以uC/OS-II for SkyEye VerA为例：

把ucosii-verA-skyeye-1.0.tar.bz2下载并拷贝到d:\cygwin\tmp目录下，则执行cygwin bash shell后的仿unix环境的根目录“/tmp”实际上就是d:\cygwin\tmp目录。

然后在cygwin bash shell环境下执行如下命令：

mkdir /tmp/ucos

cd /tmp/ucos

tar jxvf ../ucosii-verA-skyeye-1.0.tar.bz2

 

然后把uC/OS-II for SkyEye VerA执行文件 ucosii-verA.elf拷贝到d:\cygwin\tmp\ucos\sourcecode下

最后把uC/OS-II内存布局配置文件拷贝到d:\cygwin\tmp\ucos\sourcecode下，并在cgywin环境下执行改名命令：

cd /tmp/ucos/sourcecode/

mv ucosmemmap.conf memmap.conf

 

B 建立uclinux源码调试环境

假设要把uclinux源码调试环境建立在“/tmp/uclinux/uClinux-dist-20020816”目录下。

把uclinux-2.4.x精简压缩包uclinux.lightsrc.tar.bz2下载并拷贝到d:\cygwin\tmp目录，即cygwin环境的目录”/tmp”

  解压uclinux-2.4.x精简压缩包，命令如下：

cd /tmp

tar jxvf uclinux.lightsrc.tar.bz2

  则uclinux相关文件就安装到“/tmp/uclinux/uClinux-dist-20020816”目录下了。

  最后把 uclinux内存布局配置文件 uclinuxmemmap.conf拷贝到d:\cygwin\tmp\uclinux\uClinux-dist-20020816下，并在cgywin环境下执行改名命令：

  cd /tmp/uclinux/uClinux-dist-20020816/

  mv uclinuxmemmap.conf memmap.conf

  

  如果 你想把uclinux-2.4.x精简压缩包解压到/usr/local/目录下，

则把uclinux-2.4.x精简压缩包uclinux.lightsrc.tar.bz2下载并拷贝到d:\cygwin\usr\local目录，即cygwin环境的目录”/usr/local”

解压uclinux-2.4.x精简压缩包，命令如下：

cd /usr/local

tar jxvf uclinux.lightsrc.tar.bz2

  ln –s /usr/local/uclinux /tmp/uclinux

  注意：/tmp/uclinux是uclinux-2.4.x精简压缩包的缺省安装目录。

   

4.      执行调试程序
 A  调试ucos

 在cygwin环境下执行如下操作：

cd /tmp/ucos/sourcecode

skyeye

在skyeye环境中执行:

file ucosii-verA.elf   （如果建立的是ucosii-verB环境，则执行file ucosii-verB.elf）

target sim

load

run

 

然后你可以用”Ctrl-C”中断ucos的执行，通过命令

p x

p y

可以查看task1对x的修改情况，和task2对y的修改情况，

通过命令

p OSCtxSwCtr

可以查看ucos执行上下文切换的次数。

 

B 调试 uclinux

在cygwin环境下执行如下操作：

cd /tmp/uclinux/uClinux-dist-20020816

skyeye

在skyeye环境中执行:

file linux-2.4.x/linux

target sim

load

run

这时应该可以看到uclinux的启动画面。

 

如果需要进一步调试，需要学习gdb的命令使用。

 

5.      从源码生成ucosii的执行码
注意：

l       如果要重新编译，请选择ucosii for skyeye 1.0.1以上版本的源代码。

l       ucosii for skyeye 1.1以上版本支持printf功能，但目前不能在cygwin环境下编译通过，但可在linux环境下编译通过后，在cygwin环境下执行。

l       uC/OS-II的执行文件和源码要放在一个目录下。

l       memmap.conf所在目录和当前执行skyeye的目录要等同。

 

5.1 建立arm-tools in cygwin 环境
下载 arm-tools in cygwin的软件包

arm-linux-binutils-cygwin-2.9.5.0.37.tgz

      arm-linux-gcc-cygwin-2.95.3.tgz

libc6-arm-cross-2.1.3-19.tgz

      libc6-dev-arm-cross-2.1.3-19.tgz

 

如果你选择把cygwin安装到的d:\cygwin目录下。则执行cygwin bash shell后的仿unix环境的根目录“/”实际上就是d:\cygwin目录。把上软件包下载并拷贝到d:\cygwin目录下后，在cygwin bash shell环境中的根目录“/”下就存在上述文件。然后在cygwin bash shell环境中的的根目录“/”下执行：

tar zxvf arm-linux-binutils-cygwin-2.9.5.0.37.tgz

tar zxvf arm-linux-gcc-cygwin-2.95.3.tgz

tar zxvf libc6-arm-cross-2.1.3-19.tgz

tar zxvf libc6-dev-arm-cross-2.1.3-19.tgz

 

执行命令

tar jxvf ucos_verb_skyeye-1.x.x.src.bz2 

解开源码软件包

然后，你可在ucos的安装目录(设安装目录为”/tmp/ucos/sourcecode”)下执行命令：

make

则可在ucos的安装目录下生成ucos.elf       ucos.s      ucos.r      ucos.n

最后在ucos的安装目录下执行skyeye，就可以调试你编译的ucos.elf操作系统和应用程序了（与4中的描述相同）。

 

注意：ucosii for skyeye 1.1以上版本支持printf功能，但目前不能在cygwin环境下编译通过，但可在linux环境下编译通过后，在cygwin环境下执行。

 

目前提供的在cygwin环境下的支持arm的交叉编译工具集有两个。

另一个由别人制作的在cygwin环境下的支持arm的交叉编译工具集可在

ftp://166.111.68.183/pub/embed/devtool/gcc-arm-cygwin/

处下载，如果大家想在cygwin环境下重新编译uclinux，大家可以试用一下。

 

二  在linux环境下安装SkyEye懂linux还不懂如何安装吗？ J

注意：

/tmp/uclinux是uclinux-2.4.x精简压缩包的缺省安装目录

建议使用redhat7.1以上版本的系统。

建议使用arm-elf-tools-20011219.tar.gz为交叉编译工具编译arm程序

建议使用gcc2.96  gcc3.2 编译skyeye

 

1 在linux 下安装 skyeye，编译并运行 ucosii for skyeye
1 在linux 下安装skyeye

解开skyeye-0.1.1.src.tar.bz2，按照SkyEye.README介绍的步骤做configure,make,make install

需要指出的是，在mandrake8.2环境中,make 时会有error，不过不是什么大问题，

error:display.c-&gt;tcap.h-&gt;termcap.h:no such file or directory

在本机/usr/include下find一下，termcap.h头文件在/usr/include/ncurses目录下，

将termcap.h中的&lt;termcap.h&gt;改成&lt;ncurses/termcap.h&gt;

重新执行make就ok了。

执行make install命令后，skyeye默认安装在/usr/local/bin/目录下，你可以通过改configure命令参数prefix来改变安装路径。

 

2 安装arm交叉编译器 

下载arm-elf-tools-20011219.tar.gz

将arm-elf-tools-20011219.tar.gz在本机的根目录下用tar命令解开，

则相关软件安装在/usr/local/bin和/usr/local/arm-elf目录下。

3 编译 ucosii for skyeye

  下载ucosii for skyeye源代码

注意： 1.1以上版本支持printf功能

 

执行命令

tar jxvf ucos_verb_skyeye-1.x.x.src.bz2 

解开源码软件包

然后，你可在ucos的安装目录(设安装目录为”/tmp/ucos/sourcecode”)下执行命令：

make

则可在ucos的安装目录下生成ucos.elf       ucos.s      ucos.r      ucos.n

最后在ucos的安装目录下执行skyeye，就可以调试你编译的ucos.elf操作系统和应用程序了。

2 在mandrake linux8.2 下安装skyeye并运行uClinux-dist-20020927.tar.gz
感谢star提供的SkyEye在linux上的安装使用过程描述

 

 

运行环境：mandrake linux8.2

源码包及其他所需文件：<a target="_blank" href="ftp://202.99.11.120/pub/mirrors/skyeye/">ftp://202.99.11.120/pub/mirrors/skyeye/</a> 或 <a target="_blank" href="ftp://166.111.68.183/pub/embed/">ftp://166.111.68.183/pub/embed/</a>

skyeye-0.1.1.src.tar.bz2

arm-elf-tools-20011219.tar.gz

uClinux-dist-20020927.tar.gz

romfs.2.4.x.gz

uclinuxmemmap.conf

 

1 在linux 下安装skyeye

 

2编译uclinux

先安装交叉编译器，将arm-elf-tools-20011219.tar.gz在本机的根目录下tar开，解到/usr/local/arm-elf目录下。

将uClinux-dist-20020927.tar.gz解开，比如解开在/usr/src/uclinux-dist/下，然后在/usr/src/uclinux-dist/目录下执行如下命令：

在图形方式下可用命令 make xconfig 或 在命令行方式下可用命令 make menuconfig

在vendor/product中选择GDB/ARMulator，kernel版本选择2.4,save and exit.

------------------------------------------------------------------------------------------------------------------------------------------------

方案A

如果带调试信息的linux kernel执行文件

make dep;make linux

这时在/usr/src/uclinux-dist/linux-2.4.x目录下生成linux文件

方案B

如果想一步生成带调试信息的linux kernel执行文件和linux kenel 执行文件映像和磁盘映像文件romfs.img

可简单是运行命令 make dep; make 就行了。可查看/usr/src/uclinux-dist/images/下是否有文件 romfs.img等

-------------------------------------------------------------------------------------------------------------------------------------------------

在/usr/src/uclinux-dist目录下，

cp ulinuxmemmap.conf memmap.conf

------------------------------------------------------------------------------------------------------------------------------------------------

方案A

gunzip romfs.2.4.x.gz

cp romfs.2.4.x boot.rom

romfs.2.4.x其实就是磁盘映像文件。

方案B

也可以在/usr/src/uclinux-dist下make romfs ;make image来生成romfs.img。

如果想使用自己编译的romfs.img，则在目录/usr/src/uclinux-dist下执行命令

ln –s images/romfs.img boot.rom

-------------------------------------------------------------------------------------------------------------------------------------------------

这个时候就可以用skyeye来调试运行kernel了，在/usr/src/linux-dist：

skyeye linux-2.4.x/linux

(gdb)target sim

(gdb)load

(gdb)run

kernel start.....

注意要在 memmap.conf 和boot.rom所在目录下执行skyeye。

你可以在run之前给kernel设置断点来调试。目前skyeye支持的arm core基于arm7tdmi，没有mmu，所以只能跑ucos,uclinux，不过他们正在做更多的努力，相信很快skyeye也可以支持arm linux。




☆─────────────────────────────────────☆
   tjfmail (INTEL) 于  (Sun May 11 10:44:10 2008)  提到:

绝对精华贴


☆─────────────────────────────────────☆
   Winters101 (Winters) 于  (Sun May 11 11:20:02 2008)  提到:

太及时了！昨天还上网找呢。呵呵
【 在 fzylijun886 (北邮人) 的大作中提到: 】
: SkyEye是一个开源软件(OpenSource Software)项目，中文名字是“天目”。SkyEye的目标是在通用的Linux和 Windows平台实现一个纯软件模拟集成开发环境，模拟常见的嵌入式计算机系统(这里我们假定“仿真”和“模拟”的意思基本相同)；可在SkyEye上运行Linux、uClinux以及uC 
: SkyEye是一个指令级模拟器，可以模拟多种嵌入式开发板，可支持多种CPU指令集，在SkyEye上运行的操作系统意识不到它是在一个虚拟的环境中运行，而且开发人员可以通过SkyEye调试操作系统和系统软件。由于SkyEye的目标不是验证硬件逻辑，而是协助开发、调试和学习系统软件� 
: 在32位嵌入式CPU领域中，ARM系列CPU所占比重相当大，因此SkyEye首先选择了ARM CPU核作为模拟目标CPU核。目前在SkyEye上可运行并进行源码级调试Linux、uClinux、uC/OS-II操作系统和LwIP(一个著名的嵌入式TCP/IP实现)等系统软件。SkyEye可用于学习，分析，开发Linux、ucli 
: ................... 



☆─────────────────────────────────────☆
   doudou02 (豆豆) 于  (Wed Oct 15 19:36:13 2008)  提到:

zan 正想学习下skyeye呢


☆─────────────────────────────────────☆
   sweetfly (mession) 于  (Wed Oct 15 19:37:30 2008)  提到:

顶一个  


☆─────────────────────────────────────☆
   PANDAEMMA (熊猫米尼) 于  (Fri Oct 17 16:36:41 2008)  提到:

请问fzylijun886 ，你是skyeye小组的吗？



 【文章标题】：嵌入式学习的一般过程有哪些？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2907 【创建时间】：2008-11-29 【作者】：kangkai810 【评论】：6 【内容】：发信人: kangkai810 (kangkai810), 信区: Embedded_System
标  题: 嵌入式学习的一般过程有哪些？
发信站: 北邮人论坛 (Sat Nov 29 12:27:54 2008), 站内

这学期我选修了一门《嵌入式系统技术基础》的课程，但半学期上下来感觉没什么收获。那天听了嵌入式协会的讲座，才对嵌入式系统有了全新的认识。由于我本人对软件比较感兴趣，硬件的知识非常薄弱，所以我选择嵌入式系统软件设计作为学习的方向，但不知道该如何下手？
恳请“过来人”指点一下，嵌入式学习一般要经历哪些学习过程？
先学什么，再学什么？ 
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.164.*]
 

【文章标题】：用串口发文件的问题？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2734 【创建时间】：2008-11-20 【作者】：eelb 【评论】：3 【内容】：发信人: eelb (熊猫酒仙), 信区: Embedded_System
标  题: 用串口发文件的问题？
发信站: 北邮人论坛 (Thu Nov 20 18:12:40 2008), 站内

用超级终端发文本文件，
超级终端会把文件结束符发过来吗？
我测试好像不会发过来，不发过来我怎么判断文件发完了呢
--
希望的动力 耐心的等待


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.135.*]
 
【文章标题】：求邝坚老师的《Tornado/VxWorks入门与提高》 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3013 【创建时间】：2008-12-04 【作者】：seuamos 【评论】：8 【内容】：发信人: seuamos (amos), 信区: Embedded_System
标  题: 求邝坚老师的《Tornado/VxWorks入门与提高》
发信站: 北邮人论坛 (Thu Dec  4 16:18:16 2008), 站内

站内
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.132.*]
 
【文章标题】：嵌入式相关的课件 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2749 【创建时间】：2008-11-22 【作者】：stephen 【评论】：0 【内容】：发信人: stephen (三好学生), 信区: Embedded_System
标  题: 嵌入式相关的课件
发信站: 北邮人论坛 (Sat Nov 22 23:43:16 2008), 站内

贴个中科大的电子课堂的网址，上面有一些讲操作系统的课件还是相当不错的，希望对大家有用。
http://staff.ustc.edu.cn/~xlanchen/
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.215.*]
 
【文章标题】：嵌入式协会 第九次讨论会 【文章地址】：https://bbs.byr.cn/article/Embedded_System/2747 【创建时间】：2008-11-22 【作者】：hobby 【评论】：0 【内容】：发信人: hobby (hobby), 信区: Embedded_System
标  题: 嵌入式协会 第九次讨论会
发信站: 北邮人论坛 (Sat Nov 22 12:58:49 2008), 站内

本周嵌入式协会学习讨论会于周六晚上七点半在教三七一二会议室举行，我们有幸请到李俊同学（现就读于清华大学）来主讲"嵌入式系统的介绍及应用"，欢迎参加！
个人补充：李俊同学很早就接触嵌入式了，相信他的介绍能让大家对嵌入式有个直观、全面且深刻的了解。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.139.*]
 
【文章标题】：问一个tornado问题 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3383 【创建时间】：2008-12-27 【作者】：cow28 【评论】：5 【内容】：发信人: cow28 (鲍勃), 信区: Embedded_System
标  题: 问一个tornado问题
发信站: 北邮人论坛 (Sat Dec 27 19:57:58 2008), 站内

我刚开始学vxworks，先装好了tornado2.2，想运行一个hello world的程序，只有一行代码printf("hello world!\n");但是在vxsim上无法输出，总是显示 Vector 13 : General Protection Fault，请问这是怎么回事！
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 192.168.1.*]
 
【文章标题】：急！有没有哪位同学去年选过一门嵌入式方向的课 是一个挺年轻得 【文章地址】：https://bbs.byr.cn/article/Embedded_System/4508 【创建时间】：2009-04-16 【作者】：atlantis 【评论】：10 【内容】：发信人: atlantis (小妖), 信区: Embedded_System
标  题: 急！有没有哪位同学去年选过一门嵌入式方向的课 是一个挺年轻得女老师教的
发信站: 北邮人论坛 (Thu Apr 16 10:45:42 2009), 站内

有没有哪位同学去年选过一门嵌入式方向的课 是一个挺年轻的女老师教的 在教四上课 可能知道的话麻烦告诉我一下她的姓名~万分感谢
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.211.*]
 
【文章标题】：程序调处来啦 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3083 【创建时间】：2008-12-08 【作者】：haidixipan 【评论】：4 【内容】：发信人: haidixipan (嘉嘉敏 ), 信区: Embedded_System
标  题: 程序调处来啦
发信站: 北邮人论坛 (Mon Dec  8 13:00:23 2008), 站内

combobox要先在设计页面的item加点东西才能被调出

--

※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 118.229.211.*]
 
【文章标题】：能用GDB远程调试目标板上只有bootloader的程序吗？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3134 【创建时间】：2008-12-10 【作者】：lost0910 【评论】：0 【内容】：发信人: lost0910 (grep), 信区: Embedded_System
标  题: 能用GDB远程调试目标板上只有bootloader的程序吗？
发信站: 北邮人论坛 (Wed Dec 10 11:42:15 2008), 站内

可以用GDB远程调试无操作系统的应用程序吗？如果可以的话是不是像ADS一样，要用JTAG接口？用串口可以吗？
请了解过的说一下，谢谢了
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 210.72.218.*]
 
【文章标题】：有人在T61上装LINUX成功吗？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3027 【创建时间】：2008-12-04 【作者】：yxplf 【评论】：4 【内容】：发信人: yxplf (warrior_pig), 信区: Embedded_System
标  题: 有人在T61上装LINUX成功吗？
发信站: 北邮人论坛 (Thu Dec  4 23:49:28 2008), 站内

最近想装一个学习，不知有大侠试过不？另外装哪个版本好啊？
--
      也许最沉重的负担同时也是一种生活最为充实的象征，负担越沉，我们的生活也就越贴近大地，越贴近真切和实在。

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.170.*]
 
【文章标题】：嵌入式学习小组第十一次会议讨论记录 【文章地址】：https://bbs.byr.cn/article/Embedded_System/3091 【创建时间】：2008-12-08 【作者】：BES 【评论】：12 【内容】：发信人: BES (北邮嵌入式协会), 信区: Embedded_System
标  题: 嵌入式学习小组第十一次会议讨论记录
发信站: 北邮人论坛 (Mon Dec  8 15:49:25 2008), 站内

12月7日晚，嵌入式学习小组第十一次讨论会如期在教三七楼玻璃教室会议室举行。本次讨论会的详细内容如下：  
    
第11次学习讨论中演讲的具体内容

韩学奇  基于手机扩展RFID读写器
龙小平  CPLD+单片机
陆冰     一些个人项目经历
白云飞  Uboot和内核移植 工作
 
  有关本次讨论会的相关学习资料及文档在征得演讲者同意后会陆续发布在论坛上，请大家积极关注！  
  
   这次讲座的效果还是很好的，现场交流很多，氛围也很融洽。演讲者一般都是北邮各个重点实验室研一研二的同学，他们大都从自己实际项目中的经验出发，介绍自己项目中的得与失，把自己的亲身体验与大家分享。我们协会还将在12.14晚继续上次的演讲，热烈欢迎北邮相关专业的本科、研究生的同学过来听听，不管与嵌入式学习、还是读研或者其他内容，都可以进行交流，相信大家都会受益匪浅！
 
                                                                                        -------BES宣传部
--
BUPT_EMBEDDED_SYSTEM
北邮嵌入式协会欢迎每位爱好嵌入式的朋友加入！！！
想加入北邮嵌入式协会的同学请将自己的基本信息发送至协会邮箱
bupt.embedded.system@gmail.com

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.148.*]
 
【文章标题】：[求助]全校选修宋美娜老师的嵌入式系统课程论文要求 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6896 【创建时间】：2009-12-12 【作者】：nxlhero 【评论】：0 【内容】：发信人: nxlhero (牛), 信区: Embedded_System
标  题: [求助]全校选修宋美娜老师的嵌入式系统课程论文要求
发信站: 北邮人论坛 (Sat Dec 12 10:19:45 2009), 站内


--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 2001:da8:215:8211:f471:12bf:64f7:*]
 
【文章标题】：[求助]ftruncate也会造成死机？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6912 【创建时间】：2009-12-13 【作者】：longfenfen 【评论】：0 【内容】：发信人: longfenfen (CIC_BUPT人), 信区: Embedded_System
标  题: [求助]ftruncate也会造成死机？
发信站: 北邮人论坛 (Sun Dec 13 11:40:39 2009), 站内

用ftruncate函数增大某个文件，在ntfs格式下没有问题，在fat下就会死机。这是为什么？

※ 修改:·longfenfen 于 Dec 13 11:41:40 2009 修改本文·[FROM: 59.64.134.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.134.*]
 
【文章标题】：求ccs软件下载地址 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6902 【创建时间】：2009-12-12 【作者】：simon0227 【评论】：3 【内容】：发信人: simon0227 (GG_Bond), 信区: Embedded_System
标  题: 求ccs软件下载地址
发信站: 北邮人论坛 (Sat Dec 12 18:18:25 2009), 站内

rt!
bt上没种子了。
希望大家能提供下载网址，或者有的再Bt上作个种！
谢谢！
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.175.*]
 
【文章标题】：谁有Platform Builder 5.0，麻烦传一下，十分感激 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6924 【创建时间】：2009-12-14 【作者】：kangseaman 【评论】：0 【内容】：发信人: kangseaman (我不怕), 信区: Embedded_System
标  题: 谁有Platform Builder 5.0，麻烦传一下，十分感激
发信站: 北邮人论坛 (Mon Dec 14 10:09:04 2009), 站内

rt
站内联系，thx
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 2001:da8:215:5200:0:5efe:3b40:*]
 
【文章标题】：ARM调试求助！！！ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6832 【创建时间】：2009-12-09 【作者】：xxailxb 【评论】：2 【内容】：发信人: xxailxb (潇潇), 信区: Embedded_System
标  题: ARM调试求助！！！
发信站: 北邮人论坛 (Wed Dec  9 17:15:49 2009), 站内

 
     现在正在调一个S3C6410的板子（主要是硬件调试），已经调试一个月左右了，进展很不顺利，不知道有没有大牛（主要硬件调试方面的），对ARM硬件调试有经验或者兴趣，利用私人时间来帮我们调试，详细内容与报酬面谈！ 
联系方式  13426401058   或者站内   

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.152.*]
 
【文章标题】：还是得开新贴。。求助：我该怎么挂文件系统？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6908 【创建时间】：2009-12-12 【作者】：EasonChen 【评论】：7 【内容】：发信人: EasonChen (你的陈奕迅), 信区: Embedded_System
标  题: 还是得开新贴。。求助：我该怎么挂文件系统？
发信站: 北邮人论坛 (Sat Dec 12 23:31:59 2009), 站内

uboot启动找不到文件系统
我现在有一个ramdisk的包 解压好了 我该怎么放上去呢？
tftp配好了 nfs也配好了 用哪个？

 大牛说 要设置bootargs
网上查了查 说要设置这样一串命令 setenv bootargs root=/dev/nfs nfsroot=172.22.60.149:/root/nfs/root2410/ ip=172.22.60.63 init=/bin/bash console=ttySAC0,115200

我想知道这里的ip是我的ip么 还是我要设置板子的ip？
这串命令之间要空格么？ 
我用网线连了板子之后 我的主机就没有ip地址了阿。。。

还有就是 我非常不懂镜像、板子、ramdisk这些东西的关系
板子上的内核、文件系统是在flash里的？ 镜像是在ram里的？ 我是只要把镜像放进去 我就可以进行开发了？ 没有弄到flash里也可以？

我是菜鸟 真的很多不懂 问题可能很可笑 大家尽量帮我解答吧 谢谢 好多东西网上搜来的答案也看不懂。。。
--

※ 修改:·EasonChen 于 Dec 12 23:33:11 2009 修改本文·[FROM: 2001:da8:215:8611:21d:9ff:fe4b:*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 2001:da8:215:8611:21d:9ff:fe4b:*]
 
【文章标题】：谁有《VxWorks API Referedce》呀，好心人共享下哦？ 【文章地址】：https://bbs.byr.cn/article/Embedded_System/6890 【创建时间】：2009-12-11 【作者】：lj8175 【评论】：4 【内容】：发信人: lj8175 (lj_8175), 信区: Embedded_System
标  题: 谁有《VxWorks API Referedce》呀，好心人共享下哦？
发信站: 北邮人论坛 (Fri Dec 11 17:14:39 2009), 站内

Thank you!
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.64.66.*]
 
【文章标题】：【出书】各种嵌入式书籍，全新 【文章地址】：https://bbs.byr.cn/article/Embedded_System/4977 【创建时间】：2009-05-30 【作者】：ghjmon 【评论】：5 【内容】：发信人: ghjmon (Squall), 信区: Embedded_System
标  题: 【出书】各种嵌入式书籍，全新
发信站: 北邮人论坛 (Sat May 30 22:06:28 2009), 站内

1、基于VxWorks的嵌入式系统及实验，徐惠民，北邮出版社。 15元（原价35元）【已出】

<a target="_blank" href="/att/Embedded_System/0/4977/1208"><img border="0" title="DSC00651.JPG" src="/att/Embedded_System/0/4977/1208" alt="DSC00651.JPG" class="resizeable"></a>

2、Windows CE 嵌入式系统，何宗键，北航出版社。15元（原价32元）

<a target="_blank" href="/att/Embedded_System/0/4977/79965"><img border="0" title="DSC00652.JPG" src="/att/Embedded_System/0/4977/79965" alt="DSC00652.JPG" class="resizeable"></a>

3、Windows CE.Net 程序设计，姜波，机械工业出版社。15元（原价39元）

<a target="_blank" href="/att/Embedded_System/0/4977/164609"><img border="0" title="DSC00653.JPG" src="/att/Embedded_System/0/4977/164609" alt="DSC00653.JPG" class="resizeable"></a>

4、Windows CE 实用开发技术，电子工业出版社。20元（原价45元）

<a target="_blank" href="/att/Embedded_System/0/4977/270815"><img border="0" title="DSC00656.JPG" src="/att/Embedded_System/0/4977/270815" alt="DSC00656.JPG" class="resizeable"></a>

5、QT及Linux操作系统窗口设计，倪继利，电子工业出版社。30元（原价68元）

<a target="_blank" href="/att/Embedded_System/0/4977/357769"><img border="0" title="DSC00657.JPG" src="/att/Embedded_System/0/4977/357769" alt="DSC00657.JPG" class="resizeable"></a>

6、Windows CE.net 内核定制及应用开发。电子工业出版社。15元（原价35元）

<a target="_blank" href="/att/Embedded_System/0/4977/453164"><img border="0" title="DSC00658.JPG" src="/att/Embedded_System/0/4977/453164" alt="DSC00658.JPG" class="resizeable"></a>

7、Tornado/VxWorks 入门与提高。邝坚，科学出版社。15元（原价37元）

<a target="_blank" href="/att/Embedded_System/0/4977/554566"><img border="0" title="DSC00659.JPG" src="/att/Embedded_System/0/4977/554566" alt="DSC00659.JPG" class="resizeable"></a>

8、嵌入式系统设计与应用开发，郑灵翔，北航出版社。15元（原价36元）【已出】

<a target="_blank" href="/att/Embedded_System/0/4977/635232"><img border="0" title="DSC00660.JPG" src="/att/Embedded_System/0/4977/635232" alt="DSC00660.JPG" class="resizeable"></a>
 
以上书基本全新，因为刚买不久就转行了。需要的同学站内联系，或者手机13521416180

--

※ 修改:·ghjmon 于 Jun  6 10:05:38 修改本文·[FROM: 2001:da8:215:1302:6cb5:4843:528c:*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 2001:da8:215:1302:e124:f741:2cee:*]
 
【文章标题】：这个驱动小毛病搞了几个小时,谁帮我看一下呀 【文章地址】：https://bbs.byr.cn/article/Embedded_System/1591 【创建时间】：2008-10-14 【作者】：lester98 【评论】：1 【内容】：发信人: lester98 (奶瓶), 信区: Embedded_System
标  题: 这个驱动小毛病搞了几个小时,谁帮我看一下呀
发信站: 北邮人论坛 (Tue Oct 14 15:48:39 2008), 站内

主要就是在驱动的init函数中调用另外一个函数发生的,linux版本为2.4
情况一:
static int ds1302_rtc_probe()
{
... 前面语句均无关,仅最后三行...
   if (!(c == 0x42))
        return 1;
   return 0;
}

static int __init ds1302_rtc_init(void)
{
        int ret;
        ret=register_chrdev(253,DRV_NAME, &amp;ds1302_rtc_ops);
        if(ret){
                printk("can't register rtc0\n");
        }
        ret=ds1302_rtc_probe();
}
这样在编译好之后insmod的时候出错如下
Using a.o
insmod: init_module: a: Device or resource busy

情况二:
static int ds1302_rtc_probe()
{
... 前面语句均无关,仅最后三行...
   if (!(c == 0x42))
        return 1;
   return 0;
}

static int __init ds1302_rtc_init(void)
{
        int ret;
        ret=register_chrdev(253,DRV_NAME, &amp;ds1302_rtc_ops);
        if(ret){
                printk("can't register rtc0\n");
        }
        ret=ds1302_rtc_probe();
        if(ret){
                printk("can't probe rtc0\n");
        }
}
这样在编译好之后insmod的时候出错如下
Using a.o
can't probe rtc0
insmod: init_module: a: No space left on device

情况三:
static int ds1302_rtc_probe()
{
... 前面语句均无关,仅最后三行...
   if (!(c == 0x42))
        return 1;
   return 0;
}

static int __init ds1302_rtc_init(void)
{
        int ret;
        ret=register_chrdev(253,DRV_NAME, &amp;ds1302_rtc_ops);
        if(ret){
                printk("can't register rtc0\n");
        }
        ret=ds1302_rtc_probe();
}
这样在编译好之后insmod的时候出错如下
Using a.o
insmod: init_module: a: Device or resource busy

情况二:
static int ds1302_rtc_probe()
{
... 前面语句均无关,仅最后三行...
   if (!(c == 0x42))
        printk("can't probe rtc0\n");
   return 0;
}

static int __init ds1302_rtc_init(void)
{
        int ret;
        ret=register_chrdev(253,DRV_NAME, &amp;ds1302_rtc_ops);
        if(ret){
                printk("can't register rtc0\n");
        }
        ret=ds1302_rtc_probe();

}
这样insmod的时候不会发生任何错误
Using a.o
can't probe rtc0
--
希望将来能用这句话做签名
I graduated from this school ,and survive

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 125.33.192.*]
 
