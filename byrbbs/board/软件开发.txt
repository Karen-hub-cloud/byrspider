【文章标题】：[合集] 十年MFC经历认识的Microsoft技术 出处：CSDN.NET 作者： 【文章地址】：https://bbs.byr.cn/article/SoftDesign/210 【创建时间】：2005-06-28 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (!byr--709394), 信区: SoftDesign
标  题: [合集] 十年MFC经历认识的Microsoft技术 出处：CSDN.NET 作者：孙辉 (�
发信站: 北邮人论坛 (Tue Jun 28 16:44:08 2005), 站内

☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:47:46 2005)  提到:

初识MFC 

　　我最初知道MFC大概是在1993年，那个时候Visual C++还没面世，当时Microsoft的C++编译器还很弱，官方的名字是Microsoft C/C++ 7.0，MFC的版本是1.0，几乎没有引起什么反响，那个时期最好的C++开发环境是Borland C++ 3.1，其实，大概是1992年11月份，一个偶然的机会，我领略到Borland公司的厉害，记不得在什么地方，我看到一个绝妙的集成开发环境，即Turbo C++ 3.0 for Windows，这是我记忆中第一个真正的Windows环境下的C++集成开发环境，那种激动的感觉至今仍记忆犹新，不客气的说，当时至少在C++方面，Microsoft与Borland不是一个水平的，Borland明显的要高于Microsoft ，Borland的产品在技术上给我留下深刻的印象。那个时候Microsoft最好的开发平台是Visual Basic 3.0，而Borland的Delphi正处于开发阶段（Delphi 的代码名称是：“VB Killer”）……，想起这些十几年前的往事，我不禁感慨万千。 

　　十几年来，我用过许多开发环境，关于Visual Basic，我用过最早的DOS版本，Windows版的Visual Basic我基本上全都用过，至今我还记得每个版本的VB安装盘磁盘的盘数。同样，我用过各个版本的Delphi，特别是Delphi 2.0，给我留下极好的印象。Delphi提供真正编译的可视化开发环境，那个时候（1994年左右），Delphi就可以开发带有GUI的动态链接库，你可以想象，在Microsoft Access 2.0的应用程序中可以加载一个Delphi Form并进行程序交互，那种感觉真是棒极了。 

　　Borland C++是我心中无法抹掉的遗憾，从Turbo C到C++ Builder，我深刻的体验到Borland的辉煌和无奈，Delphi从VB Killer走到为VB护航（你可以想象Delphi一步到位的ActiveX 控件开发技术有多牛，早期的VB有多土，早期的VB不能开发动态链接库，因此无法开发ActiveX 控件，想起来真令人嘘唏不已），Borland C++的命运也是不济。Borland C++ 3.1的辉煌永远不再了，十几年的开发工作中，我在C++上投入了大量的精力，Borland C++曾经给我带来无数的激动，然而这个经典的名字却在与Microsoft的竞争中渐渐的流逝了……。 

　　MFC4.0的出现，使得人们感觉Microsoft在C++方面赶上来了，这一版的MFC是Win95推出后出现在Visual C++ 4中（Microsoft没有VC 3，VC4以前的版本是2.2、2.1、2.0、1.51、1.5、1.0）。也许是对Borland C++的潜意识的失望，我不知不觉的接受了MFC，VC 4.2推出时，我通过正常渠道购买了这个编译器的企业版。 



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:48:22 2005)  提到:

关于Microsoft 

　　关于Microsoft，有无数的人要对这个名字叙说感觉，这个令人讨厌的名字！不知道是喜欢还是憎恶，你是程序员，你的心思可能就要因Microsoft的存在而动，即使你用Linux，你可能也是因为Microsoft技术因素。多少年来，这个名字每天都出现在你、我、他的面前，因为你不得不面对Windows的存在，可是你憎恨这个名字吗？你讨厌这个名字吗？我不知道是否已经对这个名字麻木了。1998年我个人订了Microsoft MSDN Universal 版，我开始比较全面接触这个公司的开发技术，你可以想象，1998年当你面对上百张技术光盘的时候，你就知道什么叫做“厚度”，当我们有时说出“赶上”或 “达到”Microsoft某些产品的水平的时候，可能我们缺乏对这个公司“厚度”的真实了解。进入MSDN，我感觉Microsoft简直不是一个“公司”，而是（或者正在形成）一个“社会”。当时著名的技术网站<a target="_blank" href="http://www.codeguru.com">http://www.codeguru.com</a>全部的技术资料是可下载的（那个时候<a target="_blank" href="http://www.codeguru.com">http://www.codeguru.com</a>提供整个网站内容下载服务，大约3M左右），大名鼎鼎的www.codeproject.com还不存在。一开始，我始终潜意识在技术上对比Microsoft与Borland，应当说技术上Borland不比Microsoft弱，即使现在也有人持有这个看法，可是为什么Borland走到今天这个地步？

　　而Microsoft却如日中天？若干年前，这两个公司竞争何等激烈，而现在却是另一番“合作”的景象？可能很多人想过，如果Borland不存在，对Microsoft不是更有力吗？其实Microsoft可能精通中国历史，读过《三国》、十分了解战国时期的中国，其实Borland形式上的存在，对Microsoft是十分有利的，至少形式上还有竞争对手，而事实上Borland已经受控于Microsoft（Microsoft是Borland的大股东）。你可以看到一些微妙的现象：Borland为Microsoft提供了大量的人才，其中包括Delphi总设计师以及Borland C++编译器的核心成员；同时也为Microsoft .NET提供强有力的护航服务（看看C# Builder、Delphi .NET）。1998年Microsoft 的COM技术基本已经成熟，这个技术使人感到震撼，当时Microsoft的对手们提出“OpenDoc”用于对抗“COM”，你看看“OpenDoc”阵营的几个成员：IBM、Apple、Borland、Novell，你会感到这个阵营十分豪华、强大。但结果却差强人意，“OpenDoc”无疾而终，而“COM”依然生机勃勃。 

　　有人说“COM”没落了，那么就太不了解Microsoft了。在与“OpenDoc”的竞争中，“COM”是个彻底的胜利者，在与“Java”的竞争中，“COM”成功的进化了，在这个过程中Microsoft体现了强大的吸收能力、以及无法想象的韧劲。.NET只不过是COM的“别名”而已。对于一个经验丰富的C++程序员而言，.NET就是COM的进化，而Microsoft内部.NET就是“COM 3.0”（OLE2就是COM 2.0），而“CLR”就是一个不择不扣的COM对象。曾经有人问我，既然牛顿时代就奠定了基础（想想著名的牛顿-莱布尼茨公式），几百年后的今天，数学还研究“微积分”吗？回答当然是依然在研究！“微积分”早期是针对函数的，现代“微积分”是针对“流形（Manifold）、纤维丛（Fiber Bundle）”的，概念深奥了，可是基本思想不变，只是“微积分”的思想得到合理的延拓与进化，你了解Microsoft吗？Microsoft Research有一批超一流的数学家在为Microsoft工作，其中一些是斐尔兹奖的得主，Microsoft正在实现如同“微积分”进化到“微分流形”一样将“COM”进化到“.NET”。从科学概念角度上分析COM与Java，可能COM更全面、精确，从实现的成熟度上Java可能更成熟，可是你看到，Microsoft正在不紧不慢的追赶。Microsoft令人联想起战国时期的强秦。


☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:48:49 2005)  提到:

战国时期的秦国，采取“远交近攻”“抚弱掠强”等措施傲视六国，今天的Microsoft也是这样，VB1.0时，Microsoft推出“VBX”控件技术，众多的小公司得以生存，Microsoft自己不开发“VBX”组件，同样“VBX”进化为“OCX”时，Microsoft并不十分强大，可是这种试探得到众多小公司的响应。1997年Microsoft Office 97、1998年Microsoft推出Visual Studio 6.0，给众多中、小公司提供了生存、发展的机会，例如Microsoft Office 97中集成了Visual Basic for Application 5.0，这项技术使得几百家软件开发商与Microsoft签署了VBA技术许可协议，即使AutoDesk这样的公司都与Microsoft签署了这个协议，这个协议使得每个集成VBA的产品的给个用户许可为Microsoft付40$的许可费，如果你了解VSIP（Visual Studio Integration Protocol）协议，以及有多少公司签订了VSIP协议，你就真正感觉到Microsoft的可怕；Microsoft Office 97、Visual Studio 6.0的用户界面十分漂亮，为什么Microsoft自己的开发工具不提供类似的软件组件？你看到众多第三方的Microsoft盟友纷纷推出自己的界面库以模仿Microsoft，他们不会反对Microsoft，因为他们已经形成了使得Microsoft以及这些公司得以生存的生态圈。 

　　Microsoft的技术储备有多少，Microsoft之外的人很难说清楚，Microsoft中国公司也未必了解多少，1999年WTL类库刚刚出现的时候，人们就希望WTL能得到官方的支持，或授权给一个Microsoft之外的一个公司（你能想象出Borland C++ 5.0内置的ActiveX开发机制是基于Microsoft ATL类库吗？），直到今天，WTL依然如故，我们完全相信，如果Microsoft强力推广WTL，WTL完全可以流行，可是Microsoft不缺类似的技术，类似的类库还有BCL(Base Control Library，一个用于开发轻量级ActiveX控件的类库)，Microsoft还有一个基于ATL的类库，这个类库用于开发ActiveX Designer，ActiveX Designer是绝大多数程序员不了解得一类对象，如果你熟悉Office开发，你知道Office VBA 中有一类对象，即Form2，此外VB6.0 中的报表设计器（以及著名的Active Reporter），都属于此类对象，用这个类库，你可以为VB6.0以及集成VBA的系统提供定制化的可视化设计机制等等，如今ActiveX Designer已经演化为集成于Visual Studio .NET中的设计器。

　　向Microsoft学习 

　　无论从什么角度评价Microsoft，我觉得Microsoft是值得我们学习的，如果说生活在这个时代有Microsoft存在是一场灾难，你就应该痛恨这个家伙，但你首先要向这个家伙学习！我无意为Microsoft歌功颂德，我只是想说出十几年我对Microsoft技术的感受。


☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:49:18 2005)  提到:

Microsoft在研究式的开发中受益极大，如果你有兴趣，你可以访问<a target="_blank" href="http://research.microsoft.com/">http://research.microsoft.com/</a>，虽然部分中国公司也有研究院，但与Microsoft相比，真有“米粒之珠，也放光华？”的感觉。2003年，我在北京的一个地方现场体验了Microsoft亚洲研究院的招聘会，我看到中国的精英们进入Microsoft的渴望，事实上，在中国大陆，Microsoft亚洲研究院的人力资源已经延伸到各著名高校的相关专业的核心层，我感到，Microsoft几乎不需要“求贤”，因为，只要Microsoft需要，精英们会“蜂拥而至”，每个人都有“可以理解”的理由而向往那个地方，如果为搞数学研究蜂拥到加州大学，我觉得可以理解，因为那里有数学土壤，出了成果国人也会感到自豪，因为“科学无国界”。技术是否有国界？不知道是否有定论？！想想DVD等技术专利给国内业界带来的灾难，不知道应不应该痛定思痛，在Microsoft校园招聘现场的气氛中，我似乎明白了为什么国人“原创技术”少得可怜。我读过几本Microsoft亚洲研究院的高手写的书，明显可以看出，Bill gate 是他们的精神领袖以及他们对Microsoft的虔诚，国内的研究机构应当研究一下Microsoft的用人之道，Microsoft好像是三国里的人物，不知是刘备还是曹操，或者二者的混合物。我经常路过西格玛大厦，第一次西格玛大厦进入真有“朝圣”的感觉，也与Microsoft中国的几个层次的人打过交道，各中滋味实在一言难尽。 

　　在Office大战中，国产软件的确在一些方面与Microsoft进行较量，其实给人的感觉很勉强，界面上的似是而非，或用户习惯方面的接近并不能解决根本的问题，一个好的软件开发人员必须是一个软件使用的高手，很难想象一个软件操作水平很拙劣的开发人员能开发出高水平的软件，我最早使用的软件之一就是Microsoft Word，当时的版本是2.0，大概是1992年的事情，给我留下深刻印象的是集成于Word中的Word Basic，后来，我接触到Excel 3.0，不出所料，Excel中集成的是Excel Basic，后来使用的Access中自然内置Access Basic 1.0，在这些软件集成捆绑成Office之前，我就感觉这些产品的构思十分了不起，很具有Microsoft的风格，因为你知道，即使是一个DOS，Microsoft都要提供一个内置的QBasic或GW Basic。虽然关于Microsoft的产品评论很多，作为一个技术人员，我认为Microsoft的产品构思绝对是第一流的，从1994年早期的Office系列到1997年形成的Office 4.2，我认为，技术构思上均领先于我国2002年以后的Office产品，你听说过如下说法吗？“Dos 作为操作系统的时代，Windows是应用软件；Windows是操作系统时，Office成为Dos时代的Windows；那么如果按此规律，Office会不会替代Windows而成为操作系统？”，现在在开发领域Visual Studio( .NET)正在成为另一个Office，你注意到了吗？控制Visual Studio( .NET)集成开发环境的仍然是一个Basic语言引擎（Visual Basic .NET）。 

　　与许多公司不同的是，在技术体系上，Microsoft几乎所有的产品是息息相关的，Windows、Office、Visual Studio .NET虽然各不相同，但公共的核心即将形成，我们已经看到，核心组件方面，Office与Visual Studio .NET日渐趋于一致，例如Microsoft正在将Office 2003的核心组件VBA 6.X逐步用新的Visual Studio Tools for Office替代，而我们依然在一些似是而非的现象上与Microsoft的产品比较差距，国家采购或政府采购支持的公司，不去钻研核心技术，只是急功近利的采用短期行为急于与Microsoft相争，不知是否有蚍蜉撼树的感觉，个人的体验是，先学习Microsoft，踏踏实实的学，了解Microsoft，深入的了解，然后再喊口号。



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:49:42 2005)  提到:

为什么用MFC？ 

　　经过若干年的竞争，Borland 的OWL几乎消失了，这个OWL是个非常漂亮的C++类库，在Borland C++ 3.1风光无限的年代，OWL真正的做到了独领风骚。然而，Borland C++ 4.0错过了进入32位程序的最佳时机，BC 4.0推出后不久，迎来了Win95，Borland仓促上阵，以一个小的“Pack”使得BC4可以编译基于Win4的程序，当时的Visual C++是2.0版，支持Window16的版本为Visual C++1.51，有意思的是Borland可以用同一个编译器同时支持Win16、Win32，而Microsoft却不得不为Win16、Win32提供不同的编译器。然而，非正式版本的Visual C++ 2.1与Visual C++ 2.2却悄悄地支持了Win95的最新特征，即Win95新提供的一组公共控件，在我的印象中，Borland对Win95新特征的支持不利使得MFC与OWL的距离极大的缩短了。稍后到来的Borland C++ 4.5没有改变这个状况，尽管Borland C++ 5.0同时支持OWL与MFC，可是败象已经显露，Borland C++非常遗憾的只走到了5.5版。C++ Builder虽然形式上引入了Delphi的VCL库，可是许多C++程序员并不买账，因为许多以C++为乐的人更喜欢以编辑的模式进行编码。Visual C++ 4.0的出现，在C++这个战场上，Borland开始落败了。 

　　MFC发展到今天，已经十多年了，尽管褒贬不一，但可以肯定，十几年的技术积累已经奠定了MFC的生存基础，即使Microsoft的长角发布，MFC也不能推出Windows的舞台，事实上，长角（Longhorn）之后的Visual Studio .NET仍将MFC作为一个重要的组成部分，在今年的Visual Studio .NET 2005中，MFC在C++中的位置依然如故。MFC的未来，应该不必担心，只要你深入考察.NET类库，你会发现，MFC的许多思想机制正悄然进入.NET，与此同时，Microsoft的第三方盟友十多年来已为MFC开发了大量的扩展库，如果Microsoft是船，第三方盟友就是载舟之水。许多人认为MFC不发展了，其实是一种错觉，Visual C++ 6的界面十分经典，特别是其中的Docking控制条机制，其实Visual C++ 6的IDE完全就是MFC写的，可是MFC类库中控制条相关的类功能很弱，为什么？你会看到许多与Microsoft友好的公司，他们很快的在MFC基础上实现了Visual C++ 6 的Docking机制，这就是Microsoft的高明之处，Microsoft很会给盟友提供机会，其一贯的做法就是在自己的商品化产品中预先提供一些有趣的特征，使得其他一些公司进行模仿以带动用户群体。Borland不具备这样的储备。MFC第三方市场的繁荣，得益于Microsoft的策略与明智。MFC可否跨平台？理论上完全可以，Microsoft不做，也是策略，但是有许多重要的产品Microsoft却默许MFC移植到其他平台，事实上，Microsoft的合作伙伴之一Mainsoft公司（Windows源码就是从这家公司流失的），几年来就是负责移植MFC程序移植到UINIX、Linux、AIX等操作系统之上。 

　　新版的Visual C++中MFC已经支持.NET开发了，MFC与ATL的协作更好了。根据我的经验，MFC、ATL与.NET库三者完全可以融合在一起综合应用到实际的开发工作中去，如果你是MFC行家，我希望ATL与.NET库能成为你的忠实的左右手。那么有没有同时支持MFC、ATL与.NET库的程序？当然有，Visual Studio .NET IDE就是！而且Visual Studio .NET IDE还支持用ATL与.NET库扩展的Addin。



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:50:22 2005)  提到:

认识Application对象 

　　如果你熟悉Microsoft Office，你应该进一步的剖析这个大型软件，Microsoft Office中几乎每个程序都是可二次开发的，这一点得益于Microsoft Office内置的二次开发机制，一个是基于COM机制的VBA模型，另一个是基于.NET框架的托管模型：Visual Studio Tools for Office。作为一名程序员，你应当在技术角度解析Office的技术结构。Microsoft的大多数软件的对象结构可以通过Visual Studio提供的工具OLE/COM Object Viewer考察其类型库得到，通过引用类型库，你甚至可以得到描述对象信息的C++头文件。这样做真是好处多多。一个典型的Office通常都有一个Application对象（或其他一个与之相当的对象），这个对象相当于软件枢纽，在这里，我们不讨论Office，借此话题说说Application对象。大多数支持扩展（Addin、Plugin）的软件都存在类似的构造。通常，一个系统得Application对象或者是一个COM对象，或者是一个.NET对象，如果你的系统存在这类对象，你的系统就基本具备支持Addin、Plugin的机制了。一个理想的做法就是在一个MFC系统中，内置一个ATL对象或.NET对象，稍后我们给出方案如何做到这一点。设计Application对象的关键是如何规划这个对象的属性、方法、事件。如果你希望系统具备良好的扩展性，Application对象是十分关键的，这也是构架艺术的体现。所谓Addin(Plugin)，是系统运行时根据需要加载的对象库，Addin(Plugin)之所以可以扩展系统，关键的因素就是系统加载Addin(Plugin)时，将Application对象传递给Addin(Plugin)库，设想一下，如果Application恰到好处的触发了系统事件，而Addin(Plugin)库如愿的解释了事件，一个Addin(Plugin)库的任务不就OK了吗！因此Application对象是系统设计的关键。 

　　如果你精通ATL对象，在你的MFC系统中添加一个ATL对象，这个任务可以用VC Wizard完成。你已经接受了一个事实，就是MFC程序中存在一个CXXXApp对象（CWinApp的派生类），现在你要做的是增加一个对应得ATL对象。这个对象可以在CXXXApp::InitInstance()中创建，如果ATL对象的类是CXXXAppObject，建议你在CXXXApp对象对象中增加一个成员变量，例如：CComObject * m_pAppObj，然后可以入下初始化m_pAppObj： 

　　m_pAppObj = new CComObject ； 

　　注意程序结束时在CXXXApp::ExitInstance()中释放m_pAppObj，语句如下： 

　　delete m_pAppObj； 

　　你可以将系统得关键属性设置成CXXXAppObject的属性，例如系统得标题、是否为多文档等等。系统希望外部调用的功能可以实现为CXXXAppObject的方法，这一点取决于你的需要。系统需要外部扩展的功能，表现为CXXXAppObject的事件，关键是在恰当的位置触发事件以及提供的事件参数。例如，你可以在CXXXApp::InitInstance()触发应用程序开始的事件OnStartUp，Plugin捕获事件后，可以进行特定的初始化（身份确认、初始信息查询等等）； 




☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:51:34 2005)  提到:

你可以在CXXXApp::ExitInstance()触发应用程序结束事件，Plugin捕获事件后，处理用户需要的系统退出工作。所有的设计取决于具体设计。 

　　如何加载Plugin，是一个有趣的问题，如果Plugin实现为一个COM范畴（Category），可以运用COM技术枚举这个Category；可以将Plugin安装到一个特定目录，也可以通过注册表。Plugin的实现可以用COM技术、也可以用.NET框架。适当的机会我会提供例子…… 

　　一些感想 

　　一时心血来潮，就发了这个帖子，很难说是有心，还是无意。几天前我在新浪网上看应氏杯围棋决赛，我觉得该赢了吧，作为一个围棋迷，我们等了十几年，等到了属于国人的应氏杯。记得7、8年前在还在大学工作的时候，有一次，一位同事兴致冲冲的走道我面前对我说：“嗨，昨天马XX赢了李昌镐！”，当时我在系办公室正在看报纸，那位仁兄见我头都没抬，非常不满的抢下报纸，对我吼道：“喂！马XX赢了李昌镐！！你听到没有！！！”，我对他说：“你大惊小怪个啥？！马XX输了李昌镐多少盘，你知道吗？”，马XX几乎一直在输给李昌镐，人们已经不奇怪了，偶尔赢一次，国人就把他捧得北都找不到了，李昌镐弱冠17的时候就傲视这个世界了，可至今面孔不变，几天前的农心杯，中日联军5个人，被他打个落花流水，李昌镐是公认的世界第一，以至于有的高手知道下一个对手如果是他，就会去订回程机票。这次应氏杯，国人竟然感谢崔哲瀚，何也？因为这个弱冠19的小子，挡住了他的大哥李昌镐才使得应氏杯有了悬念。当国人媒体在说韩国仅李昌镐一人厉害的时候，不知道是出何居心还是自欺欺人，李昌镐年方30，不知道要力压中、日多少年！面对这个名字，真有点麻木了，这个太极虎！软件界又来了我们一向不齿的印度虎，2001年我们的软件出口额仅是印度的四十分之一，我们震惊了，怎么可能呢？这个四十分之一水分很大，很可能更可怜！当时我在大连参加一个关于“大连软件出口国内第一”的官方会议，那位大人在会上说：“据说，我们大连软件出口国内排名第一，市有关领导希望今天的会议给出这个第一的数字依据，希望你们把数据报上来，去年的数据也可申报，注意，我们要的只是数据，你们仔细体会，我们根据数据，有奖励，机会难得呀！”……。某一天，几个朋友在我家看央视的对话节目，对话一方为国内的软件大鳄们（用友、阿尔派等公司的老总们），另一方为印度软件的一个代表团。当问及中、印软件差距的时候，我们的刘老总（代表阿尔派）不以为然的说，据他的看法，我们已经快赶上（印度）了，……，言下之意颇有印度的水平不过如此的感觉，印度方的话我至今记忆犹新：“是否赶上，国际市场说的算！在中国看来，印度程序员的个性不足，技术也不怎么样，其实是个错觉，印度软件首先注重个性，许多重要的美国商品化软件都是在印度本土开发的……”，我们的舆论总是将印度程序员的水平描述的平庸至极，可是差距日渐拉开，……，围棋、足球（不好意思谈，谈不出口！）、软件，我们被近邻严酷的封锁了，乐坏了记者们、给媒体带来了生机…… 

　　日本江户时代的围棋，如果一个人要想世袭一个称号（例如：本因坊），他必须战胜所有的师兄弟，然后，住进师父家的内室，你知道以后的事情吗？以后，这个棋手，就得为师父一家做饭、带孩子、搞卫生……，其余的门人则一心一意的下棋，这样的人、方式，造就了一代一代的本因坊，他们的棋谱大多数都流芳至今，这就是早期日本围棋的悟道模式。软件总共有多少语句？我最早接触的计算机软件教材是一本英文版的（影印的D版），不同于我们，那本书的作者构造了“X-语言”，他们不讲什么C、Pascal、Basic，一旦缺了什么机制，就给“X-语言”添加些成分。什么C、Pascal、Basic，你感觉差不多，但现在却分出了等级！我们驾驭语言的能力弱得很，可是我们在语言的细微之处却很讲究，不知道对不对，许多程序员也许是出于虚荣而用C++，事实上，地球人都知道，做数据库，Delphi、VB远比C++胜任，铺天盖地的C++的书，写的东西几乎雷同，因为，有用的或者作者不写、或者作者不懂。有时我在想，如果国内没有内需，会怎样？也许软件内需的存在，造就了中国软件的特色，我认为国内业界并没有充分利用中国软件内需的存在，也许中国软件内需的存在是软件落后的硬伤。 

　　我记得一部电影《神辫》，那个英雄的大辫子被洋人炸掉了，最终他成了神枪手，战胜洋人用大刀、秘籍是不行的，用洋的东西战胜洋的技术才是正道。我觉得，一个好的程序员必须了解软件的历史，学习历史，你知道你为什么弱，别人是如何强大的。我们正在另一个战场上抗美（可笑的是我们却要赶超印度！），无论Microsoft、Borland如何争斗，无论他们谁统治谁，他们不影响美国的强大，朋友们，学习Microsoft，开发出让国人感到牛的软件！ 


☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:52:03 2005)  提到:

FireFox与Microsoft 

　　FireFox在一片赞扬、欢呼声中激情登场了，也许人们真的期待已久，平静的水面终于被扔进一块石头。我是IE的最早期的用户了，1996年首次Microsoft的TED（技术教育大会），IE4还没有发布时候，我们有机会目睹了内部版本的IE4（当时内部名称是：纳什维尔，英文名称忘记了），那真是一次令人激动的预览，当时IE3与Navigator 3激战正酣。当你第一次看到想象中的“Active Desktop”，如果你没有身临其境，你不会激动。IE4本质上是一个Shell，其SDK是免费的，Navigator是基于Mozilla的浏览器，虽然是开源的，由于要照顾更大的共性（与操作系统无关），因此Mozilla不能充分的利用Windows的优势，Mozilla不能为广大的程序员带来所谓开发人员的“快感”，顶尖程序员可以驾驭Mozilla，以实现技术深度带来的乐趣，最早的Navigator同时提供17个版本（注意：不是17种自然语言，而是17种操作系统），从数学角度分析，Mozilla就像一组公理，你可以以此为基础开发不同操作系统上的浏览器，Navigator就是基于Mozilla的一个漂亮的结果，你能欣赏到代码结构的优美，然而失去的却是功能强大的个性（要知道，Windows用户在数量上远大于其他操作系统用户的总和）。普通用户不可能读懂Mozilla的代码，即使懂了也不能很好的运用，这也许是Mozilla（以及大多数开源代码）失败的致命原因之一。IE内核聪明的抓住了开发者，你想想：对数以万计的中、初级开发者而言，容易驾驭是首选的选择，也是明智的。我读过Mozilla，但我不会在开发过程中为一个具体的项目应用它。只要是浏览器，就不可能绝对的安全，无论是Mozilla，还是IE。当我了解到FireFox是基于Mozilla的一个新的浏览器，我基本上对其失去了信心，我有一个奇怪的观点：FireFox的推出，最大的受益者绝对是Microsoft，即使Microsoft失去20%的份额，但是会导致Microsoft强化IE，Microsoft正不知道如何促使IE进化的时候，FireFox的出现无疑为Microsoft提供了机会，物种进化的原则就是竞争，FireFox就是促进IE进一步强大的催化剂。FireFox的扩展机制的确十分灵活，如果对手不是Microsoft，就很难掀起波澜，而且当高级的开发者逐渐了解FireFox的时候，FireFox的漏洞就会渐渐暴露，试想想，如果某种Linux取代了Windows，那么，它的漏洞也会与Windows一样多，因为那个时候，会有与研究Windows漏洞一样多的人去研究对应得Linux的漏洞！从个人的角度上看，Microsoft也许有点“冤”，因为窥视Microsoft弱点的人实在太多了。从理论上看，计算机安全性是个永远的话题，就像任何社会都需要警察一样，没有了小偷、贼、犯罪，警察也就消失了，你想想，文明是什么？野蛮能消失吗？野蛮消失了，文明也就不存在了，高度文明就是更不存在了。人类克服了癌症，下一个疾病会比癌症更致命，但这并不意味着不必克服了癌症，进步真是一种挑战…… 

　　IE的技术构思肯定是个卓越的构思，IE可扩展的机制，会给Windows开发者带来许许多多的益处。我正在计划一片文章，介绍如何将你的对象模型与MSHTML库实现对接，这样，在HTML文件中可以将你的指令系统与HTML对象模型融合在一起。 



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 09:52:33 2005)  提到:

话说“Hook” 

　　在CSDN上时常看到关于“hook”，的问题，令我想起另一个话题，那就是游戏“外挂”。Hook提供一种改变一个Windows窗口消息处理的一种手段，通常的开发根本用不到，因此，谈不上“常用”，早期的Windows，由于不能很好的支持远东（当然包含汉字）地区的文字，因此出现了许多外挂的软件补充Windows的不足，中文之星是一个典型的、令国人自豪的软件，监控软件也许要运用hook技术，此外，很难想象什么软件会用到hook。有人问我，能不能改变一个进程的数据处理行为，我曾经告诉他：能，也不能！感觉告诉我，hook绝大多数场合下是一种“不礼貌”的行为。曾有一段时间，我的服务器，经常有人悄悄地近来，给我增加许多超级用户，肆意修改我的管理权限，我找到托管商，解决了这个问题，那时，我也买了几本服务器监听、安全方面的书，看了几天，我就放弃了，为什么？担心学坏（正、邪仅在一念之差），其实，每个服务器都很脆弱，对有经验的系统程序员而言，安全性与道德准则是联系在一起的，软件技术上走邪路很容易，有时我会想，如果我去设计病毒或者当黑客，会怎样？基础数学出身的我，数论、组合学、密码理论统统不是问题，Windows虚拟驱动程序开发，也不是问题！为什么那么多的人关心hook？国人的正道软件寥寥无几，可破解术却出神入化，可惜，可惜！hook是一种底层的编成机制，能理解好hook的人，完全具备掌握一流技术的底蕴，真希望回头…… 

　　MFC的批判 

　　记得梁羽生先生笔下有一位正邪兼修的高手，名曰“乔北溟”（好像是这个名字），一次此人与大侠张丹枫在一个庙中相遇，乔北溟随手操起香案上的香炉，张丹枫问他：“你的家伙称手吗?” ，乔北溟笑答：“以吾辈之见识，还在意手中之物是否为剑？”，张丹枫一愣，心中暗念，此人果然不同凡响…… 


☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 21:37:09 2005)  提到:

说起MFC，许多人都会撇撇嘴，高手们会对其提出许多尖锐的批评，例如，刻板的Document-View机制，繁复的框架结构，怪异的COM实现以及令人莫名其妙的宏，等等。MFC的大而全，不仅捆住了MFC开发组的手脚，也为全面掌握MFC的愿望设置了障碍。高手们批评之余，可能忽略了一个基本的事实，这个事实就是，你的批评来自于你对MFC的深入理解，当许多人指出MFC的种种弱点时，他们或许不愿意承认：他们的技高一筹、见识超人一等是MFC带来的，不止一次有人与我谈及：“MFC的COM实现，实在差劲，看看ATL（不容否认，ATL至今仍然是开发COM的最佳C++类库），你就会感觉MFC的臃肿……”，我们中的许多人潜意识里不知不觉的在作一件事：“当我们借助一部梯子登上一层楼的时候，我们会评价这个梯子是如何如何之糟糕。”1999年，我的一个项目中需要一个描述引擎，VBS（Visual Basic Script），是个免费的语言引擎，但功能局限极大，我联系了美国的Summit公司，他们很快寄来了Microsoft的Visual Basic for Application SDK 6.0，当时我的团队可谓很强，其中的几位研究生C++修养很好，拿到VBA SDK时，他们对我说：“应当没问题，我们很快就会搞定VBA SDK”，可是几天过去了，连个例子都没出来，原来，虽然VBA SDK提供了MFC扩展类库（基于模版机制的MFC/ATL合成类库），可实现得极其别扭，我接手后的当天晚上，VBA 的IDE就集成到系统中，第二天可编程对象顺利出现在VBA 的IDE中，其余人觉得很奇怪，一看代码，原来我绕过Microsoft的例子，完全是另外的实现途径，那个时候，我感觉到，Microsoft这个家伙真的可恶，本来清晰的集成途径，却人为的让你绕来绕去增加技术难度，过后想想，也可以理解，不这样，第三方的Summit何以作技术支持？我经常想，如果没有商业利益，许多技术应当十分简洁、高效，这一点，Microsoft以及其他大公司都十分明白，如果一切都是最佳的实现模式，可能就另外一种局面了，复变函数论中有一个著名的定理：“复平面上处处解析的函数一定是常值函数。”， 学生们很难理解，当时我说，如果把一个省几十个县的最好学生组成一个班会怎样？结果是一定有一个较差的学生（除非这个班只有一个学生！），这是个无法抗拒的定则，你想想，用天下最好的20个菜形成的酒席是什么味道？那一定是最差的！ 

　　Microsoft的MFC是值得你学习和使用的，如果你讨厌这个东西或者你认为这是个邪恶的东西，你学学乔北溟，实现正邪归一…… 



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 21:38:07 2005)  提到:

有感于“鸡兔同笼” 

　　小女初到北京时，对北京的教育颇为不适，铺天盖地的数学奥赛培训班向她压过来，孩子真是辛苦。她四年级时，就的对初等数论的基本内容进行强迫性的熟悉，还好，经过一段时间的努力，掌握了“鸡兔同笼”、“韩信点兵”等中国经典，马马虎虎的能证明费马小定理，有一天，她问我：“爸爸，大学数学什么样？还有‘鸡兔同笼’吗？”，我说，有，我特意找了本老外写的《Basic Algebra》，找到其中的“中国剩余定理”，小孩子接着问道：“这本书中还有中国人的数学内容吗？”，我在习题中给她找到华罗庚老先生的“反同构定理”，小孩子又接着问：“还有吗？”，我感到很没面子，因为真的找不到了…… 

　　曾经的一个梦，就是当一个数学家！为此，研究生时期买了大量的数学书，当时我们系的资料室是联合国教科文组织的藏书室，可以说，里面就是一个装满武功秘籍的宝库。有一天我们打扫资料室的一个仓库，仓库里全是鼓鼓囊囊的麻袋包，上面落满灰尘，手触摸一下，能粘出几毫米厚的灰尘，可以想象有几年没有打扫了。同学无意中揭开一个麻袋，我们惊呆了，里面是美国60年代各大学的数学杂志，每个杂志的名字都是响当当的，那真叫浩如烟海！当时我们就想，我们的论文能发表到其中吗？如果侥幸发了几篇，可想而知，我们就可以当博导了，这些比国内所谓核心期刊有分量得多的杂志，就像CSDN上的帖子一样，很快就会被淹没了，也许很久都不会有人参考、访问……，有一天，我也当了老师，面临着种种考核，于是，我们就成了论文机器，不论是否有价值，只要是核心的，你就高人一等。那个时候，我经常想起那些麻袋里的文献…… 

　　我们整体水平的落后，导致整体的浮躁，数量上上去了，质量却下来了。若干年后，也许我成熟了，我们这些曾经站在大学讲坛上的人，没什么好的东西讲（谈不上 ‘教’）给年轻的学生，记得当年我校的计算中心计划招个培训班，几天过去，仅有7人报名，第8人来时，前7人就退了3人，主任感到奇怪，问学生，学生不语，其中原委并不复杂。我发此帖并没有精心策划，的确如某些网友所言是随感而发，“鸡兔同笼”、“勾股定理”已经有了历史地位，如果仅仅够用，我们住草房子一样保暖，为何建大厦呢？为什么放弃传统的长袍、马褂而去穿西装革履？病毒软件大战几乎是自杀性的内战，没有撼动国外产品的分毫，我们许多人喜欢对自己人说三道四，是不是很少想一致对外？人家卖我们打折的产品，条件是附加一份“忏悔书”，而执行者却是我们国人，为什么？因为我们的东西匮乏！当年别人用钢铁武器掠夺了我们的财富，他们强大了，地痞无赖换上了绅士面孔，讲起了法律，当你用D版时，人家文明的指责你，你的人力、财力、物力统统为人所用，取之于你用之于你，而我们却依然陶醉在“鸡兔同笼”、“勾股定理”的历史成就之中，我们依然喜欢争论“勾股定理”谁发现得更早，π是谁最先精确计算的，就像谈论C++谁的水平更高一样。


☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 21:38:49 2005)  提到:

想起西太后……

　　据说，西太后垂帘时期，洋人曾送给她一量火车，慈禧看过后，大骇，以为妖魔……。火车进入中国，最初可能也是引起争议的，大多数百姓都对此怀有惧怕的心理，时间长了，也就自然而然的接受了。

　　想想Windows，最早也就是1983-1984年间出生的，到现在充其量也就20几岁，Linux大概比Windows小十岁。Windows来自一个贵族家庭，家长是Microsoft；Linux来自一个单身“母亲”，成长环境是一个社会，正可谓一个是贵族娇儿、一个是山野村夫。在洋人的世界里，Windows与Linux正如火如荼的争斗着，就跟人类历史上贵族与平民之间的争斗一样。我们很看不惯许多贵族娇儿，往往拿平民子弟的良好习惯与之比较，这一点都不奇怪。然而，我们平民阶层却有培养贵族的愿望，Linux社会也是如此，Linux社会已经分化出许多贵族了，为了各自的利益，面和心不和的联盟不知结了多少回，历史告诉我们，如果Windows死了而且如果Linux社会繁荣了，Linux社会就会出现一个贵族来接替Windows（叫不叫Windows无所谓，改朝换代吗）。某次，与国内一著名软件研究所的几个朋友一起进餐，谈到了Linux，话题自然很多，话题之一就是中国的Linux，朋友们笑曰：“……，自主知识产权的操作系统，也就是对开源代码内核的汉化，……”。人们可以列举许多关于Linux的强大之处，比如著名的电影《泰坦尼克》的特技制作，高性能计算Linux操作系统占据绝对主动等等……，其实对了解Linux的人而言，这一点并不奇怪：为某一特定的任务定制的Linux很容易剔除许多不必要的服务，这就好比轻装上阵，事实上，如果可以将许许多多的不必要的“虚拟”服务卸掉，Windows的性能并不差（Windows要加载许多虚拟服务），其实，即使Linux专家也承认，如果Windows允许向Linux一样可以按要求订制，许多弱点也许就不存在了，但市场也就是另一回事了。

　　回到我们国人的立场，本人以为，没必要太多的对比Windows、Linux，如果我们Linux领域很强或者我们创造了Linux（毕竟这些都是洋玩意儿），倒也罢了，事实上，我们在Linux领域也不比Windows领域光彩多少，我们的许多人愿意用Linux说话，可是我们在Linux上拿出让我们立足的工作了吗？看看Linux社区就知道了！我们为什么不能把Windows、Linux都当作进入中国的两种新型火车而客观对待呢？在外交礼仪、航海公约以及种种标准等方面，我们已经潜移默化的接受了，为什么？因为我们弱势。Linux也是别人的，与Windows没什么区别。我们真正应该做的，是接受并使自己强大，许多网友给我回信，认为我的观点偏激或奉Microsoft为神，其实不对！只有认识一个强大的令你敬佩的敌人，你才有激情去强大自己。谈论Microsoft越多，其实客观上是对其承认越深，如果Microsoft不够强，就没必要拿它说话或对比，Microsoft给世界带来太多的负担，任何一个操作系统想战胜它，前提是必须兼容它给这个世界已经带来的积累，因此Microsoft很可能是无疾而终，铁木真的王国，是巨大无比的（据说他要讨伐一个对象，路上要在他的疆土内走上一年的时间），可并没有谁灭了这个王国，是自己灭的。我们认为铁木真是中国历史上的人物，可是有些国家认为是他们历史上的人物。其实只要客观对待Windows、Linux，能够正确定位他们的应用环节，Windows、Linux就都是好的东西！



☆─────────────────────────────────────☆
   flyuphigh (北邮人) 于  (Mon Jun  6 21:39:31 2005)  提到:

我们应当更多的看到，IBM、Microsoft等的崛起，是公司行为，这些公司为美国创造的不仅仅是辉煌，而是国力！我们的软件，依赖国家行为的投资（我们的软件研究所拿出什么来了？），靠国家的资助，却抱怨别人在垄断，多可笑！我们应当搞清楚我们在食物链中的层次，然后再指责别人。你不强大，你就受人欺负，拳头是硬道理。看看我们的北大青鸟，如果你看了他们的组件工厂的论述，你会觉得这是世界上最好的东西，可是你看到市场上北大青鸟在干嘛？我们有太多的自欺欺人的东西，有太多的世界领先、国内首创的鉴定，可是回头来，我们不得不清醒了……
如果大家有好的建议，请与我联系（sunhui@mail.apptemplate.com、sunhuizlz@yeah.net）,如果有北京的朋友肯帮忙协助，在下不胜感激，希望得到大家的支持！


 【文章标题】：[ZT]C++风格与技巧 【文章地址】：https://bbs.byr.cn/article/SoftDesign/104 【创建时间】：2005-04-27 【作者】：UnrealT 【评论】：0 【内容】：发信人: UnrealT (wahaha), 信区: SoftDesign
标  题: [ZT]C++风格与技巧
发信站: 北邮人论坛 (Wed Apr 27 20:49:59 2005), 站内

C++风格与技巧

（译注：本文的翻译相当艰苦。Bjarne Stroustrup不愧是创立C++语言的一代大师，不但思想博大精深，而且在遣词造句上，也非常精微深奥。有很多地方，译者反复斟酌，都不能取得理想的效果，只能尽力而为。 

Html格式的文档见译者主页：<a target="_blank" href="http://www.wushuang.net">http://www.wushuang.net</a>

如果你对这个翻译稿有任何意见和建议，请发信给译者：onekey@163.com。

原文的地址为：<a target="_blank" href="http://www.research.att.com/~bs/bs_faq.html">http://www.research.att.com/~bs/bs_faq.html</a>）


（Bjarne Stroustrup博士，1950年出生于丹麦，先后毕业于丹麦阿鲁斯大学和英国剑挢大学，AT&amp;T大规模程序设计研究部门负责人，AT&amp;T 贝尔实验室和ACM成员。1979年，B. S开始开发一种语言，当时称为"C with Class"，后来演化为C++。1998年，ANSI/ISO C++标准建立，同年，B. S推出其经典著作The C++ Programming Language的第三版。）


这是一些人们经常向我问起的有关C++的风格与技巧的问题。如果你能提出更好的问题，或者对这些答案有所建议，请务必发Email给我(bs@research.att.com)。请记住，我不能把全部的时间都花在更新我的主页上面。


更多的问题请参见我的general FAQ。


关于术语和概念，请参见我的C++术语表（C++ glossary.）。


请注意，这仅仅是一个常见问题与解答的列表。它不能代替一本优秀教科书中那些经过精心挑选的范例与解释。它也不能象一本参考手册或语言标准那样，提供详细和准确的说明。有关C++的设计的问题，请参见《C++语言的设计和演变》（The Design and Evolution of C++）。关于C++语言与标准库的使用，请参见《C++程序设计语言》（The C++ Programming Language）。


目录：

我如何写这个非常简单的程序？

为什么编译要花这么长的时间？

为什么一个空类的大小不为0？

我必须在类声明处赋予数据吗？

为什么成员函数默认不是virtual的？

为什么析构函数默认不是virtual的？

为什么不能有虚拟构造函数？

为什么重载在继承类中不工作？

我能够在构造函数中调用一个虚拟函数吗？

有没有“指定位置删除”(placement delete)？

我能防止别人继承我自己的类吗？

为什么不能为模板参数定义约束（constraints）？

既然已经有了优秀的qsort()函数，为什么还需要一个sort()？

什么是函数对象（function object）？

我应该如何对付内存泄漏？

我为什么在捕获一个异常之后就不能继续？

为什么C++中没有相当于realloc()的函数？

如何使用异常？

怎样从输入中读取一个字符串？

为什么C++不提供“finally”的构造？

什么是自动指针（auto_ptr），为什么没有自动数组（auto_array）？

可以混合使用C风格与C++风格的内存分派与重新分配吗？

我为什么必须使用一个造型来转换*void？

我如何定义一个类内部（in-class）的常量？

为什么delete不会将操作数置0？

我能够写“void main()”吗？

为什么我不能重载点符号，::，sizeof，等等？

怎样将一个整型值转换为一个字符串？

“int* p”正确还是“int *p”正确？

对于我的代码，哪一种布局风格（layout style）是最好的？

我应该将“const”放在类型之前还是之后？

使用宏有什么问题？


我如何写这个非常简单的程序？


特别是在一个学期的开始，我常常收到许多关于编写一个非常简单的程序的询问。这个问题有一个很具代表性的解决方法，那就是（在你的程序中）读入几个数字，对它们做一些处理，再把结果输出。下面是一个这样做的例子：


#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;algorithm&gt;

using namespace std;


int main()

{

vector&lt;double&gt; v;


double d;

while(cin&gt;&gt;d) v.push_back(d); // 读入元素

if (!cin.eof()) { // 检查输入是否出错

cerr &lt;&lt; "format error\n";

return 1; // 返回一个错误

}


cout &lt;&lt; "read " &lt;&lt; v.size() &lt;&lt; " elements\n";


reverse(v.begin(),v.end());

cout &lt;&lt; "elements in reverse order:\n";

for (int i = 0; i&lt;v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\n';


return 0; // 成功返回

}


对这段程序的观察：


这是一段标准的ISO C++程序，使用了标准库(standard library)。标准库工具在命名空间std中声明，封装在没有.h后缀的头文件中。


如果你要在Windows下编译它，你需要将它编译成一个“控制台程序”（console application）。记得将源文件加上.cpp后缀，否则编译器可能会以为它是一段C代码而不是C++。


是的，main()函数返回一个int值。


读到一个标准的向量(vector)中，可以避免在随意确定大小的缓冲中溢出的错误。读到一个数组(array)中，而不产生“简单错误”(silly error)，这已经超出了一个新手的能力——如果你做到了，那你已经不是一个新手了。如果你对此表示怀疑，我建议你阅读我的文章“将标准C++作为一种新的语言来学习”("Learning Standard C++ as a New Language")，你可以在本人著作列表(my publications list)中下载到它。


!cin.eof()是对流的格式的检查。事实上，它检查循环是否终结于发现一个end-of-file(如果不是这样，那么意味着输入没有按照给定的格式)。更多的说明，请参见你的C++教科书中的“流状态”(stream state)部分。


vector知道它自己的大小，因此我不需要计算元素的数量。


这段程序没有包含显式的内存管理。Vector维护一个内存中的栈，以存放它的元素。当一个vector需要更多的内存时，它会分配一些；当它不再生存时，它会释放内存。于是，使用者不需要再关心vector中元素的内存分配和释放问题。


程序在遇到输入一个“end-of-file”时结束。如果你在UNIX平台下运行它，“end-of-file”等于键盘上的Ctrl+D。如果你在Windows平台下，那么由于一个BUG它无法辨别“end-of-file”字符，你可能倾向于使用下面这个稍稍复杂些的版本，它使用一个词“end”来表示输入已经结束。


#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;algorithm&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

vector&lt;double&gt; v;


double d;

while(cin&gt;&gt;d) v.push_back(d); // 读入一个元素

if (!cin.eof()) { // 检查输入是否失败

cin.clear(); // 清除错误状态

string s;

cin &gt;&gt; s; // 查找结束字符

if (s != "end") {

cerr &lt;&lt; "format error\n";

return 1; // 返回错误

}

}


cout &lt;&lt; "read " &lt;&lt; v.size() &lt;&lt; " elements\n";


reverse(v.begin(),v.end());

cout &lt;&lt; "elements in reverse order:\n";

for (int i = 0; i&lt;v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\n';


return 0; // 成功返回

}


更多的关于使用标准库将事情简化的例子，请参见《C++程序设计语言》中的“漫游标准库”("Tour of the Standard Library")一章。


为什么编译要花这么长的时间？


你的编译器可能有问题。也许它太老了，也许你安装它的时候出了错，也许你用的计算机已经是个古董。在诸如此类的问题上，我无法帮助你。


但是，这也是很可能的：你要编译的程序设计得非常糟糕，以至于编译器不得不检查数以百计的头文件和数万行代码。理论上来说，这是可以避免的。如果这是你购买的库的设计问题，你对它无计可施（除了换一个更好的库），但你可以将你自己的代码组织得更好一些，以求得将修改代码后的重新编译工作降到最少。这样的设计会更好，更有可维护性，因为它们展示了更好的概念上的分离。


看看这个典型的面向对象的程序例子：


class Shape {

public: // 使用Shapes的用户的接口

virtual void draw() const;

virtual void rotate(int degrees);

// ...

protected: // common data (for implementers of Shapes)

Point center;

Color col;

// ...

};


class Circle : public Shape {

public: 

void draw() const;

void rotate(int) { }

// ...

protected:

int radius;

// ...

};


class Triangle : public Shape {

public: 

void draw() const;

void rotate(int);

// ...

protected:

Point a, b, c;

// ...

}; 


设计思想是，用户通过Shape的public接口来操纵它们，而派生类（例如Circle和Triangle）的实现部分则共享由protected成员表现的那部分实现（implementation）。


这不是一件容易的事情：确定哪些实现部分是对所有的派生类都有用的，并将之共享出来。因此，与public接口相比，protected成员往往要做多得多的改动。举例来说，虽然理论上“中心”(center)对所有的图形都是一个有效的概念，但当你要维护一个三角形的“中心”的时候，是一件非常麻烦的事情——对于三角形，当且仅当它确实被需要的时候，计算这个中心才是有意义的。


protected成员很可能要依赖于实现部分的细节，而Shape的用户（译注：user此处译为用户，指使用Shape类的代码，下同）却不见得必须依赖它们。举例来说，很多（大多数？）使用Shape的代码在逻辑上是与“颜色”无关的，但是由于Shape中“颜色”这个定义的存在，却可能需要一堆复杂的头文件，来结合操作系统的颜色概念。


当protected部分发生了改变时，使用Shape的代码必须重新编译——即使只有派生类的实现部分才能够访问protected成员。


于是，基类中的“实现相关的信息”(information helpful to implementers)对用户来说变成了象接口一样敏感的东西，它的存在导致了实现部分的不稳定，用户代码的无谓的重编译（当实现部分发生改变时），以及将头文件无节制地包含进用户代码中（因为“实现相关的信息”需要它们）。有时这被称为“脆弱的基类问题”(brittle base class problem)。


一个很明显的解决方案就是，忽略基类中那些象接口一样被使用的“实现相关的信息”。换句话说，使用接口，纯粹的接口。也就是说，用抽象基类的方式来表示接口：


class Shape {

public: //使用Shapes的用户的接口

virtual void draw() const = 0;

virtual void rotate(int degrees) = 0;

virtual Point center() const = 0;

// ...


// 没有数据

};


class Circle : public Shape {

public: 

void draw() const;

void rotate(int) { }

Point center() const { return center; }

// ...

protected:

Point cent;

Color col;

int radius;

// ...

};


class Triangle : public Shape {

public: 

void draw() const;

void rotate(int);

Point center() const;

// ...

protected:

Color col;

Point a, b, c;

// ...

}; 


现在，用户代码与派生类的实现部分的变化之间的关系被隔离了。我曾经见过这种技术使得编译的时间减少了几个数量级。


但是，如果确实存在着对所有派生类（或仅仅对某些派生类）都有用的公共信息时怎么办呢？可以简单把这些信息封装成类，然后从它派生出实现部分的类：


class Shape {

public: //使用Shapes的用户的接口

virtual void draw() const = 0;

virtual void rotate(int degrees) = 0;

virtual Point center() const = 0;

// ...


// no data

};


struct Common {

Color col;

// ...

};


class Circle : public Shape, protected Common {

public: 

void draw() const;

void rotate(int) { }

Point center() const { return center; }

// ...

protected:

Point cent;

int radius;

};


class Triangle : public Shape, protected Common {

public: 

void draw() const;

void rotate(int);

Point center() const;

// ...

protected:

Point a, b, c;

}; 


为什么一个空类的大小不为0？


要清楚，两个不同的对象的地址也是不同的。基于同样的理由，new总是返回指向不同对象的指针。

看看：


class Empty { };


void f()

{

Empty a, b;

if (&amp;a == &amp;b) cout &lt;&lt; "impossible: report error to compiler supplier";


Empty* p1 = new Empty;

Empty* p2 = new Empty;

if (p1 == p2) cout &lt;&lt; "impossible: report error to compiler supplier";

} 


有一条有趣的规则：一个空的基类并不一定有分隔字节。

struct X : Empty {

int a;

// ...

};


void f(X* p)

{

void* p1 = p;

void* p2 = &amp;p-&gt;a;

if (p1 == p2) cout &lt;&lt; "nice: good optimizer";

}


这种优化是允许的，可以被广泛使用。它允许程序员使用空类以表现一些简单的概念。现在有些编译器提供这种“空基类优化”(empty base class optimization)。


我必须在类声明处赋予数据吗？


不必须。如果一个接口不需要数据时，无须在作为接口定义的类中赋予数据。代之以在派生类中给出它们。参见“为什么编译要花这么长的时间？”。


有时候，你必须在一个类中赋予数据。考虑一下复数类的情况：


template&lt;class Scalar&gt; class complex {

public:

complex() : re(0), im(0) { }

complex(Scalar r) : re(r), im(0) { }

complex(Scalar r, Scalar i) : re(r), im(i) { }

// ...


complex&amp; operator+=(const complex&amp; a)

{ re+=a.re; im+=a.im; return *this; }

// ...

private:

Scalar re, im;

};


设计这种类型的目的是将它当做一个内建（built-in）类型一样被使用。在声明处赋值是必须的，以保证如下可能：建立真正的本地对象（genuinely local objects）(比如那些在栈中而不是在堆中分配的对象)，或者使某些简单操作被适当地inline化。对于那些支持内建的复合类型的语言来说，要获得它们提供的效率，真正的本地对象和inline化都是必要的。


为什么成员函数默认不是virtual的？


因为很多类并不是被设计作为基类的。例如复数类。


而且，一个包含虚拟函数的类的对象，要占用更多的空间以实现虚拟函数调用机制——往往是每个对象占用一个字(word)。这个额外的字是非常可观的，而且在涉及和其它语言的数据的兼容性时，可能导致麻烦(例如C或Fortran语言)。


要了解更多的设计原理，请参见《C++语言的设计和演变》（The Design and Evolution of C++）。


为什么析构函数默认不是virtual的？


因为很多类并不是被设计作为基类的。只有类在行为上是它的派生类的接口时(这些派生类往往在堆中分配，通过指针或引用来访问)，虚拟函数才有意义。


那么什么时候才应该将析构函数定义为虚拟呢？当类至少拥有一个虚拟函数时。拥有虚拟函数意味着一个类是派生类的接口，在这种情况下，一个派生类的对象可能通过一个基类指针来销毁。例如：


class Base {

// ...

virtual ~Base();

};


class Derived : public Base {

// ...

~Derived();

};


void f()

{

Base* p = new Derived;

delete p; // 虚拟析构函数保证~Derived函数被调用

}


如果基类的析构函数不是虚拟的，那么派生类的析构函数将不会被调用——这可能产生糟糕的结果，例如派生类的资源不会被释放。


为什么不能有虚拟构造函数？


虚拟调用是一种能够在给定信息不完全(given partial information)的情况下工作的机制。特别地，虚拟允许我们调用某个函数，对于这个函数，仅仅知道它的接口，而不知道具体的对象类型。但是要建立一个对象，你必须拥有完全的信息。特别地，你需要知道要建立的对象的具体类型。因此，对构造函数的调用不可能是虚拟的。


当要求建立一个对象时，一种间接的技术常常被当作“虚拟构造函数”来使用。有关例子，请参见《C++程序设计语言》第三版15.6.2.节。


下面这个例子展示一种机制：如何使用一个抽象类来建立一个适当类型的对象。


struct F { // 对象建立函数的接口

virtual A* make_an_A() const = 0;

virtual B* make_a_B() const = 0;

};


void user(const F&amp; fac)

{

A* p = fac.make_an_A(); // 将A作为合适的类型

B* q = fac.make_a_B(); // 将B作为合适的类型

// ...

}


struct FX : F {

A* make_an_A() const { return new AX(); } // AX是A的派生

B* make_a_B() const { return new BX(); } // AX是B的派生

};


struct FY : F {

A* make_an_A() const { return new AY(); } // AY是A的派生

B* make_a_B() const { return new BY(); } // BY是B的派生


};


int main()

{

user(FX()); // 此用户建立AX与BX

user(FY()); // 此用户建立AY与BY

// ...

}


这是所谓的“工厂模式”(the factory pattern)的一个变形。关键在于，user函数与AX或AY这样的类的信息被完全分离开来了。


为什么重载在继承类中不工作？


这个问题（非常常见）往往出现于这样的例子中：


#include&lt;iostream&gt;

using namespace std;


class B {

public:

int f(int i) { cout &lt;&lt; "f(int): "; return i+1; }

// ...

};


class D : public B {

public:

double f(double d) { cout &lt;&lt; "f(double): "; return d+1.3; }

// ...

};


int main()

{

D* pd = new D;


cout &lt;&lt; pd-&gt;f(2) &lt;&lt; '\n';

cout &lt;&lt; pd-&gt;f(2.3) &lt;&lt; '\n';

}


它输出的结果是：


f(double): 3.3

f(double): 3.6


而不是象有些人猜想的那样：


f(int): 3

f(double): 3.6


换句话说，在B和D之间并没有发生重载的解析。编译器在D的区域内寻找，找到了一个函数double f(double)，并执行了它。它永远不会涉及（被封装的）B的区域。在C++中，没有跨越区域的重载——对于这条规则，继承类也不例外。更多的细节，参见《C++语言的设计和演变》和《C++程序设计语言》。


但是，如果我需要在基类和继承类之间建立一组重载的f()函数呢？很简单，使用using声明：


class D : public B {

public:

using B::f; // make every f from B available

double f(double d) { cout &lt;&lt; "f(double): "; return d+1.3; }

// ...

};


进行这个修改之后，输出结果将是：


f(int): 3

f(double): 3.6


这样，在B的f()和D的f()之间，重载确实实现了，并且选择了一个最合适的f()进行调用。


我能够在构造函数中调用一个虚拟函数吗？


可以，但是要小心。它可能不象你期望的那样工作。在构造函数中，虚拟调用机制不起作用，因为继承类的重载还没有发生。对象先从基类被创建，“基类先于继承类(base before derived)”。


看看这个：


#include&lt;string&gt;

#include&lt;iostream&gt;

using namespace std;


class B {

public:

B(const string&amp; ss) { cout &lt;&lt; "B constructor\n"; f(ss); }

virtual void f(const string&amp;) { cout &lt;&lt; "B::f\n";}

};


class D : public B {

public:

D(const string &amp; ss) :B(ss) { cout &lt;&lt; "D constructor\n";}

void f(const string&amp; ss) { cout &lt;&lt; "D::f\n"; s = ss; }

private:

string s;

};


int main()

{

D d("Hello");

}


程序编译以后会输出：


B constructor

B::f

D constructor


注意不是D::f。设想一下，如果出于不同的规则，B::B()可以调用D::f()的话，会产生什么样的后果：因为构造函数D::D()还没有运行，D::f()将会试图将一个还没有初始化的字符串s赋予它的参数。结果很可能是导致立即崩溃。


析构函数在“继承类先于基类”的机制下运行，因此虚拟机制的行为和构造函数一样：只有本地定义(local definitions)被使用——不会调用虚拟函数，以免触及对象中的（现在已经被销毁的）继承类的部分。


更多的细节，参见《C++语言的设计和演变》13.2.4.2和《C++程序设计语言》15.4.3。


有人暗示，这只是一条实现时的人为制造的规则。不是这样的。事实上，要实现这种不安全的方法倒是非常容易的：在构造函数中直接调用虚拟函数，就象调用其它函数一样。但是，这样就意味着，任何虚拟函数都无法编写了，因为它们需要依靠基类的固定的创建(invariants established by base classes)。这将会导致一片混乱。


有没有“指定位置删除”(placement delete)？


没有，不过如果你需要的话，可以自己写一个。


看看这个指定位置创建(placement new)，它将对象放进了一系列Arena中；


class Arena {

public:

void* allocate(size_t);

void deallocate(void*);

// ...

};


void* operator new(size_t sz, Arena&amp; a)

{

return a.allocate(sz);

}


Arena a1(some arguments);

Arena a2(some arguments);


这样实现了之后，我们就可以这么写：


X* p1 = new(a1) X;

Y* p2 = new(a1) Y;

Z* p3 = new(a2) Z;

// ...


但是，以后怎样正确地销毁这些对象呢？没有对应于这种“placement new”的内建的“placement delete”，原因是，没有一种通用的方法可以保证它被正确地使用。在C++的类型系统中，没有什么东西可以让我们确认，p1一定指向一个由Arena类型的a1分派的对象。p1可能指向任何东西分派的任何一块地方。


然而，有时候程序员是知道的，所以这是一种方法：


template&lt;class T&gt; void destroy(T* p, Arena&amp; a)

{

if (p) {

p-&gt;~T(); // explicit destructor call

a.deallocate(p);

}

}


现在我们可以这么写：


destroy(p1,a1);

destroy(p2,a2);

destroy(p3,a3);


如果Arena维护了它保存着的对象的线索，你甚至可以自己写一个析构函数，以避免它发生错误。


这也是可能的：定义一对相互匹配的操作符new()和delete()，以维护《C++程序设计语言》15.6中的类继承体系。参见《C++语言的设计和演变》10.4和《C++程序设计语言》19.4.5。


我能防止别人继承我自己的类吗？


可以，但你为什么要那么做呢？这是两个常见的回答：


效率：避免我的函数被虚拟调用

安全：保证我的类不被用作一个基类（例如，保证我能够复制对象而不用担心出事）


根据我的经验，效率原因往往是不必要的担心。在C++中，虚拟函数调用是如此之快，以致于它们在一个包含虚拟函数的类中被实际使用时，相比普通的函数调用，根本不会产生值得考虑的运行期开支。注意，仅仅通过指针或引用时，才会使用虚拟调用机制。当直接通过对象名字调用一个函数时，虚拟函数调用的开支可以被很容易地优化掉。


如果确实有真正的需要，要将一个类封闭起来以防止虚拟调用，那么可能首先应该问问为什么它们是虚拟的。我看见过一些例子，那些性能表现不佳的函数被设置为虚拟，没有其他原因，仅仅是因为“我们习惯这么干”。


这个问题的另一个部分，由于逻辑上的原因如何防止类被继承，有一个解决方案。不幸的是，这个方案并不完美。它建立在这样一个事实的基础之上，那就是：大多数的继承类必须建立一个虚拟的基类。这是一个例子：


class Usable;


class Usable_lock {

friend class Usable;

private:

Usable_lock() {}

Usable_lock(const Usable_lock&amp;) {}

};


class Usable : public virtual Usable_lock {

// ...

public:

Usable();

Usable(char*);

// ...

};


Usable a;


class DD : public Usable { };


DD dd; // 错误: DD::DD() 不能访问

// Usable_lock::Usable_lock()是一个私有成员


(来自《C++语言的设计和演变》11.4.3)


为什么不能为模板参数定义约束（constraints）？


可以的，而且方法非常简单和通用。


看看这个：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


如果出现类型错误，可能是发生在相当复杂的for_each()调用时。例如，如果容器的元素类型是int，我们将得到一个和for_each()相关的含义模糊的错误(因为不能够对对一个int值调用Shape::draw的方法)。


为了提前捕捉这个错误，我这样写：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

Shape* p = c.front(); // accept only containers of Shape*s


for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


对于现在的大多数编译器，中间变量p的初始化将会触发一个易于了解的错误。这个窍门在很多语言中都是通用的，而且在所有的标准创建中都必须这样做。在成品的代码中，我也许可以这样写：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

typedef typename Container::value_type T;

Can_copy&lt;T,Shape*&gt;(); // accept containers of only Shape*s


for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


这样就很清楚了，我在建立一个断言(assertion)。Can_copy模板可以这样定义：


template&lt;class T1, class T2&gt; struct Can_copy {

static void constraints(T1 a, T2 b) { T2 c = a; b = a; }

Can_copy() { void(*p)(T1,T2) = constraints; }

};


Can_copy(在运行时)检查T1是否可以被赋值给T2。Can_copy&lt;T,Shape*&gt;检查T是否是Shape*类型，或者是一个指向由Shape类公共继承而来的类的对象的指针，或者是被用户转换到Shape*类型的某个类型。注意这个定义被精简到了最小：


一行命名要检查的约束，和要检查的类型

一行列出指定的要检查的约束(constraints()函数)

一行提供触发检查的方法(通过构造函数)


注意这个定义有相当合理的性质：


你可以表达一个约束，而不用声明或复制变量，因此约束的编写者可以用不着去设想变量如何被初始化，对象是否能够被复制，被销毁，以及诸如此类的事情。(当然，约束要检查这些属性的情况时例外。)

使用现在的编译器，不需要为约束产生代码

定义和使用约束，不需要使用宏

当约束失败时，编译器会给出可接受的错误信息，包括“constraints”这个词（给用户一个线索），约束的名字，以及导致约束失败的详细错误（例如“无法用double*初始化Shape*”）。


那么，在C++语言中，有没有类似于Can_copy——或者更好——的东西呢？在《C++语言的设计和演变》中，对于在C++中实现这种通用约束的困难进行了分析。从那以来，出现了很多方法，来让约束类变得更加容易编写，同时仍然能触发良好的错误信息。例如，我信任我在Can_copy中使用的函数指针的方式，它源自Alex Stepanov和Jeremy Siek。我并不认为Can_copy()已经可以标准化了——它需要更多的使用。同样，在C++社区中，各种不同的约束方式被使用；到底是哪一种约束模板在广泛的使用中被证明是最有效的，还没有达成一致的意见。


但是，这种方式非常普遍，比语言提供的专门用于约束检查的机制更加普遍。无论如何，当我们编写一个模板时，我们拥有了C++提供的最丰富的表达力量。看看这个：


template&lt;class T, class B&gt; struct Derived_from {

static void constraints(T* p) { B* pb = p; }

Derived_from() { void(*p)(T*) = constraints; }

};


template&lt;class T1, class T2&gt; struct Can_copy {

static void constraints(T1 a, T2 b) { T2 c = a; b = a; }

Can_copy() { void(*p)(T1,T2) = constraints; }

};


template&lt;class T1, class T2 = T1&gt; struct Can_compare {

static void constraints(T1 a, T2 b) { a==b; a!=b; a&lt;b; }

Can_compare() { void(*p)(T1,T2) = constraints; }

};


template&lt;class T1, class T2, class T3 = T1&gt; struct Can_multiply {

static void constraints(T1 a, T2 b, T3 c) { c = a*b; }

Can_multiply() { void(*p)(T1,T2,T3) = constraints; }

};


struct B { };

struct D : B { };

struct DD : D { };

struct X { };


int main()

{

Derived_from&lt;D,B&gt;();

Derived_from&lt;DD,B&gt;();

Derived_from&lt;X,B&gt;();

Derived_from&lt;int,B&gt;();

Derived_from&lt;X,int&gt;();


Can_compare&lt;int,float&gt;();

Can_compare&lt;X,B&gt;();

Can_multiply&lt;int,float&gt;();

Can_multiply&lt;int,float,double&gt;();

Can_multiply&lt;B,X&gt;();


Can_copy&lt;D*,B*&gt;();

Can_copy&lt;D,B*&gt;();

Can_copy&lt;int,B*&gt;();

}


// 典型的“元素必须继承自Mybase*”约束:


template&lt;class T&gt; class Container : Derived_from&lt;T,Mybase&gt; {

// ...

};


事实上，Derived_from并不检查来源（derivation），而仅仅检查转换（conversion），不过这往往是一个更好的约束。为约束想一个好名字是很难的。


既然已经有了优秀的qsort()函数，为什么还需要一个sort()？


对于初学者来说，


qsort(array,asize,sizeof(elem),elem_compare);


看上去太古怪了，而且比这个更难理解：


sort(vec.begin(),vec.end());


对于专家来说，在元素与比较方式（comparison criteria）都相同的情况下，sort()比qsort()更快，这是很重要的。而且，qsort()是通用的，所以它可以用于不同容器类型、元素类型、比较方式的任意有意义的组合。举例来说：


struct Record {

string name;

// ...

};


struct name_compare { // 使用"name"作为键比较Record

bool operator()(const Record&amp; a, const Record&amp; b) const

{ return a.name&lt;b.name; }

};


void f(vector&lt;Record&gt;&amp; vs)

{

sort(vs.begin(), vs.end(), name_compare());

// ...

} 


而且，很多人欣赏sort()是因为它是类型安全的，使用它不需要进行造型（cast），没有人必须去为基本类型写一个compare()函数。


更多的细节，参见我的文章《将标准C++作为一种新的语言来学习》（Learning C++ as a New language），可以从我的文章列表中找到。


sort()胜过qsort()的主要原因是，比较操作在内联（inlines）上做得更好。


什么是函数对象（function object）？


顾名思义，就是在某种方式上表现得象一个函数的对象。典型地，它是指一个类的实例，这个类定义了应用操作符operator()。


函数对象是比函数更加通用的概念，因为函数对象可以定义跨越多次调用的可持久的部分（类似静态局部变量），同时又能够从对象的外面进行初始化和检查（和静态局部变量不同）。例如：


class Sum {

int val;

public:

Sum(int i) :val(i) { }

operator int() const { return val; } // 取得值


int operator()(int i) { return val+=i; } // 应用

};


void f(vector v)

{

Sum s = 0; // initial value 0

s = for_each(v.begin(), v.end(), s); // 求所有元素的和

cout &lt;&lt; "the sum is " &lt;&lt; s &lt;&lt; "\n";


//或者甚至：

cout &lt;&lt; "the sum is " &lt;&lt; for_each(v.begin(), v.end(), Sum(0)) &lt;&lt; "\n";

}


注意一个拥有应用操作符的函数对象可以被完美地内联化（inline），因为它没有涉及到任何指针，后者可能导致拒绝优化。与之形成对比的是，现有的优化器几乎不能（或者完全不能？）将一个通过函数指针的调用内联化。


在标准库中，函数对象被广泛地使用以获得弹性。


我应该如何对付内存泄漏？


写出那些不会导致任何内存泄漏的代码。很明显，当你的代码中到处充满了new 操作、delete操作和指针运算的话，你将会在某个地方搞晕了头，导致内存泄漏，指针引用错误，以及诸如此类的问题。这和你如何小心地对待内存分配工作其实完全没有关系：代码的复杂性最终总是会超过你能够付出的时间和努力。于是随后产生了一些成功的技巧，它们依赖于将内存分配（allocations）与重新分配（deallocation）工作隐藏在易于管理的类型之后。标准容器（standard containers）是一个优秀的例子。它们不是通过你而是自己为元素管理内存，从而避免了产生糟糕的结果。想象一下，没有string和vector的帮助，写出这个：


#include&lt;vector&gt;

#include&lt;string&gt;

#include&lt;iostream&gt;

#include&lt;algorithm&gt;

using namespace std;


int main() // small program messing around with strings

{

cout &lt;&lt; "enter some whitespace-separated words:\n";

vector&lt;string&gt; v;

string s;

while (cin&gt;&gt;s) v.push_back(s);


sort(v.begin(),v.end());


string cat;

typedef vector&lt;string&gt;::const_iterator Iter;

for (Iter p = v.begin(); p!=v.end(); ++p) cat += *p+"+";

cout &lt;&lt; cat &lt;&lt; '\n';

}


你有多少机会在第一次就得到正确的结果？你又怎么知道你没有导致内存泄漏呢？


注意，没有出现显式的内存管理，宏，造型，溢出检查，显式的长度限制，以及指针。通过使用函数对象和标准算法（standard algorithm），我可以避免使用指针——例如使用迭代子（iterator），不过对于一个这么小的程序来说有点小题大作了。


这些技巧并不完美，要系统化地使用它们也并不总是那么容易。但是，应用它们产生了惊人的差异，而且通过减少显式的内存分配与重新分配的次数，你甚至可以使余下的例子更加容易被跟踪。早在1981年，我就指出，通过将我必须显式地跟踪的对象的数量从几万个减少到几打，为了使程序正确运行而付出的努力从可怕的苦工，变成了应付一些可管理的对象，甚至更加简单了。


如果你的程序还没有包含将显式内存管理减少到最小限度的库，那么要让你程序完成和正确运行的话，最快的途径也许就是先建立一个这样的库。


模板和标准库实现了容器、资源句柄以及诸如此类的东西，更早的使用甚至在多年以前。异常的使用使之更加完善。


如果你实在不能将内存分配/重新分配的操作隐藏到你需要的对象中时，你可以使用资源句柄（resource handle），以将内存泄漏的可能性降至最低。这里有个例子：我需要通过一个函数，在空闲内存中建立一个对象并返回它。这时候可能忘记释放这个对象。毕竟，我们不能说，仅仅关注当这个指针要被释放的时候，谁将负责去做。使用资源句柄，这里用了标准库中的auto_ptr，使需要为之负责的地方变得明确了。


#include&lt;memory&gt;

#include&lt;iostream&gt;

using namespace std;


struct S {

S() { cout &lt;&lt; "make an S\n"; }

~S() { cout &lt;&lt; "destroy an S\n"; }

S(const S&amp;) { cout &lt;&lt; "copy initialize an S\n"; }

S&amp; operator=(const S&amp;) { cout &lt;&lt; "copy assign an S\n"; }

};


S* f()

{

return new S; // 谁该负责释放这个S？

};


auto_ptr&lt;S&gt; g()

{

return auto_ptr&lt;S&gt;(new S); // 显式传递负责释放这个S

}


int main()

{

cout &lt;&lt; "start main\n";

S* p = f();

cout &lt;&lt; "after f() before g()\n";

// S* q = g(); // 将被编译器捕捉

auto_ptr&lt;S&gt; q = g();

cout &lt;&lt; "exit main\n";

// *p产生了内存泄漏

// *q被自动释放

}


在更一般的意义上考虑资源，而不仅仅是内存。


如果在你的环境中不能系统地应用这些技巧（例如，你必须使用别的地方的代码，或者你的程序的另一部分简直是原始人类（译注：原文是Neanderthals，尼安德特人，旧石器时代广泛分布在欧洲的猿人）写的，如此等等），那么注意使用一个内存泄漏检测器作为开发过程的一部分，或者插入一个垃圾收集器（garbage collector）。


我为什么在捕获一个异常之后就不能继续？


换句话说，C++为什么不提供一种简单的方式，让程序能够回到异常抛出点之后，并继续执行？


主要的原因是，如果从异常处理之后继续，那么无法预知掷出点之后的代码如何对待异常处理，是否仅仅继续执行，就象什么也没有发生一样。异常处理者无法知道，在继续之前，有关的上下文环境（context）是否是“正确”的。要让这样的代码正确执行，抛出异常的编写者与捕获异常的编写者必须对彼此的代码与上下文环境都非常熟悉才行。这样会产生非常复杂的依赖性，因此无论在什么情况下，都会导致一系列严重的维护问题。


当我设计C++的异常处理机制时，我曾经认真地考虑过允许这种继续的可能性，而且在标准化的过程中，这个问题被非常详细地讨论过。请参见《C++语言的设计和演变》中的异常处理章节。


在一次新闻组的讨论中，我曾经以一种稍微不同的方式回答过这个问题。


为什么C++中没有相当于realloc()的函数？


如果你需要，你当然可以使用realloc()。但是，realloc()仅仅保证能工作于这样的数组之上：它们被malloc()（或者类似的函数）分配，包含一些没有用户定义的复制构造函数（copy constructors）的对象。而且，要记住，与通常的期望相反，realloc()有时也必须复制它的参数数组。


在C++中，处理内存重新分配的更好的方法是，使用标准库中的容器，例如vector，并让它自我增长。


如何使用异常？


参见《C++程序设计语言》第4章，第8.3节，以及附录E。这个附录针对的是如何在要求苛刻的程序中写出异常安全的代码的技巧，而不是针对初学者的。一个关键的技术是“资源获得即初始化”（resource acquisiton is initialization），它使用一些有析构函数的类，来实现强制的资源管理。


怎样从输入中读取一个字符串？


你可以用这种方式读取一个单独的以空格结束的词：


#include&lt;iostream&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

cout &lt;&lt; "Please enter a word:\n";


string s;

cin&gt;&gt;s;


cout &lt;&lt; "You entered " &lt;&lt; s &lt;&lt; '\n';

}


注意，这里没有显式的内存管理，也没有可能导致溢出的固定大小的缓冲区。


如果你确实想得到一行而不是一个单独的词，可以这样做：



#include&lt;iostream&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

cout &lt;&lt; "Please enter a line:\n";


string s;

getline(cin,s);


cout &lt;&lt; "You entered " &lt;&lt; s &lt;&lt; '\n';

}


在《C++程序设计语言》（可在线获得）的第3章，可以找到一个对诸如字符串与流这样的标准库工具的简介。对于使用C与C++进行简单输入输出的详细比较，参见我的文章《将标准C++作为一种新的语言来学习》(Learning Standard C++ as a New Language)，你可以在本人著作列表(my publications list)中下载到它。


为什么C++不提供“finally”的构造？


因为C++提供了另外一种方法，它几乎总是更好的：“资源获得即初始化”（resource acquisiton is initialization）技术。基本的思路是，通过一个局部对象来表现资源，于是局部对象的析构函数将会释放资源。这样，程序员就不会忘记释放资源了。举例来说：


class File_handle {

FILE* p;

public:

File_handle(const char* n, const char* a)

{ p = fopen(n,a); if (p==0) throw Open_error(errno); }

File_handle(FILE* pp)

{ p = pp; if (p==0) throw Open_error(errno); }


~File_handle() { fclose(p); }


operator FILE*() { return p; }


// ...

};


void f(const char* fn)

{

File_handle f(fn,"rw"); //打开fn进行读写

// 通过f使用文件

}


在一个系统中，需要为每一个资源都使用一个“资源句柄”类。无论如何，我们不需要为每一个资源获得都写出“finally”语句。在实时系统中，资源获得要远远多于资源的种类，因此和使用“finally”构造相比，“资源获得即初始化”技术会产生少得多的代码。


什么是自动指针（auto_ptr），为什么没有自动数组（auto_array）？


auto_ptr是一个非常简单的句柄类的例子，在&lt;memory&gt;中定义，通过“资源获得即初始化”技术支持异常安全。auto_ptr保存着一个指针，能够象指针一样被使用，并在生存期结束时释放指向的对象。举例：


#include&lt;memory&gt;

using namespace std;


struct X {

int m;

// ..

};


void f()

{

auto_ptr&lt;X&gt; p(new X);

X* q = new X;


p-&gt;m++; // 象一个指针一样使用p

q-&gt;m++;

// ...


delete q;

}


如果在...部分抛出了一个异常，p持有的对象将被auto_ptr的析构函数正确地释放，而q指向的X对象则产生了内存泄漏。更多的细节，参见《C++程序设计语言》14.4.2节。


auto_ptr是一个非常简单的类。特别地，它不是一个引用计数（reference counted）的指针。如果你将一个auto_ptr赋值给另一个，那么被赋值的auto_ptr将持有指针，而原来的auto_ptr将持有0。举例：


#include&lt;memory&gt;

#include&lt;iostream&gt;

using namespace std;


struct X {

int m;

// ..

};


int main()

{

auto_ptr&lt;X&gt; p(new X);

auto_ptr&lt;X&gt; q(p);

cout &lt;&lt; "p " &lt;&lt; p.get() &lt;&lt; " q " &lt;&lt; q.get() &lt;&lt; "\n";

}


将会打印出一个指向0的指针和一个指向非0的指针。例如：


p 0x0 q 0x378d0


auto_ptr::get()返回那个辅助的指针。


这种“转移”语义不同于通常的“复制”语义，这是令人惊讶的。特别地，永远不要使用auto_ptr作为一个标准容器的成员。标准容器需要通常的“复制”语义。例如：


std::vector&lt;auto_ptr&lt;X&gt; &gt;v; // 错误


auto_ptr只持有指向一个单独元素的指针，而不是指向一个数组的指针：


void f(int n)

{

auto_ptr&lt;X&gt; p(new X[n]); //错误

// ...

}


这是错误的，因为析构函数会调用delete而不是delete[]来释放指针，这样就不会调用余下的n-1个X的析构函数。


那么我们需要一个auto_array来持有数组吗？不。没有auto_array。原因是根本没有这种需要。更好的解决方案是使用vector：


void f(int n)

{

vector&lt;X&gt; v(n);

// ...

}


当...部分发生异常时，v的析构函数会被正确地调用。


可以混合使用C风格与C++风格的内存分派与重新分配吗？


在这种意义上是可以的：你可以在同一个程序中使用malloc()和new。


在这种意义上是不行的：你不能使用malloc()来建立一个对象，又通过delete来释放它。你也不能用new建立一个新的对象，然后通过free()来释放它，或者通过realloc()在数组中再建立一个新的。


C++中的new和delete操作可以保证正确的构造和析构：构造函数和析构函数在需要它们的时候被调用。C风格的函数alloc(), calloc(), free(), 和realloc()却不能保证这一点。此外，用new和delete来获得和释放的原始内存，并不一定能保证与malloc()和free()兼容。如果这种混合的风格在你的系统中能够运用，只能说是你走运——暂时的。


如果你觉得需要使用realloc()——或者要做更多——考虑使用标准库中的vector。例如：


// 从输入中将词读取到一个字符串vector中


vector&lt;string&gt; words;

string s;

while (cin&gt;&gt;s &amp;&amp; s!=".") words.push_back(s);


vector会视需要自动增长。


更多的例子与讨论，参见我的文章《将标准C++作为一种新的语言来学习》(Learning Standard C++ as a New Language)，你可以在本人著作列表(my publications list)中下载到它。


我为什么必须使用一个造型来转换*void？


在C语言中，你可以隐式地将*void转换为*T。这是不安全的。考虑一下：


#include&lt;stdio.h&gt;


int main()

{

char i = 0;

char j = 0;

char* p = &amp;i;

void* q = p;

int* pp = q; /* 不安全的，在C中可以，C++不行 */


printf("%d %d\n",i,j);

*pp = -1; /* 覆盖了从i开始的内存 */

printf("%d %d\n",i,j);

}


使用一个并不指向T类型的T*将是一场灾难。因此，在C++中，如果从一个void*得到一个T*，你必须进行显式转换。举例来说，要得到上列程序的这个令人别扭的效果，你可以这样写：


int* pp = (int*)q;


或者使用一个新的类型造型，以使这种没有检查的类型转换操作变得更加清晰：


int* pp = static_cast&lt;int*&gt;(q);


造型被最好地避免了。


在C语言中，这种不安全的转换最常见的应用之一，是将malloc()的结果赋予一个合适的指针。例如：


int* p = malloc(sizeof(int));


在C++中，使用类型安全的new操作符：


int* p = new int;


附带地，new操作符还提供了胜过malloc()的新特性：


new不会偶然分配错误的内存数量；

new会隐式地检查内存耗尽情况，而且

new提供了初始化。


举例：


typedef std::complex&lt;double&gt; cmplx;


/* C风格: */

cmplx* p = (cmplx*)malloc(sizeof(int)); /* 错误：类型不正确 */

/* 忘记测试p==0 */

if (*p == 7) { /* ... */ } /* 糟糕，忘记了初始化*p */


// C++风格:

cmplx* q = new cmplx(1,2); // 如果内存耗尽，将抛出一个bad_alloc异常

if (*q == 7) { /* ... */ }


我如何定义一个类内部（in-class）的常量？


如果你需要一个通过常量表达式来定义的常量，例如数组的范围，你有两种选择：


class X {

static const int c1 = 7;

enum { c2 = 19 };


char v1[c1];

char v2[c2];


// ...

};


乍看起来，c1的声明要更加清晰，但是要注意的是，使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式初始化的整型或枚举类型，而且必须是static和const形式。这是很严重的限制：


class Y {

const int c3 = 7; // 错误：不是static

static int c4 = 7; // 错误：不是const

static const float c5 = 7; // 错误：不是整型

};


我倾向使用枚举的方式，因为它更加方便，而且不会诱使我去使用不规范的类内初始化语法。


那么，为什么会存在这种不方便的限制呢？一般来说，类在一个头文件中被声明，而头文件被包含到许多互相调用的单元去。但是，为了避免复杂的编译器规则，C++要求每一个对象只有一个单独的定义。如果C++允许在类内部定义一个和对象一样占据内存的实体的话，这种规则就被破坏了。对于C++在这个设计上的权衡，请参见《C++语言的设计和演变》。


如果你不需要用常量表达式来初始化它，那么可以获得更大的弹性：


class Z {

static char* p; // 在定义中初始化

const int i; // 在构造函数中初始化

public:

Z(int ii) :i(ii) { }

};


char* Z::p = "hello, there";


你可以获取一个static成员的地址，当且仅当它有一个类外部的定义的时候：


class AE {

// ...

public:

static const int c6 = 7;

static const int c7 = 31;

};


const int AE::c7; // 定义


int f()

{

const int* p1 = &amp;AE::c6; // 错误：c6没有左值

const int* p2 = &amp;AE::c7; // ok

// ...

}


为什么delete不会将操作数置0？


考虑一下：


delete p;

// ...

delete p;


如果在...部分没有涉及到p的话，那么第二个“delete p;”将是一个严重的错误，因为C++的实现（译注：原文为a C++ implementation，当指VC++这样的实现了C++标准的具体工具）不能有效地防止这一点（除非通过非正式的预防手段）。既然delete 0从定义上来说是无害的，那么一个简单的解决方案就是，不管在什么地方执行了“delete p;”，随后都执行“p=0;”。但是，C++并不能保证这一点。


一个原因是，delete的操作数并不需要一个左值（lvalue）。考虑一下：


delete p+1;

delete f(x);


在这里，被执行的delete并没有拥有一个可以被赋予0的指针。这些例子可能很少见，但它们的确指出了，为什么保证“任何指向被删除对象的指针都为0”是不可能的。绕过这条“规则”的一个简单的方法是，有两个指针指向同一个对象：


T* p = new T;

T* q = p;

delete p;

delete q; // 糟糕！


C++显式地允许delete操作将操作数左值置0，而且我曾经希望C++的实现能够做到这一点，但这种思想看来并没有在C++的实现中变得流行。


如果你认为指针置0很重要，考虑使用一个销毁的函数：


template&lt;class T&gt; inline void destroy(T*&amp; p) { delete p; p = 0; }


考虑一下，这也是为什么需要依靠标准库的容器、句柄等等，来将对new和delete的显式调用降到最低限度的另一个原因。


注意，通过引用来传递指针（以允许指针被置0）有一个额外的好处，能防止destroy()在右值上（rvalue）被调用：


int* f();

int* p;

// ...

destroy(f()); // 错误：应该使用一个非常量（non-const）的引用传递右值

destroy(p+1); // 错误：应该使用一个非常量（non-const）的引用传递右值


我能够写“void main()”吗？


这种定义：


void main() { /* ... */ }


在C++中从未被允许，在C语言中也是一样。参见ISO C++标准3.6.1[2]或者ISO C标准5.1.2.2.1。规范的实现接受这种方式：


int main() { /* ... */ }


和


int main(int argc, char* argv[]) { /* ... */ }


一个规范的实现可能提供许多版本的main()，但它们都必须返回int类型。main()返回的int值，是程序返回一个值给调用它的系统的方式。在那些不具备这种方式的系统中，返回值被忽略了，但这并不使“void main()”在C++或C中成为合法的。即使你的编译器接受了“void main()”，也要避免使用它，否则你将冒着被C和C++程序员视为无知的风险。


在C++中，main()并不需要包含显式的return语句。在这种情况下，返回值是0，表示执行成功。例如：


#include&lt;iostream&gt;


int main()

{

std::cout &lt;&lt; "This program returns the integer value 0\n";

}


注意，无论是ISO C++还是C99，都不允许在声明中漏掉类型。那就是说，与C89和ARM C++形成对照，当声明中缺少类型时，并不会保证是“int”。于是：


#include&lt;iostream&gt;


main() { /* ... */ }


是错误的，因为缺少main()的返回类型。


为什么我不能重载点符号，::，sizeof，等等？


大多数的运算符能够被程序员重载。例外的是：


. (点符号) :: ?: sizeof


并没有什么根本的原因要禁止重载?:。仅仅是因为，我没有发现有哪种特殊的情况需要重载一个三元运算符。注意一个重载了 表达式1？表达式2：表达式3 的函数，不能够保证表达式2：表达式3中只有一个会被执行。


Sizeof不能够被重载是因为内建的操作（built-in operations），诸如对一个指向数组的指针进行增量操作，必须依靠它。考虑一下：


X a[10];

X* p = &amp;a[3];

X* q = &amp;a[3];

p++; // p指向a[4]

// 那么p的整型值必须比q的整型值大出一个sizeof(X)


所以，sizeof(X)不能由程序员来赋予一个不同的新意义，以免违反基本的语法。


在N::m中，无论N还是m都不是值的表达式；N和m是编译器知道的名字，::执行一个（编译期的）范围解析，而不是表达式求值。你可以想象一下，允许重载x::y的话，x可能是一个对象而不是一个名字空间（namespace）或者一个类，这样就会导致——与原来的表现相反——产生新的语法（允许 表达式1::表达式2）。很明显，这种复杂性不会带来任何好处。


理论上来说，.（点运算符）可以通过使用和-&gt;一样的技术来进行重载。但是，这样做会导致一个问题，那就是无法确定操作的是重载了.的对象呢，还是通过.引用的一个对象。例如：



class Y {

public:

void f();

// ...

};


class X { // 假设你能重载.

Y* p;

Y&amp; operator.() { return *p; }

void f();

// ...

};


void g(X&amp; x)

{

x.f(); // X::f还是Y::f还是错误？

}


这个问题能够用几种不同的方法解决。在标准化的时候，哪种方法最好还没有定论。更多的细节，请参见《C++语言的设计和演变》。


怎样将一个整型值转换为一个字符串？


最简单的方法是使用一个字符串流（stringstream）：


#include&lt;iostream&gt;

#include&lt;string&gt;

#include&lt;sstream&gt;

using namespace std;


string itos(int i) // 将int转换成string

{

stringstream s;

s &lt;&lt; i;

return s.str();

}


int main()

{

int i = 127;

string ss = itos(i);

const char* p = ss.c_str();


cout &lt;&lt; ss &lt;&lt; " " &lt;&lt; p &lt;&lt; "\n";

}


自然地，这种技术能够将任何使用&lt;&lt;输出的类型转换为字符串。对于字符串流的更多说明，参见《C++程序设计语言》21.5.3节。


“int* p”正确还是“int *p”正确？


二者都是正确的，因为二者在C和C++中都是有效的，而且意义完全一样。就语言的定义与相关的编译器来说，我们还可以说“int*p”或者“int * p”。


在“int* p”和“int *p”之间的选择与正确或错误无关，而只关乎风格与侧重点。C侧重表达式；对声明往往比可能带来的问题考虑得更多。另一方面，C++则非常重视类型。


一个“典型的C程序员”写成“int *p”，并且解释说“*p表示一个什么样的int”以强调语法，而且可能指出C（与C++）的语法来证明这种风格的正确性。是的，在语法上*被绑定到名字p上。


一个“典型的C++程序员”写成“int* p”，并且解释说“p是一个指向int的指针类型”以强调类型。是的，p是一个指向int的指针类型。我明确地倾向于这种侧重方向，而且认为对于学好更多的高级C++这是很重要的。


严重的混乱（仅仅）发生在当人们试图在一条声明中声明几个指针的时候：


int* p, p1; // 也许是错的：p1不是一个int*


把*放到名字这一边，看来也不能有效地减少这种错误：


int *p, p1; // 也许是错的？


为每一个名字写一条声明最大程度地解决了问题——特别是当我们初始化变量的时候。人们几乎不会这样写：


int* p = &amp;i;

int p1 = p; // 错误：int用一个int*初始化了


如果他们真的这么干了，编译器也会指出。


每当事情可以有两种方法完成，有人就会迷惑。每当事情仅仅是一个风格的问题，争论就会没完没了。为每一个指针写一条声明，而且永远都要初始化变量，这样，混乱之源就消失了。更多的关于C的声明语法的讨论，参见《C++语言的设计和演变》。


对于我的代码，哪一种布局风格（layout style）是最好的？


这种风格问题属于个人的爱好。人们往往对布局风格的问题持有强烈的意见，不过，也许一贯性比某种特定的风格更加重要。象大多数人一样，我花了很长的时间，来为我的偏好作出一个固定的结论。


我个人使用通常称为“K&amp;R”的风格。当使用C语言没有的构造函数时，需要增加新的习惯，这样就变成了一种有时被称为“Stroustrup”的风格。例如：


class C : public B {

public:

// ...

};


void f(int* p, int max)

{

if (p) {

// ...

}


for (int i = 0; i&lt;max; ++i) {

// ...

}

}


比大多数布局风格更好，这种风格保留了垂直的空格，我喜欢尽可能地在合理的情况下对齐屏幕。对函数开头的大括弧的放置，有助于我第一眼就分别出类的定义和函数的定义。


缩进是非常重要的。


设计问题，诸如作为主要接口的抽象基类的使用，使用模板以表现有弹性的类型安全的抽象，以及正确地使用异常以表现错误，比布局风格的选择要重要得多。


我应该将“const”放在类型之前还是之后？


我把它放在前面，但那仅仅是个人爱好问题。“const T”和“T const”总是都被允许的，而且是等效的。例如：


const int a = 1; // ok

int const b = 2; // also ok


我猜想第一种版本可能会让少数（更加固守语法规范）的程序员感到迷惑。


为什么？当我发明“const”（最初的名称叫做“readonly”，并且有一个对应的“writeonly”）的时候，我就允许它出现在类型之前或之后，因为这样做不会带来任何不明确。标准之前的C和C++规定了很少的（如果有的话）特定的顺序规范。


我不记得当时有过任何有关顺序问题的深入思考或讨论。那时，早期的一些使用者——特别是我——仅仅喜欢这种样子：


const int c = 10;


看起来比这种更好：


int const c = 10;


也许我也受了这种影响：在我最早的一些使用“readonly”的例子中


readonly int c = 10;


比这个更具有可读性：


int readonly c = 10;


我创造的那些最早的使用“const”的（C或C++）代码，看来已经在全球范围内取代了“readonly”。


我记得这个语法的选择在几个人——例如Dennis Ritchie——当中讨论过，但我不记得当时我倾向于哪种语言了。


注意在固定指针（const pointer）中，“const”永远出现在“*”之后。例如：


int *const p1 = q; // 指向int变量的固定指针

int const* p2 = q; //指向int常量的指针

const int* p3 = q; //指向int常量的指针


使用宏有什么问题？


宏不遵循C++中关于范围和类型的规则。这经常导致一些微妙的或不那么微妙的问题。因此，C++提供更适合其他的C++（译注：原文为the rest of C++，当指C++除了兼容C以外的部分）的替代品，例如内联函数、模板与名字空间。


考虑一下：


#include "someheader.h"


struct S {

int alpha;

int beta;

};


如果某人（不明智地）地写了一个叫“alpha”或“beta”的宏，那么它将不会被编译，或者被错误地编译，产生不可预知的结果。例如，“someheader.h”可能包含：


#define alpha 'a'

#define beta b[2]


将宏（而且仅仅是宏）全部大写的习惯，会有所帮助，但是对于宏并没有语言层次上的保护机制。例如，虽然成员的名字包含在结构体的内部，但这无济于事：在编译器能够正确地辨别这一点之前，宏已经将程序作为一个字符流进行了处理。顺便说一句，这是C和C++程序开发环境和工具能够被简化的一个主要原因：人与编译器看到的是不同的东西。


不幸的是，你不能假设别的程序员总是能够避免这种你认为“相当白痴”的事情。例如，最近有人报告我，他们遇到了一个包含goto的宏。我也见过这种情况，而且听到过一些——在很脆弱的时候——看起来确实有理的意见。例如：


#define prefix get_ready(); int ret__

#define Return(i) ret__=i; do_something(); goto exit

#define suffix exit: cleanup(); return ret__


void f()

{

prefix;

// ...

Return(10);

// ...

Return(x++);

//...

suffix;

}


作为一个维护的程序员，就会产生这种印象；将宏“隐藏”到一个头文件中——这并不罕见——使得这种“魔法”更难以被辨别。


一个常见的微妙问题是，一个函数风格的宏并不遵守函数参数传递的规则。例如：


#define square(x) (x*x)


void f(double d, int i)

{

square(d); // 好

square(i++); // 糟糕：这表示 (i++*i++)

square(d+1); //糟糕：这表示(d+1*d+1); 也就是 (d+d+1)

// ...

}


“d+1”的问题，可以通过在“调用”时或宏定义时添加一对圆括号来解决：


#define square(x) ((x)*(x)) /*这样更好 */


但是， i++被执行了两次（可能并不是有意要这么做）的问题仍然存在。


是的，我确实知道有些特殊的宏并不会导致C/C++预处理宏这样的问题。但是，我无心去发展C++中的宏。作为替代，我推荐使用C++语言中合适的工具，例如内联函数，模板，构造函数（用来初始化），析构函数（用来清除），异常（用来退出上下文环境），等等。

--
装B者死于自然灾害！

帖子发的快删的也快,只有灌水是永恒的


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 219.142.139.*]
 【文章标题】：从“六十万游戏人才” 谈教育者职业操守 【文章地址】：https://bbs.byr.cn/article/SoftDesign/1908 【创建时间】：2005-11-24 【作者】：BlueStorm 【评论】：0 【内容】：发信人: BlueStorm (流氓军团&gt;||&lt;天之骄子), 信区: SoftDesign
标  题: 从“六十万游戏人才” 谈教育者职业操守
发信站: BBS 北邮人论坛站 (Thu Nov 24 16:42:45 2005), 站内

从“六十万游戏人才” 谈教育者职业操守 
2005.11.17  来自：eNet硅谷动力   
 
　　最近看到一系列的文章，都包含着一个非常刺眼的内容：“中国的游戏开发行业上出现的人才缺口是六十万人（也有一说是“二十万”的）”，据说还是引用的信息产业部公布的数字。如果你还没有被这个数字惊呆，我想提供给你一个参考标准：六十万大约就是中国人民解放军现役全部海军和空军官兵的总和。现在估计你已经被吓着了。对游戏行业进行稍加了解，你就会更加觉得这简直就是彻头彻尾的疯话。 

　　中国游戏行业目前谁是老大？感谢福布斯等机构的努力，类似这样的问题是不存在多大的争议的，答案当然是上海的盛大。但从盛大公司提交给美国证券交易委员会的报告可以看到，截至最近，盛大公司的员工总数1，400多人，而且这其中还包括着市场、运营甚至人力资源和财务这样的非开发人员。在2004年4月2日盛大公司出具的官方报告上精确地注明，至2004年3月31日 ，该公司的游戏开发人员一共186人而已。同样查一查网易等大公司的相关文件，就会看到，这些公司的开发人员的数量，普遍都只在百人的数量级上。是不是这些大公司所占的市场份额不够大，游戏人才都在其他更小的公司里？好像不是。即便是在鼓吹游戏人才缺口几十万人的那类文章上，关于网络游戏市场规模的描述，也只是说在二十五亿元左右。而盛大一家公司在过去十二个月(2004年8月至2005年8月)的营业收入，就已经达到了十六亿元，显然，市场主体确是在这些大公司的手中的。那么，这六十万人究竟谁来领走呢？争论至此，“六十万”的鼓吹者们，似乎也只好把我们的视线指向两个方向，一个是国外，一个是未来。 

　　顺便说一句，近些年来，“国外如何如何”已经成了大小骗子们的防空洞了，似乎一扯到国外，所有荒谬的东西都具备了合理性，满口“某某国等国家很先进，研发很厉害，我们必须追赶才行”。让我们看看真实的所谓国外的情况。韩国和ACTOZ，应该是所有关注游戏行业发展的人们无比熟悉的两个词。韩国之所以让人熟悉，因为它已经成为了网络游戏的“好莱坞”；如果前面的比喻成立，那么ACTOZ公司无疑可以被叫做游戏“二十一世纪福克斯”。ACTOZ这个网络游戏研发的航母，是包括盛大在内的几个国内网游公司的上游开发商《传奇》、《A3》等众多著名网络游戏的版权拥有者。对于盛大，研发的命脉掌握在外人手中的可怖威胁，终于使得陈首富在若干个夜晚的辗转反侧后下定决心，于在2004年对ACTOZ 进行了收购，巩固了盛大的大后方。查看韩国KOSDAQ（相当于美国纳斯达克的韩国证券市场）的注册资料 ，你会惊奇地发现，即使是ACTOZ这样一个研发型的、具有行业领导地位的公司，也不过区区162人而已（2004年6月的数字），注意，是全部员工数字，前台接电话的小姐已经包含在内了！可见，即便是在韩国，真正从事游戏开发工作的人也是相当有限的。游戏作为一个信息类产品，最大的特点就是几乎为零的“边际成本”。通俗地说，就是一个产品开发好以后，究竟给多少人提供服务对成本的影响不会非常大。在鼓吹游戏人才缺口的文章中，有人感叹道，“一方面是两千万的游戏玩家，一方面是仅仅三千人的开发队伍”，言下之意，这人才短缺不是显而易见了吗。那么，我不禁要问，在目前“两千万用户”及“三千开发人员”的“窘迫”状况下，有多少玩家在游戏过程中感受到游戏公司的人手短缺了？好莱坞的电影拥有观众不下十亿，按照这样的逻辑，究竟安排几百万人去美国做电影比较合适呢？从用户数量和从业人员的数量之悬殊就得出从业人员数量将要增加的结论，是“六十万”理论最大的无知之处。 

　　最后，一个相对难以通过查资料解决、求证的问题出现了：“这六十万人是否会出现在将来”？先看看“六十万”们的预测吧。这些文章当中说，“近年来，中国的游戏产业发展迅速，去年网络游戏市场规模达到二十四点七亿元人民币，比上一年增长近五成，预计经过三至四年的发展，中国网络游戏市场销售收入将达到一百亿元左右。”即便不去讨论这些数字的预测是否过于乐观，即便我们认定这样的增长一直会持续下去，我们也必须看到，游戏这类信息类产品的特点，决定了从业人员的增长必将大大落后于行业的规模增长速度。还是从盛大公司的情况看，在最近公布季度财务报告上，盛大的季度销售收入同比增加了93.1%，但是员工的数量仅从2004年3月底的931人，增加到了目前的1，429人，增长率仅53%。因此，以这样的速度，盛大的营业收入即使再翻一倍，员工也仅仅会增加不到1，000人，而且，我们有理由相信，这部分的增长，也会是以客服人员而不是以更加专业的开发人员为主的。盛大公司现在人均实现销售收入约100万元。按照这样的标准测算，即便那个行业收入过百亿的时代真的来了，这个行业也就能养活一万人而已。考虑到竞争使人均创收能力降低等因素，游戏行业顶多可以容纳2-3万人，而且是在不知道多久的将来。 

　　对于所谓“六十万”的鼓噪，如果仅仅因为盲从与无知，可能还是尚可原谅的，但是此次宣传之猛烈，意图之明显，使稍有头脑的人都可以清楚地看到，其背后似有利益团体的操纵，而更加让人拍案的，是操纵者似乎是一批本该“为人师表”的教育工作者。笔者认为，要缔造所谓的和谐社会，有两类人的良心是万万坏不得的，一是媒体工作者，二是教育工作者。媒体工作者的职业良知之所以重要，是因为他们可以影响人群之广泛；教育工作者的职业操守之所以必须，是因为他们对受教育者产生的影响之深远。可悲的是，“六十万”论恰是在这两个人群当中少部分人的互动中所勾勒出的骗局。 

　　在中国，从事教育工作是令人骄傲的。在“一日为师，终生为父”的训诫下，即便是改革的大潮涤荡、冲刷掉了绝大多数的传统遗风后，对教师的尊重依然存留于大多数人的心间。但是，我们的教育工作者在为别人“解惑”的同时，是否对“你们的责任有多大”这个问题，有着比较正确的答案？从事教育工作，特别是职业教育领域的人员，应该意识到，你们的教育对象-处于二十岁左右的青年，是处在他们职业生涯的“方向选择”阶段。在二十岁到三十岁前的这段时间，一个人尽管未必能实现在事业发展上的道路上行进多远，但对将来终生从事的职业方向，已经会有一个相对明确的取舍了。“六十万”们是否想过，在二十岁这样一个人的热情最高涨，但自信最脆弱的阶段，引导他走向一个所谓“游戏英雄”的海市蜃楼，最后的结果会是一个多大的灾难。一两万元的学费、一两年时间的损失也就罢了，但对于他们，当发现人生第一个他们所热爱并全心投入的、“社会急需的”、“老师们也都说好”的职业发展目标，竟是一个可望不可及的幻影时，梦想被击碎的他们将会用多长时间，才能理智地认识到这一切并非他们的无能，而是目标原本就被人悄悄移偏了方向？而当最终发现这个误导他们的人竟然是他们尊敬的老师时，他们会不会发出“如果老师都骗人，这个世界上我们究竟还可以相信谁”的哀叹？！教育假药是最毒的假药，不仅因为它们一旦服下就会危害终生，更因为服这个假药的一两年时间中，你可能无法同时摄入其他的营养；而且，你可能需要未来十年的时间，才认识到这剂药的质量存在瑕疵。不要忘了，在这些热血沸腾地选择游戏作为毕生事业的学员当中，有相当部分本来已经陷入游戏不能自拔了，这时以“社会最需要的就是你们这样的人才，缺口几十万”的光彩理由把他们再向前推，无疑将把他们送上事业上的不归迷途。 

　　笔者供职的机构，也在进行游戏开发人才的培养工作。稍有不同的是，我们并不打算因为公众对游戏的热情、因为商业上的利益就把我们的判断力与良知拿出来待价而沽。在2005年，我们的培养计划仅仅是在百人数量级而已。教育机构、特别是职业教育机构应该认识到，教育机构真正扮演的角色是为各行业进行人力资源配套供应的服务性工作。在对行业进行定向人才培养时，应该时刻关注行业的人力资源需求情况，既不能超前，也不能落后，而是必须像影子一样仅仅跟随。在IT相关的领域当中，技能是无法保鲜的，即便游戏行业真的需要六十万开发人才，如果不能选择合适的时机进行培养，对这些学员来说，这个时间上的提前量也会造成灾难性的后果。 

　　我们相信对学员前途而不是经营利润的真正关注，才是教育机构、包括经营性教育机构长期生存的根本，才是教育者职业操守的核心。我在这里非常希望提醒“六十万派”们，未来再准备放这类似“六十万”的卫星，先自己用手摸摸两个部位：摸一下头-确实不烧，摸一下心-当真无愧，再把这类惊人观点抛出来不迟。

--

人没有怨死，没有妄死，只有注定的一死；
上帝为每个人精心设计了死亡，
如果你逃脱了上帝的设计，
那么上帝还将为你另外设计死亡……

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 61.144.67.*]
 


【文章标题】：[转帖]痛苦的选择：不再只专注于技术 【文章地址】：https://bbs.byr.cn/article/SoftDesign/121 【创建时间】：2005-05-16 【作者】：SunFlowers 【评论】：0 【内容】：发信人: SunFlowers (突然有了), 信区: SoftDesign
标  题: [转帖]痛苦的选择：不再只专注于技术
发信站: BBS 北邮人论坛站 (Mon May 16 18:28:43 2005), 站内

     我很长一段时间都在煎熬中度过，已经快到而立之年，对自己的发展方向、前途却还很迷茫。这么多年来，我一直受兴趣指引，走了很长的路，或曲或直，但我从来没有后悔过。可决定未来的方向却让我痛苦不已。

     1987年，我开始在CONMAX（记得不是很清楚了）机器上学习BASIC，从此和程序语言结下了不解之缘。当时学校仅有两台苹果II型电脑，我们连碰的机会都没有。CONMAX机器开机就是BASIC，没有操作系统，没有磁盘（使用录音机记录程序），在这样的机器上，我和我的同学们用SHAPE命令编程序在屏幕上写自己的名字，写赛车游戏、碰碰球游戏。编程给我带来了无穷的乐趣。

     93年考入大学，因为当时外贸非常热门，我放弃了感兴趣的自动化专业、机械专业，开始学习工业外贸。由于是工业外贸，所以在课程设置上包含了机械、电子、经济、英语、外贸等方向的多门课程。凭着自己的兴趣，在机械相关的课程上，我的平均成绩不在97分之下（画法几何还考了100分）。这也奠定了后来学习Auto CAD、3DS MAX的基础。电子类课程成绩也不错，基本上都是班中第一。我对外语和外贸并不是很感兴趣，但在周围同学的强大压力下，还是以73.5分的成绩通过了六级考试，并在全院第一个拿到了BEC2的证书，更没想到的是5年后我竟然成为了BEC的口语考官。

     大学的生活非常紧张，除了在学生会任职之外，我还把学校中所有的计算机培训班课程学了一个遍，在这期间我接触了PASCAL、C语言、FoxBASE、FoxPro，也为我参加数学建模竞赛奠定了计算机基础。1995年，学校组队参加全国大学生数学建模竞赛，我没有被选中。在强烈要求下，我作为旁听生参加了近一年半的数学建模的培训。虽经过艰苦的准备，但最终由于一个小失误导致我们组在全国大学生数学建模竞赛上只拿到了河北省二等奖。为了挽回失去的荣誉，我放弃了考研，毅然决定与队友参加美国大学生数学建模竞赛，并最终取得了一等奖的好成绩。可笑的是，在参赛获奖的两组六个人中，竟然有三个人是当时的“旁听生”。

   虽然外贸专业课没有学好，但大学的学习为我的英语、数学、计算机打下了很好的基础，这也是我的兴趣带我到这一步的。毕业后留校，并转行管理信息系统。比起管理信息系统专业的学生来，我欠缺了太多的知识。我把“计算机技术”作为我的专攻方向，不断追赶。VFP、VB、DELPHI、.NET、SQL Server……甚至成为了MCT，在计算机技术上走了很远。

现在，我忽然发现“累”了。我发现我对编程、对计算机技术不象以前那么专注了。我更加感兴趣技术后面的东西：设计模式、分析模式、财务管理、营销策略、企业信息化……想起当时我的老师说管理信息系统是“数学”、“管理”、“计算机”的交叉地带，我现在花了7年的时间才明白“技术”不能代表一切。

很多象我一样对计算机技术“狂热”的人，其中一个原因恐怕是“编程”容易上手，花上个把月的时间就可以学到一些“高深”东西，并且可以编程炫耀一番了。另外，编程是创造的过程，看着自己的想法付诸实现，总会有成就之感，即使程序编写的很糟糕。编程也能处处体现征服困难的喜悦，每当一个问题被解决，心里面总有一种成就感，即使这个问题早就有人解决过了。这也是为什么有人花上大量时间，用尽各种技巧用JavaScript编写一个Web控件，而根本不去琢磨是否有一种智能客户端的技术，可以使用功能丰富的Windows控件。

编程中的这种体会引导着我的兴趣，让我走了很远，也失去了很多。“专注于计算机技术”让很多人放弃了外语、放弃了数学、放弃了管理。很多人说这种放弃是心甘情愿的，你可能花了两年的时间学习英语，然而收获很少，为什么不去学计算机呢，至少能够“速成”，而且喜悦伴随着整个的学习过程。可是，这错了。编程创造的价值是什么呢？当你开发一套系统的时候，这套系统的管理内涵决定了应用信息系统的价值，而不是编程技巧的高低。编程技巧的高低可以决定开发效率，但不能决定企业应用信息系统究竟能带来多大的收益。编程是一种机械性的工作，它里面的创新并不能象优化管理流程一样对企业带来的巨大的利润。Web Service技术也不是凭空出现的，而是应企业应用集成的需求而出现的。

现在的编程技术也降低了编程的门槛（很多人的虚荣心可以更容易的实现了），寒枫天伤有一次推荐自动代码生成的一系列网站，我看了一些，其中“Constructor”软件让程序编写.net系统变的如此容易。应用MDA后恐怕更容易。也许有一天人们不用再写那么多的代码。程序开发员的价值是否也意味着会不断贬值呢？

“开发”阵营的人往往感慨为什么中国程序员没有超过30的，为什么中国没有人能够创造出一门语言来。不再专注于技术不意味着放弃技术。过分专注技术，就会陷入一种“技术成功”做成的陷阱中，最终变成一个“快乐的井底之蛙”。另外，只有知道技术的发展方向，才能更好的专注于技术，而技术的发展方向往往不取决于技术本身。设想有一天，一个跨国公司经营的几千万种商品一小时内完成清点，配货，及时针对竞争对手作出决策，所有这一切都是技术本身的功劳吗？我想不全是，其中一大部分取决于管理。用过ERP产品的程序员都说，其实每个界面都很简单，但ERP的价值不在于编程是否简单，其最重要的价值就是理顺的管理流程，推动了企业的运转。

我跟着兴趣走得太远了，而且这个“兴趣”实际上是“过分关注编程技术”带来的小恩小惠积累起来的，它让我走了条弯路（但我不后悔）。现在这个问题困扰了我太久了，我实在是很难割舍这些“小恩小惠”，可我还要割舍掉。我曾经放弃过自动化、机械选择了工业外贸，也曾经放弃了考研选择了参加美国大学生数学建模竞赛，还曾经放弃了我的大学专业工业外贸转行管理信息系统，现在我也要放弃“专注于技术”，将更多的精力专注在管理、财务、企业信息化上面。我不放弃技术，也会继续在博客园发表技术文章，只是不想再专注于技术这一方面了。


--
This ID belong to these two guys：
ChenX ，  who uses it to water
LuengC， who uese it to release his painting。

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.179.*]
 
【文章标题】：【求问】有大神懂中国移动的预算系统么？或者参与过编写的？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45649 【创建时间】：2014-12-26 【作者】：whatever23 【评论】：0 【内容】：发信人: whatever23 (【意涵团】不求offer只求AD), 信区: SoftDesign
标  题: 【求问】有大神懂中国移动的预算系统么？或者参与过编写的？
发信站: 北邮人论坛 (Fri Dec 26 10:27:43 2014), 站内

就是他们的全面预算系统是用什么软件编的？什么语言怎么实现的么？
谢谢了！！！
--
※ 修改:·whatever23 于 Dec 26 10:37:38 2014 修改本文·[FROM: 10.204.31.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 10.204.31.*]
 
【文章标题】：安卓app开发 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45545 【创建时间】：2014-12-05 【作者】：wxgsdy 【评论】：1 【内容】：发信人: wxgsdy (wxgsdy), 信区: SoftDesign
标  题: 安卓app开发
发信站: 北邮人论坛 (Fri Dec  5 17:18:15 2014), 站内

小白求问，安卓app开发有没有类似于Dreamweaver的软件，现在只想做出来app的UI界面，达到展示的效果就行。<img src="/img/ubb/em/4.gif" alt="em4" style="display:inline;border-style:none">
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 10.8.191.*]
 
【文章标题】：通过什么方式能把别人的QQ头像在本地“显示”成我想要的呢？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45708 【创建时间】：2015-01-13 【作者】：prison 【评论】：0 【内容】：发信人: prison (人只有将寂寞坐断，才可以重拾喧闹), 信区: SoftDesign
标  题: 通过什么方式能把别人的QQ头像在本地“显示”成我想要的呢？
发信站: 北邮人论坛 (Tue Jan 13 18:59:06 2015), 站内

①我第一种思路是遮蔽，但是怎么才能动态跟踪这个头像来遮蔽呢=。=
②第二种思路是，额，能否替换掉实际文件呢
求指导
--
※ 修改:·prison 于 Jan 13 18:59:14 2015 修改本文·[FROM: 222.129.101.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 222.129.101.*]
 
【文章标题】：这几年屯的IT天文历史哲学文学书籍，有需要的么 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45656 【创建时间】：2015-01-04 【作者】：aishuishou 【评论】：0 【内容】：发信人: aishuishou (aishuishou), 信区: SoftDesign
标  题: 这几年屯的IT天文历史哲学文学书籍，有需要的么
发信站: 北邮人论坛 (Sun Jan  4 10:00:06 2015), 站内

大部分是英文版的，当时收藏来着，工作后发现中文版就够用啦~
书有的在老家，可以平邮。需要的联系我把，到时候可以在淘宝创建二手连接，支付宝交易。

请加qq 907569107 注明买书即可
这几年屯的IT天文历史哲学文学书籍，有需要的么


--


<a target="_blank" href="/att/SoftDesign/0/45656/563"><img border="0" title="shu2.jpg" src="/att/SoftDesign/0/45656/563" alt="shu2.jpg" class="resizeable"></a>
※ 修改:·aishuishou 于 Jan  4 10:04:00 2015 修改本文·[FROM: 61.135.152.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 61.135.152.*]
 
【文章标题】：要崩溃鸟……Qt如何才能使用VS编译生成的dll文件呢？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/41245 【创建时间】：2011-10-10 【作者】：buptlay 【评论】：3 【内容】：发信人: buptlay (Lay), 信区: SoftDesign
标  题: 要崩溃鸟……Qt如何才能使用VS编译生成的dll文件呢？
发信站: 北邮人论坛 (Mon Oct 10 20:12:04 2011), 站内

我在.pro文件里把它写成 DEBUG:LIBS += -L F:/Libs/ -l kerneld 这样的形式之后仍然报错，信息是：undefined reference to `RW::init()'木有链接成功dll中定义的init函数，但是我已经把kerneld.dll和libkerneld.lib都复制到源代码和build的文件夹里面了，libs文件夹也有，可是就是链接不上……几天都没弄明白……此外我还把.lib改成.a文件试过，链接成功，但是在IDE启动的时候报错-17XXXXXXXXX的一串数字，网上说是没有把.a文件复制到上述的文件夹下，但是我已经复制了……到底该如何设置呢？dll使用C++和C混合写的，这个不是问题吧……谢过各位了！
--
※ 修改:·buptlay 于 Oct 10 20:14:37 2011 修改本文·[FROM: 118.229.161.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 118.229.161.*]
 
【文章标题】：从小白开始成长吧~ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45585 【创建时间】：2014-12-08 【作者】：seshy 【评论】：12 【内容】：发信人: seshy (shihengying), 信区: SoftDesign
标  题: 从小白开始成长吧~
发信站: 北邮人论坛 (Mon Dec  8 23:05:01 2014), 站内

They think programmers are cogs in the machines. The truth is programmers are artisans and to get the best results from a project the wise thing to do would be to ask the people who are experts at programming how things should be done! 
这是我很喜欢的一段话了，前一段时间浏览外国网站看到的，嗯，感觉说出了我的梦想的感觉了呢~
本人是大四下架学姐一枚啦，就要离开学校了，所以最近总想说些什么呢...
还记得一年前的自己坐在公交车上，望着外面黑黑的天，心里对自己说，一定不要成为一个程序员，嗯，就是这样。可是一年后的现在，自己不仅成为了一个小程序员，而且还庆幸自己选择了它，选择了一份我喜欢的工作。
我喜欢上它缘于一个解析文件的程序。当时带我的老大告诉我这厮不是那么好做的事情，只是让我试试看而已，然而我是个倔强的孩纸，不好做我偏一定要做出来！于是我就开始查文档写算法然后卡住卡住卡住，最后终于把它搞出来了。交代码给老大看的时候才发现写出完成需求的代码仅仅是开始，更重要的是它的结构合理性和效率，减少冗余。嗯，写出漂亮的代码着实不容易呢。于是我就回去精简重构代码，尽量用最少的行数完成功能。于是就不断不断的修改啊修改。最后一千多行的代码到最后只有七百行就可以了，而且速度也提升了很多。嗯，过程漫长，可是我也明白了，写代码其实是一件很有趣的事情..
那么再先讲讲现在吧，现在自己在一家手机软件公司安定下来了，每天的生活就是用Xcode和Android Studio开发APP，从日出到月明，看上去很枯燥的样子，但是每当看到有界面出来了，有功能实现了，bug被解决了，心里除了开森就是开森了呢~
现在会常常梦到自己在调bug写数据接口，不过却是很开心的，因为在意这个，因为希望自己可以有一天会不再是小白，是一个artisan。
那么，晚安啦..
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 10.204.38.*]
 
【文章标题】：Re: 小白求问，现在开发软件用什么语言会比较好？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/45502 【创建时间】：2015-01-06 【作者】：原帖已删除 【评论】：35 【内容】：发信人: kayla (MRRB), 信区: SoftDesign
标  题: Re: 小白求问，现在开发软件用什么语言会比较好？
发信站: 北邮人论坛 (Tue Dec  2 00:07:56 2014), 站内

如果你知道要做什么，自然就知道该用什么语言。
你的问题一点信息量都没有，别人根本没法回答你。
--
※ 修改:·kayla 于 Dec  2 00:12:54 2014 修改本文·[FROM: 1.83.164.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 1.83.164.*]
 
【文章标题】：【经管妹子请教】想做好的个人博客需要什么？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/44303 【创建时间】：2013-11-20 【作者】：pingxiahuhu 【评论】：56 【内容】：发信人: pingxiahuhu (huhu), 信区: SoftDesign
标  题: 【经管妹子请教】想做好的个人博客需要什么？
发信站: 北邮人论坛 (Wed Nov 20 20:16:12 2013), 站内

不懂发到哪个版块。。。就发在这里了。。。
RT，一直很想做个人博客，很早以前是在QQ空间写日志，后来改成新浪博客，也想着用lofter但是觉得不是很舒服，原因有以下几点：
1.有些功能不想要，只是想简单的表达而已。
2.非常希望有自己独特的域名
3.像新浪博客这种广告老多！而且有时候自己写的博客会生成微博告诉大家发了新博客。。。。。。但其实只是自己转载了比较喜欢的文章而已。。。
4.希望有自己设计的风格，比如版面，主题图片等！
  
一直关注以下的主页：<a target="_blank" href="http://lixiaolai.com/">http://lixiaolai.com/</a> 或<a target="_blank" href="http://www.matrix67.com/blog/">http://www.matrix67.com/blog/</a> 或<a target="_blank" href="http://littlecheesecake.me/">http://littlecheesecake.me/</a>觉得这样的风格就是自己想要的呀！！！只是想一直记录一些自己平时觉得很好的文章，视频，写一些自己的感悟，记录一些重要的时刻，拥有自己的平台！
  
但是自己不懂怎么做成这样的啊？
  
我不懂程序员的github，例如：<a target="_blank" href="http://www.lizherui.com/">http://www.lizherui.com/</a> 这样的~
我也不懂wordpress，例如：<a target="_blank" href="http://xw2423.byr.edu.cn/blog/">http://xw2423.byr.edu.cn/blog/</a> 这样的~
  
但是觉得虽然是一个经管的童鞋，想要为自己创造个人主页的心总是有滴呀呀。
  
所以求教各位大神：需要做哪些工作才能打造一个有个人风格的简单博客呢？印象中是需要：
1.购买域名
2.在本机上安装github？或wordpress？
3.。。。。。。
  
求指导！怎样从小白到搭建网站完成？或者有更好的建议？请原谅完全不懂技术的经管妹子。。。
  
小女子在此先谢过各位大神了~  如果觉得我的问题比较令人无语，那就对不住大神您了。。。
  
  
--
※ 修改:·pingxiahuhu 于 Nov 30 18:12:36 2014 修改本文·[FROM: 10.8.171.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://bbs.byr.cn">http://bbs.byr.cn</a>·[FROM: 10.8.239.*]
 
【文章标题】：工作中的十不要（适用于工作不久的同事）(转) 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30438 【创建时间】：2008-10-11 【作者】：atian25 【评论】：3 【内容】：发信人: atian25 (天猪天狗|阿天), 信区: SoftDesign
标  题: 工作中的十不要（适用于工作不久的同事）(转)
发信站: 北邮人论坛 (Sat Oct 11 17:22:13 2008), 站内

工作中的十不要（适用于工作不久的同事）(转)
第一：不要认为停留在心灵的舒适区域内是可以原谅的。
　　
　　每个人都有一个舒适区域，在这个区域内是很自我的，不愿意被打扰，不愿意被push，不愿意和陌生的面孔交谈，不愿意被人指责，不愿意按照规定的时限做事，不愿意主动的去关心别人，不愿意去思考别人还有什么没有想到。这在学生时代是很容易被理解的，有时候这样的同学还跟“冷酷”“个性”这些字眼沾边，算作是褒义。然而相反，在工作之后，你要极力改变这一现状。否则，你会很快变成鸡尾酒会上唯一没有人理睬的对象，或是很快因为压力而内分泌失调。但是，如果你能很快打破之前学生期所处的舒适区域，比别人更快的处理好业务、人际、**之间的关系，那就能很快的脱颖而出。
　　
　　在会议上，一个停留在心灵舒适区域的人会消极的听取领导的话语，消极的待命，很死的完成上级交给的事情，但从来不关心此事以外的任何事情，更不会想到多做一步，让接下来的别人的工作更加容易上手。而敢于打破这个舒适区域的人，敢于在适当的时候提出自己的看法和不理解，并在得到上级认可和指点之后把手头的工作尽快的完成，并随时接受别人的批评和调整。（注意：永远不要等待别人把你的想法说出来，这是典型的前者）
　　
　　在工作上，当前者遇到一名新的同事，他会装作没有看见，继续自己的工作。殊不知新来的同事不久就变成了自己的上司。而后者则大方客气的自我介绍，并了解对方和自己的关系。
　　
　　在聚会上，前者总是等待别人发言，并喜欢私下里评论对方的言语；如果这个桌子上没有人发言，那直到用餐结束，也没有人认识你。而后者是勇敢的和一同吃饭的开始介绍和闲谈，这看起来很困难，有时候会有失面子，但往往你会发现，对方是多么希望能和你说几句话。
　　
　　以上只是很小的几个例子，但是要说明的是，大学生在走出校园的同时就要在工作上把校园中的“随意性”从身边赶走，尽早的冲出自己的舒适区域，开始做好和这个社会交流的准备。 
　　

　　第二：不要把“好像”；“有人会……”；“大概”；“晚些时候”；“或者”；“说不定”之类放在嘴边。尤其是和上级谈论工作的时候。
　　
　　我十分痛恨听到的一句话是：“我晚些时候会把这个文件发给所有的人”；因为这往往预示着我必须时刻提醒他不要忘记。同样，以下这些言辞也会让人觉得厌恶至极：
　　“到时候有人会把那些东西都准备好”
　　“大概是明天”
　　“明天或者后天客户会过来拜访”
　　“好像他说……”
　　
　　一般是人都会这样说话的，因为这样第一给自己留下了广阔的余地，第二也不会给别人造成很大的压迫感，好像什么事情一定要弄个水落石出似的。说实话大学里面再用功的人都有一半是混的。一个人要么是在课堂上是混的，要么下课之后是混的。两个都没有带有混的色彩的人，要么是超级牛人，要么是神经病。所以，就因为人人都在混的，所以校园是一个浪漫的地方，校园也容易让人单纯。所以学生社团的工作往往是效率很低的，我现在回想起学校里做的工作，当时还觉得挺卖力的，但工作了之后才开始感觉到什么是效率。当你进入了用金钱计算时间的地方之后，你要尽可能的避免在学校里养成的这种习惯。如果上级问你什么时候能实施你给他的承诺，而你回答“今晚或者明天早上”这样的答案对于他来说完全等同于你没有回答，并且还给他留下了一个坏印象。（当然，这样的回答往往在学校社团，学生会工作中是常见的）
　　
　　有一个寓言故事，一只小老鼠刚刚出世不久，老鼠妈妈问小老鼠：你现在能看见了吗？ 小老鼠说：能。 老鼠妈妈说：那你能看到那块红薯吗？ 小老鼠说：是的。老鼠妈妈说：那是一块石头，这说明你不但还看不见东西，你连嗅觉都还没有。
　　
　　似是而非的应答往往一样会暴露出你更多的弱点。可能是以下中的一个或几个：
　　1.你之前没有想到这个工作，或者一直在拖延。
　　2.你没有责任心，认为这些并不重要。
　　3.你应付上级。
　　4.你不敢说真话。
　　5.你喜欢逞能，答应一些做不到的事情。
　　6.你不能独立工作。
　　
　　当你的上级在以上选项中怀疑的时候，潜意识中你已经同时具备了以上所有的弱点了。
　　
　　相反的看来，这样的回答，总是让上司恼火。
　　第一，他的问题没有得到回答，只是起到了提醒你的作用。
　　第二，他依然需要记住提醒你，因为他不知道你是否真正已经落实了工作。
　　第三，他不知道有多少你已经做了的事情中，都是这样没有落实的。（这点非常致命）
　　第四，往往因为没有得到满意的答案，上司自己的计划不得不被耽搁或推迟或不能给出明朗的结束时间。
　　
　　所以---------
　　甲问：你什么时候能把要这个漏洞修好？
　　乙说：我已经通知他们了，他们大概明天就会来修的。
　　一天后
　　甲问：维修公司什么时候回来，你找的是哪家维修公司？
　　乙说：好像他们说安排不出人来，如果可以的话，今天晚上或者明天下午就能过来。
　　一天后
　　甲问：漏洞怎么还没有修好？
　　乙说：我晚点再问问他们。
　　甲说：今天下午之前不解决，明天不用来上班了。 
　　
　　
　　第三：不要拖延工作
　　
　　很多人喜欢在学习和玩耍之间先选择后者，然后在最后时间一次性赶工把考试要复习的东西突击完成。但是在工作中请不要养成这样的习惯，因为工作是永远做不完的，容不得你“突击”。又或者，当你在徘徊和彷徨如何实施的时候，你的领导已经看不下去，自己去做了。----这是一个危险的信号。
　　
　　往往我们总是想把事情从头到尾全部想好了，才开始走第一步-----就摔倒了。
　　
　　举个例子： 我小学的时候第一次给我一个喜欢的女孩子打电话的时候，想象了各种情况-------1，她接电话的时候在做作业。2，她在做作业，她妈妈接的电话。3.她也很无聊，很想找人说话。4.她正在被父母训斥。 5.她正在想另外一个男孩。6.她父亲接电话。 7.她家正好来了什么亲戚，亲戚接了电话。 8.她接了电话，但父母就在身边，说话不方便。。。。。等等等等。我整整想了一个下午，想好了各种情况的心理准备和应对的策略。然后勇敢的拿起电话机，按下了那几个按钮。结果-------她不在家。
　　
　　所以，当你徘徊不前而手足无措的时候，你要意识到你正在拖延工作。徘徊是因为害怕这个事情可能发生的后果需要自己承担或应付。工作的时候需要一种起码的自信，相信自己有能力，不管下一步是什么状况，我都能把它引导到我需要的那条线上去的。另外，告诉自己，不要想太多时间，如果不知道，就赶快求助，或想办法，苦恼和忧虑会给你更多的压力也会把剩下的时间蚕食殆尽。
　　
　　
　　另外，警告一下：永远不要想，我知道了，先把上级派的事情放一下，等这集《越狱》看完再说。----90%的情况下，你会忘记，或者来不及，因为这件事需要比你原先想象要更多的时间。说做就做，一直是很好的习惯。 
　　
　　
　　第四：不要认为理论上可以实施就大功告成了！
　　
　　这点太重要了，往往当真正实施的人开始做了才会发现计划完全等于鬼话。如果不亲自实践，做计划的人会早晚被实施的鄙视。永远需要提升自己的办实事的能力，而不是空谈。
　　
　　首先，如果你是做办公室工作的，或者做策划和计划的。请千万不要把你自己都认为不太可能或者很难做到的事情，让别人试试看。比如，用一个下午的时间在人流量很少的地方举办露天歌唱会。这会让执行的人觉得你在玩他，拿他做实验。没错，理论上，在任何地方都能举办歌唱会，但是，在不同的地方，执行的人的心情是不一样的。
　　
　　其次，和执行的人讨论你的安排。比如，新来的你的下属，你可以安排她坐在任何地方，但是如果那是一个很难和大家接触的角落，这可能比你什么都不安排更差。的确，理论上一个人要坐下来，需要的只是空间。但事实上远远不止那些。
　　
　　再次，不要奢望一切会随着你的计划进行。理论上这个会议会持续两个小时，但是，这是“不考虑在开场后的30分钟全场都在调试话筒”，或者“场下没有提出如此尖锐的问题”的前提下的状态。 大学生已经习惯了把事情做到 "理论上看上去很美"的程度了。 论文，ppt讲演，考试，辩论赛…… 这些校园智商大比拼，都是教我们如何完美的做好“纸上谈兵”的功夫。 你一定要相信自己能“搞定”事情的能力比想象的弱。
　　
　　如果你是在学校的学生，测试一下自己，能否能搞定以下这些状况：
　　1.学校要制作一套校服，由你去寻找供应商，砍价，至少有三家公司的报价。
　　2.学校保安抓住一个学生偷窃，怎么处理？
　　3.学校的一个很重要路段的路灯坏了，你能否让它三天内继续亮起来。
　　4.食堂需要请一位专门烧清真菜的厨师，一周内到岗位。
　　
　　当你开始思考以上这样的问题的时候，你会发现，他的思路和“看过去两年这个公司的业绩趋向，做出一个下个季度的市场策划方案”要相差极大。你会发现后者只要你做到“看上去很完美”，没有人知道按照你这样做结果会怎样。而上述的工作你只要一想，就会体会到不少的压力。因为你不处理好，结果就是明显的失败更大的问题就会相继发生。
　　对了，这种感觉就是“工作”给你的感觉！这就是“工作”和“纸上谈兵”的差别！ 
　　
　　
　　第五：不要让别人等你
　　
　　在任何情况下都不要让别人放下手头的工作来等你。在大学中可能只是同寝室的人的几句半开玩笑的抱怨，在工作上很可能导致你的潜在合作伙伴的丢失。
　　
　　你在做一个工作的同时要知道别人的进度，而永远不要落后。
　　这不像是在考试，你比别人做的慢，别人可以先交卷，你到时间了做不完你自己承受扣分。在工作中的情况是这样的：这是一场没有人能做完的考试，所有的人，都分配做一张试卷的不同部分，有的人分到的是阅读理解，有的人做的是完形填空，有的人做的是语法…… 然后大家做完了相互抄，这样，所有人都做完了。 如果大家都把各自的部分做完了，而你却还在没有做完，那么做得快的别人会开始做你的那部分题目，然后也是相互抄。慢慢地，大家会发现你的工作量完全可以由另外人来代替，整个团队中可以不需要你，这个时候，没有人从你这里得到试卷的答案，也没有人会给你他们的答案--------很不幸，你已经没有利用价值了。
　　
　　请一定记住这个例子。 
　　第六：不要认为细节不重要
　　
　　在大学里，往往做事粗枝大叶，看看差不多就行了。相反，在企业里管理的精髓就在于将简单的事情做到细节。一个慌忙寻找保险箱钥匙的动作就很有可能丧失你晋升财务主管的机会。
　　
　　公司的管理，其实需要的并不是把很难的事情做到90%----比如，优化管理层的核心工作流程、改变公司在当地政府面前的形象，提高产品质量，改善工作环境…… 而管理要做的是把每个简单的事情做到100%-----比如，把公司的每个人的档案都按照一定的规律整齐的存放起来、在门卫设立一个外来人员的签到台、把会议室多余的椅子拿走、和电视台讲好下个礼拜三来公司做采访、把试用装送到客户手里、在生产的咖啡上加一个口子、给下一期的封面人物拍照……等等如此。 如果你能把所有细节的问题都如实做到，那你才有开口升职的本钱。
　　
　　很多人在毕业的时候不知道自己将来要做什么，于是就和自己说：我以后做管理吧！做管理？问一下自己，如果，公司资产被偷窃了，所有员工士气低下，办公室杂乱无章，公司电梯又坏了，打印机没墨了，采购计划超支了，产品滞销了，客户迟到了……你愿意解决这样的问题，并从小事开始做起吗？想好了这些再考虑是否把管理看得太空洞了。 
　　

　　第七：不要表现得消极，仅仅因为你所做的事情不是你的兴趣所在。
　　
　　很显然，在学生时代，当做到自己喜欢的时候，我们会pay200%的精力去创造，但如果是枯燥的事务，我们便懒得理睬，最好能有办法应付过去。但在工作上80%你所做的事情都是繁琐而看似机械的，如果仅仅为此而表现的闷闷不乐，那么你会郁闷更久。要知道你的上司已经为这个项目够烦恼了，你还想让他看到你的表情吗？
　　
　　学会喜欢自己的工作，并把注意力放在日常工作能学到些什么上去。如果现在你努力的抱怨工作，那么接下来你就是努力的寻找工作。尽量少用“有趣”，“好奇”之类的词语来描述自己想要的工作，而是“充实”，“有成就感”，“乐意”
　　之类。
　　想想以下职位，你会发现生活中很多工作不是在等你有很好的状态下让你做的很有趣的事情：
　　1.高速公路收费口的收费员：一天都是面对一个小窗口，把一张卡片送出去，这样要持续好几年。
　　2.学校食堂厨师：永远在烧大排和鸡腿。烧一年。
　　3.作家：交稿期要到了，我还在孕育灵感，两个星期没吃早饭了。
　　4.外科医生：刚刚睡着，马上叫我做一个3小时的手术。这样至少一周一次。
　　5.门市部销售：产品不好卖，8点上班来就坐在店门口，一个人，坐到晚上6点，今天没有一个人来，和昨天一样。
　　6.公交司机：我开车不用你指挥。这条线路我开了三年了。
　　7.宠物商店店员：生意不好，还要一早就过来听着20条狗的叫声一整天，听一年。
　　8.公司职员：晚上两点下班，第二天还要8点上班。关键是路上还要一小时。这样已经一个月了。
　　
　　再想想自己是不是只是接触了这个工作一个月或者才碰到没几个困难，这个时候抱怨的声音最大。
　　千万不要想着去选择一个有趣的职业，因为没有那样的工作存在。没有哪一“种”行业是开心的，因为如果有，那所有人都去干那个了。最多试着问问自己本身的兴趣吧。self exploration。 
　　
　　
　　第八：绝对不要把改善工作能力仅寄托在公司培训上
　　
　　人绝对不可能经过一次培训就脱胎换骨。相反，集体培训上学到的东西往往是最用不上的信息。 就像食堂烧大锅菜一样，总没有你最想吃的菜，因为这样做容易，并且不容易得罪人。
　　
　　很多学生很看重所选的公司有没有培训，这说明，你不但不知道这个公司做什么，你甚至不知道怎样学习这些技能。
　　我的感悟是如果你不知道怎么学你想要的知识，也不知道你想要的知识是什么，你只会做出两种行为：1。等待别人来教你，并且等待别人发现你不知道的地方。2.寻找现成的答案并且拷贝。期待公司培训的人，就很大概率上是第一种人（不排除极少真正优秀的公司培训）
　　
　　许多的同学有这样的习惯思维：
　　因为，这个公司的培训能结束达到多少多少的程度
　　又因为，这个程度正好是我想达到的
　　所以我尽力进这家公司
　　因为我进了这家公司
　　所以它自然会使我达到了这个期望的程度。
　　
　　我们把参加培训和达到效果很幼稚的画上了等号。其实往往集体培训上所得到的信息是最没有实际操作价值的。永远不要期望单靠听课，靠老师把同样的东西给所有的人，你会得到比别人更多。把更多的心思放在观察和思考自己的需要上，找到问题的所在再通过观察和实践得到的答案才是真正的知识。
　　
　　所以，刚刚开始工作，什么都不会，不要认为那样是正常的，因为公司还没有培训过呢！等我接受培训了之后，我就全都会了。如果你一无所知还等待别人会可怜你的无知而施舍你知识，那你会为你的无知而付出更多的智商。 
　　
　　
　　第九：不要推卸责任
　　
　　推卸责任是害怕的条件反射。不要认为别人看不出这点。
　　
　　我记得我小学里的一件事情。我一次作业没有带来，老师要训斥我，说：你怎么老是作业不带？
　　我当时说：不是。。。。 当我正要支支吾吾时候，老师说：什么不是？你带来了没有？
　　我说：没有
　　老师说：那不就是没有带！什么不是！就是！
　　
　　之后我就发现，我只是害怕承担责任而条件反射似的就说了“不是”，仔细观察一下周围，你会发现，身边有无数的人在用“不是”作为被责问之后的第一反应。
　　其实现在很多人面对工作也是这样，当上级责问的时候，很条件反射的就做出了推卸动作，然而这样的动作，接下来往往是无力的辩解，以及一些很粗糙的借口。这样会让上司感到你这个人很难沟通，并且很不真实。
　　
　　
　　另外一种情况，就是无论什么情况下，我指责一个人，他永远是强调客观。其实这点才是学生最典型的特征。这说明他太容易受到其他事物的影响，并受它们决定。如果你和上司之间会出现以下类型的对话，想想是不是需要改一下你的处事方法。
　　
　　甲：为什么到现在还没有给副总看你的报告！
　　乙：刚才c在打印，我在等他结束，现在他大概好了吧，我去看看
　　乙：还有点东西要修改
　　乙：b也要把东西给副总，我因为等他
　　乙：a他说我报告不用给副总看（a是乙的同级同事）
　　乙：不知道副总在不在哦，他的门关着。
　　乙：d他叫我帮他打印文件！怪他！（d是乙的同级同事）
　　乙：我的杯子突然找不到了，在找杯子。
　　
　　
　　不愿意负责任的人的不利在于他会让上司怀疑他的忠诚程度，因为上司给他的命令往往会因为一个小事情而被搁置或者打折执行，转而被他人的意识所改变。 
　　
　　
　　第十：不要对自己说“我是大学生”
　　
　　这点包涵了很多信息。
　　1.不要认为自己有多清高
　　2.不要仍然以学生的标准要求自己
　　3.不要感觉低人一等
　　4.不要等待别人的关怀
　　5.不要把这个作为犯错误自我安慰的借口
　　6.不要忘记搞清楚，公司究竟给自己的待遇是多少，老练些，这不是在做志愿者。
　　
　　品格是处理好人际关系的基础，也是确保人际关系质量的关键。除此之外，人际交往的技巧也是尤为重要的。有些人做好事会让人感激一辈子，而有些人帮了别人却可能费力不讨好，不但得不到感激和回报，还让人心存嫉恨。将同样的产品以相同的价格推销给同一个客户，有些业务员可能被粗暴地赶出门，有些业务员却可能签到大单，甚至被客户奉为上宾。 
　　人际交往的技巧是一个非常庞杂的话题，囿于篇幅，在这里只能结合我的切身体会做一些简单的列举，挂一漏万在所难免了。 
　　1. 多给别人鼓励和表扬，尽量避免批评、指责和抱怨，不要逼别人认错。 
　　2. 要学会倾听。不要说得太多，想办法让别人多说。 
　　3. 如果你要加入别人的交谈，先要弄清楚别人究竟在说什么。 
　　4. 交谈之前尽量保持中立、客观。表明自己的倾向之前先要弄清楚对方真实的倾向。 
　　5. 注意对方的社交习惯并适当加以模仿。 
　　6. 不要轻易打断、纠正、补充别人的谈话。 
　　7. 别人有困难时，主动帮助，多多鼓励。 
　　8. 不要因为对方是亲朋好友而不注意礼节。 
　　9. 尽可能谈论别人想要的，教他怎样去得到他想要的。 
　　10. 始终以微笑待人。 
　　11. 做一个有幽默感的人。但是在讲笑话的时候千万不要只顾着自己笑。 
　　12. 做一个脱离低级趣味的人。 
　　13. 跟别人说话的时候尽量看着对方的眼睛，不管你是在说还是在听。 
　　14. 转移话题要尽量不着痕迹。 
　　15. 要学会聆听对方的弦外之音。也要学会通过弦外之音来委婉地表达自己的意思。 
　　16. 拜访别人一定要事先通知。 
　　17. 不要在别人可能忙于工作或者休息的时候打电话过去。除非是非常紧急的事情。 
　　18. 给别人打电话的时候，先问对方是否方便通话。 
　　19. 一件事情让两个人知道就不再是秘密。 
　　20. 你在背后说任何人的坏话都迟早有一天传入这个人的耳朵。 
　　21. 不要说尖酸刻薄的话。 
　　22. 牢记他人的名字。养成偶尔翻看名片簿、电话本的习惯。 
　　23. 尝试着跟你讨厌的人交往。 
　　24. 一定要尊重对方的隐私，不管是朋友还是夫妻。 
　　25. 很多人在一起的时候，当你与其中某个人交谈，请不要无视其他人的存在。 
　　26. 要勇于认错。 
　　27. 以谦卑的姿态面对身边的每一个人。 
　　28. 给予他人同情和谅解。 
　　29. 尽可能用“建议”取代“命令”。 
　　30. 不要轻易做出承诺。承诺的事情就一定要尽可能做到。


凡是有该标志的文章，都是该blog博主Caoer（草儿）原创，凡是索引、收藏
、转载请注明来处和原文作者。非常感谢。
--
[ 请排好队观赏本文作者亲手绘制的头像(点击下图浏览画图过程),并有秩序的发出赞叹声 ]
http://spaces.msn.com/atian25  or  <a target="_blank" href="http://822112.qzone.qq.com">http://822112.qzone.qq.com</a>

生命可能很短,故事却可以很精彩! 


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 121.8.124.*]
 
【文章标题】：请教大侠，下面这段调试结果说明什么问题？急等赐教 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30426 【创建时间】：2008-10-11 【作者】：jonnezhou 【评论】：7 【内容】：发信人: jonnezhou (当小虾遇到彩虹), 信区: SoftDesign
标  题: 请教大侠，下面这段调试结果说明什么问题？急等赐教
发信站: 北邮人论坛 (Sat Oct 11 10:39:30 2008), 站内

(gdb) run test-igmp.tcl
Starting program: /home/jonne/ns-allinone-2.33/ns-2.33/IGMP-SIM/ns.exe test-igmp
.tcl
[New thread 1160.0xf48]
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
[New thread 1160.0xed8]
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
(no debugging symbols found)
Error: Cannot open shared library: No such file or directory
(no debugging symbols found)

Program exited with code 01.

这是在用gdb调试一个脚本代码的时候出现的问题。
焦点在三个地方：
1.我看上面有两个线程，是说我实际定了两个线程吗（我还不怎么会多线程编程呢）？
2.Cannot open shared library 这是什么意思？
3.Program exited with code 01.这又是什么意思？
--
正因为自己很平凡，才有动力让自己变得更好。

我的韩版镶钻DIY个性饰品店，有空来光顾哦，说不定有你喜欢的哟：）
http://forum.byr.edu.cn/wForum/disparticle.php?boardName=Ad_Agent&amp;ID=321233&amp;pos=23&amp;page=1[/URL]


※ 修改:·jonnezhou 于 Oct 11 10:44:26 修改本文·[FROM: 118.229.154.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 118.229.154.*]
 
【文章标题】：推荐一本好书《windows核心编程》第5版 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30425 【创建时间】：2008-10-11 【作者】：bravejin 【评论】：13 【内容】：发信人: bravejin (菜虫), 信区: SoftDesign
标  题: 推荐一本好书《windows核心编程》第5版
发信站: 北邮人论坛 (Sat Oct 11 10:37:28 2008), 站内

刚出的新版，昨买了一本，相对从前的这本翻译好了非常多，不像以前的那么晦涩（大概由于是微软内部人士参加翻译的缘故）。纸张什么的也不错。现正浸淫其中……

--
夏天在阴凉的树荫下听歌，冬天在温暖的炉火边看书，啊! Where did the good times go？

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.151.*]
 
【文章标题】：[注意][重要]amiao必须入[其他人随意] 【文章地址】：https://bbs.byr.cn/article/SoftDesign/26836 【创建时间】：2008-06-14 【作者】：UnrealT 【评论】：22 【内容】：发信人: UnrealT (MOMO|A100100), 信区: SoftDesign
标  题: [注意][重要]amiao必须入[其他人随意]
发信站: 北邮人论坛 (Sat Jun 14 00:29:56 2008), 站内

#include &lt;stdio.h&gt;
void main(){char* str="k3K2P3422222922222&lt;222229222228222228233228252424242428252826262427322825242424242825282626242732282524242424282528262624273422222324242424262222232622222822222822233{3t273v233";for(int i=0;str[i];i+=2)printf("%*.*s",str[i]-48,str[i+1]-48,"_/\n");}


嗯，运行一下就可以看到结果了
为了方便大家，这个程序就不弄得过于隐晦了，不写成那种只有ANSI C才能运行的方式

--
Mars　　在无限的　　─┼───┼──┼──┼────┼────┼───┼─→
QMD:　　时间长河　　　↑　　　元　　泥　　侏　　　　公　　　　公　　　公
NO 3　　中………　　　楼　　　古　　盆　　罗　　　　元　　　　元　　　元
　　　　　　　　　　　主　　　代　　纪　　纪　　　　元　　　 2000　　2005
　　　　　　　　　　　贴　　　　　　　　　　　　　　年　　　　年　　　年
　　　　　　　　　　　子


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 123.113.241.*]
 
【文章标题】：BAFP vs LBYL. Which do you prefer? 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30443 【创建时间】：2008-10-11 【作者】：wks 【评论】：10 【内容】：发信人: wks (cloverprince), 信区: SoftDesign
标  题: BAFP vs LBYL. Which do you prefer?
发信站: 北邮人论坛 (Sat Oct 11 23:52:15 2008), 站内

Which one do you prefer, BAFP or LBYL?

BAFP = "Better to Ask for Forgiveness than Permission"
LBYL = "Look Before You Leap"

Choose one.
Trust your intuition.

--
いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす
the quick brown fox jumps over a lazy dog

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 202.91.182.*]
 
【文章标题】：[ZT]C++风格与技巧 【文章地址】：https://bbs.byr.cn/article/SoftDesign/104 【创建时间】：2005-04-27 【作者】：UnrealT 【评论】：0 【内容】：发信人: UnrealT (wahaha), 信区: SoftDesign
标  题: [ZT]C++风格与技巧
发信站: 北邮人论坛 (Wed Apr 27 20:49:59 2005), 站内

C++风格与技巧

（译注：本文的翻译相当艰苦。Bjarne Stroustrup不愧是创立C++语言的一代大师，不但思想博大精深，而且在遣词造句上，也非常精微深奥。有很多地方，译者反复斟酌，都不能取得理想的效果，只能尽力而为。 

Html格式的文档见译者主页：<a target="_blank" href="http://www.wushuang.net">http://www.wushuang.net</a>

如果你对这个翻译稿有任何意见和建议，请发信给译者：onekey@163.com。

原文的地址为：<a target="_blank" href="http://www.research.att.com/~bs/bs_faq.html">http://www.research.att.com/~bs/bs_faq.html</a>）


（Bjarne Stroustrup博士，1950年出生于丹麦，先后毕业于丹麦阿鲁斯大学和英国剑挢大学，AT&amp;T大规模程序设计研究部门负责人，AT&amp;T 贝尔实验室和ACM成员。1979年，B. S开始开发一种语言，当时称为"C with Class"，后来演化为C++。1998年，ANSI/ISO C++标准建立，同年，B. S推出其经典著作The C++ Programming Language的第三版。）


这是一些人们经常向我问起的有关C++的风格与技巧的问题。如果你能提出更好的问题，或者对这些答案有所建议，请务必发Email给我(bs@research.att.com)。请记住，我不能把全部的时间都花在更新我的主页上面。


更多的问题请参见我的general FAQ。


关于术语和概念，请参见我的C++术语表（C++ glossary.）。


请注意，这仅仅是一个常见问题与解答的列表。它不能代替一本优秀教科书中那些经过精心挑选的范例与解释。它也不能象一本参考手册或语言标准那样，提供详细和准确的说明。有关C++的设计的问题，请参见《C++语言的设计和演变》（The Design and Evolution of C++）。关于C++语言与标准库的使用，请参见《C++程序设计语言》（The C++ Programming Language）。


目录：

我如何写这个非常简单的程序？

为什么编译要花这么长的时间？

为什么一个空类的大小不为0？

我必须在类声明处赋予数据吗？

为什么成员函数默认不是virtual的？

为什么析构函数默认不是virtual的？

为什么不能有虚拟构造函数？

为什么重载在继承类中不工作？

我能够在构造函数中调用一个虚拟函数吗？

有没有“指定位置删除”(placement delete)？

我能防止别人继承我自己的类吗？

为什么不能为模板参数定义约束（constraints）？

既然已经有了优秀的qsort()函数，为什么还需要一个sort()？

什么是函数对象（function object）？

我应该如何对付内存泄漏？

我为什么在捕获一个异常之后就不能继续？

为什么C++中没有相当于realloc()的函数？

如何使用异常？

怎样从输入中读取一个字符串？

为什么C++不提供“finally”的构造？

什么是自动指针（auto_ptr），为什么没有自动数组（auto_array）？

可以混合使用C风格与C++风格的内存分派与重新分配吗？

我为什么必须使用一个造型来转换*void？

我如何定义一个类内部（in-class）的常量？

为什么delete不会将操作数置0？

我能够写“void main()”吗？

为什么我不能重载点符号，::，sizeof，等等？

怎样将一个整型值转换为一个字符串？

“int* p”正确还是“int *p”正确？

对于我的代码，哪一种布局风格（layout style）是最好的？

我应该将“const”放在类型之前还是之后？

使用宏有什么问题？


我如何写这个非常简单的程序？


特别是在一个学期的开始，我常常收到许多关于编写一个非常简单的程序的询问。这个问题有一个很具代表性的解决方法，那就是（在你的程序中）读入几个数字，对它们做一些处理，再把结果输出。下面是一个这样做的例子：


#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;algorithm&gt;

using namespace std;


int main()

{

vector&lt;double&gt; v;


double d;

while(cin&gt;&gt;d) v.push_back(d); // 读入元素

if (!cin.eof()) { // 检查输入是否出错

cerr &lt;&lt; "format error\n";

return 1; // 返回一个错误

}


cout &lt;&lt; "read " &lt;&lt; v.size() &lt;&lt; " elements\n";


reverse(v.begin(),v.end());

cout &lt;&lt; "elements in reverse order:\n";

for (int i = 0; i&lt;v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\n';


return 0; // 成功返回

}


对这段程序的观察：


这是一段标准的ISO C++程序，使用了标准库(standard library)。标准库工具在命名空间std中声明，封装在没有.h后缀的头文件中。


如果你要在Windows下编译它，你需要将它编译成一个“控制台程序”（console application）。记得将源文件加上.cpp后缀，否则编译器可能会以为它是一段C代码而不是C++。


是的，main()函数返回一个int值。


读到一个标准的向量(vector)中，可以避免在随意确定大小的缓冲中溢出的错误。读到一个数组(array)中，而不产生“简单错误”(silly error)，这已经超出了一个新手的能力——如果你做到了，那你已经不是一个新手了。如果你对此表示怀疑，我建议你阅读我的文章“将标准C++作为一种新的语言来学习”("Learning Standard C++ as a New Language")，你可以在本人著作列表(my publications list)中下载到它。


!cin.eof()是对流的格式的检查。事实上，它检查循环是否终结于发现一个end-of-file(如果不是这样，那么意味着输入没有按照给定的格式)。更多的说明，请参见你的C++教科书中的“流状态”(stream state)部分。


vector知道它自己的大小，因此我不需要计算元素的数量。


这段程序没有包含显式的内存管理。Vector维护一个内存中的栈，以存放它的元素。当一个vector需要更多的内存时，它会分配一些；当它不再生存时，它会释放内存。于是，使用者不需要再关心vector中元素的内存分配和释放问题。


程序在遇到输入一个“end-of-file”时结束。如果你在UNIX平台下运行它，“end-of-file”等于键盘上的Ctrl+D。如果你在Windows平台下，那么由于一个BUG它无法辨别“end-of-file”字符，你可能倾向于使用下面这个稍稍复杂些的版本，它使用一个词“end”来表示输入已经结束。


#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;algorithm&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

vector&lt;double&gt; v;


double d;

while(cin&gt;&gt;d) v.push_back(d); // 读入一个元素

if (!cin.eof()) { // 检查输入是否失败

cin.clear(); // 清除错误状态

string s;

cin &gt;&gt; s; // 查找结束字符

if (s != "end") {

cerr &lt;&lt; "format error\n";

return 1; // 返回错误

}

}


cout &lt;&lt; "read " &lt;&lt; v.size() &lt;&lt; " elements\n";


reverse(v.begin(),v.end());

cout &lt;&lt; "elements in reverse order:\n";

for (int i = 0; i&lt;v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt; '\n';


return 0; // 成功返回

}


更多的关于使用标准库将事情简化的例子，请参见《C++程序设计语言》中的“漫游标准库”("Tour of the Standard Library")一章。


为什么编译要花这么长的时间？


你的编译器可能有问题。也许它太老了，也许你安装它的时候出了错，也许你用的计算机已经是个古董。在诸如此类的问题上，我无法帮助你。


但是，这也是很可能的：你要编译的程序设计得非常糟糕，以至于编译器不得不检查数以百计的头文件和数万行代码。理论上来说，这是可以避免的。如果这是你购买的库的设计问题，你对它无计可施（除了换一个更好的库），但你可以将你自己的代码组织得更好一些，以求得将修改代码后的重新编译工作降到最少。这样的设计会更好，更有可维护性，因为它们展示了更好的概念上的分离。


看看这个典型的面向对象的程序例子：


class Shape {

public: // 使用Shapes的用户的接口

virtual void draw() const;

virtual void rotate(int degrees);

// ...

protected: // common data (for implementers of Shapes)

Point center;

Color col;

// ...

};


class Circle : public Shape {

public: 

void draw() const;

void rotate(int) { }

// ...

protected:

int radius;

// ...

};


class Triangle : public Shape {

public: 

void draw() const;

void rotate(int);

// ...

protected:

Point a, b, c;

// ...

}; 


设计思想是，用户通过Shape的public接口来操纵它们，而派生类（例如Circle和Triangle）的实现部分则共享由protected成员表现的那部分实现（implementation）。


这不是一件容易的事情：确定哪些实现部分是对所有的派生类都有用的，并将之共享出来。因此，与public接口相比，protected成员往往要做多得多的改动。举例来说，虽然理论上“中心”(center)对所有的图形都是一个有效的概念，但当你要维护一个三角形的“中心”的时候，是一件非常麻烦的事情——对于三角形，当且仅当它确实被需要的时候，计算这个中心才是有意义的。


protected成员很可能要依赖于实现部分的细节，而Shape的用户（译注：user此处译为用户，指使用Shape类的代码，下同）却不见得必须依赖它们。举例来说，很多（大多数？）使用Shape的代码在逻辑上是与“颜色”无关的，但是由于Shape中“颜色”这个定义的存在，却可能需要一堆复杂的头文件，来结合操作系统的颜色概念。


当protected部分发生了改变时，使用Shape的代码必须重新编译——即使只有派生类的实现部分才能够访问protected成员。


于是，基类中的“实现相关的信息”(information helpful to implementers)对用户来说变成了象接口一样敏感的东西，它的存在导致了实现部分的不稳定，用户代码的无谓的重编译（当实现部分发生改变时），以及将头文件无节制地包含进用户代码中（因为“实现相关的信息”需要它们）。有时这被称为“脆弱的基类问题”(brittle base class problem)。


一个很明显的解决方案就是，忽略基类中那些象接口一样被使用的“实现相关的信息”。换句话说，使用接口，纯粹的接口。也就是说，用抽象基类的方式来表示接口：


class Shape {

public: //使用Shapes的用户的接口

virtual void draw() const = 0;

virtual void rotate(int degrees) = 0;

virtual Point center() const = 0;

// ...


// 没有数据

};


class Circle : public Shape {

public: 

void draw() const;

void rotate(int) { }

Point center() const { return center; }

// ...

protected:

Point cent;

Color col;

int radius;

// ...

};


class Triangle : public Shape {

public: 

void draw() const;

void rotate(int);

Point center() const;

// ...

protected:

Color col;

Point a, b, c;

// ...

}; 


现在，用户代码与派生类的实现部分的变化之间的关系被隔离了。我曾经见过这种技术使得编译的时间减少了几个数量级。


但是，如果确实存在着对所有派生类（或仅仅对某些派生类）都有用的公共信息时怎么办呢？可以简单把这些信息封装成类，然后从它派生出实现部分的类：


class Shape {

public: //使用Shapes的用户的接口

virtual void draw() const = 0;

virtual void rotate(int degrees) = 0;

virtual Point center() const = 0;

// ...


// no data

};


struct Common {

Color col;

// ...

};


class Circle : public Shape, protected Common {

public: 

void draw() const;

void rotate(int) { }

Point center() const { return center; }

// ...

protected:

Point cent;

int radius;

};


class Triangle : public Shape, protected Common {

public: 

void draw() const;

void rotate(int);

Point center() const;

// ...

protected:

Point a, b, c;

}; 


为什么一个空类的大小不为0？


要清楚，两个不同的对象的地址也是不同的。基于同样的理由，new总是返回指向不同对象的指针。

看看：


class Empty { };


void f()

{

Empty a, b;

if (&amp;a == &amp;b) cout &lt;&lt; "impossible: report error to compiler supplier";


Empty* p1 = new Empty;

Empty* p2 = new Empty;

if (p1 == p2) cout &lt;&lt; "impossible: report error to compiler supplier";

} 


有一条有趣的规则：一个空的基类并不一定有分隔字节。

struct X : Empty {

int a;

// ...

};


void f(X* p)

{

void* p1 = p;

void* p2 = &amp;p-&gt;a;

if (p1 == p2) cout &lt;&lt; "nice: good optimizer";

}


这种优化是允许的，可以被广泛使用。它允许程序员使用空类以表现一些简单的概念。现在有些编译器提供这种“空基类优化”(empty base class optimization)。


我必须在类声明处赋予数据吗？


不必须。如果一个接口不需要数据时，无须在作为接口定义的类中赋予数据。代之以在派生类中给出它们。参见“为什么编译要花这么长的时间？”。


有时候，你必须在一个类中赋予数据。考虑一下复数类的情况：


template&lt;class Scalar&gt; class complex {

public:

complex() : re(0), im(0) { }

complex(Scalar r) : re(r), im(0) { }

complex(Scalar r, Scalar i) : re(r), im(i) { }

// ...


complex&amp; operator+=(const complex&amp; a)

{ re+=a.re; im+=a.im; return *this; }

// ...

private:

Scalar re, im;

};


设计这种类型的目的是将它当做一个内建（built-in）类型一样被使用。在声明处赋值是必须的，以保证如下可能：建立真正的本地对象（genuinely local objects）(比如那些在栈中而不是在堆中分配的对象)，或者使某些简单操作被适当地inline化。对于那些支持内建的复合类型的语言来说，要获得它们提供的效率，真正的本地对象和inline化都是必要的。


为什么成员函数默认不是virtual的？


因为很多类并不是被设计作为基类的。例如复数类。


而且，一个包含虚拟函数的类的对象，要占用更多的空间以实现虚拟函数调用机制——往往是每个对象占用一个字(word)。这个额外的字是非常可观的，而且在涉及和其它语言的数据的兼容性时，可能导致麻烦(例如C或Fortran语言)。


要了解更多的设计原理，请参见《C++语言的设计和演变》（The Design and Evolution of C++）。


为什么析构函数默认不是virtual的？


因为很多类并不是被设计作为基类的。只有类在行为上是它的派生类的接口时(这些派生类往往在堆中分配，通过指针或引用来访问)，虚拟函数才有意义。


那么什么时候才应该将析构函数定义为虚拟呢？当类至少拥有一个虚拟函数时。拥有虚拟函数意味着一个类是派生类的接口，在这种情况下，一个派生类的对象可能通过一个基类指针来销毁。例如：


class Base {

// ...

virtual ~Base();

};


class Derived : public Base {

// ...

~Derived();

};


void f()

{

Base* p = new Derived;

delete p; // 虚拟析构函数保证~Derived函数被调用

}


如果基类的析构函数不是虚拟的，那么派生类的析构函数将不会被调用——这可能产生糟糕的结果，例如派生类的资源不会被释放。


为什么不能有虚拟构造函数？


虚拟调用是一种能够在给定信息不完全(given partial information)的情况下工作的机制。特别地，虚拟允许我们调用某个函数，对于这个函数，仅仅知道它的接口，而不知道具体的对象类型。但是要建立一个对象，你必须拥有完全的信息。特别地，你需要知道要建立的对象的具体类型。因此，对构造函数的调用不可能是虚拟的。


当要求建立一个对象时，一种间接的技术常常被当作“虚拟构造函数”来使用。有关例子，请参见《C++程序设计语言》第三版15.6.2.节。


下面这个例子展示一种机制：如何使用一个抽象类来建立一个适当类型的对象。


struct F { // 对象建立函数的接口

virtual A* make_an_A() const = 0;

virtual B* make_a_B() const = 0;

};


void user(const F&amp; fac)

{

A* p = fac.make_an_A(); // 将A作为合适的类型

B* q = fac.make_a_B(); // 将B作为合适的类型

// ...

}


struct FX : F {

A* make_an_A() const { return new AX(); } // AX是A的派生

B* make_a_B() const { return new BX(); } // AX是B的派生

};


struct FY : F {

A* make_an_A() const { return new AY(); } // AY是A的派生

B* make_a_B() const { return new BY(); } // BY是B的派生


};


int main()

{

user(FX()); // 此用户建立AX与BX

user(FY()); // 此用户建立AY与BY

// ...

}


这是所谓的“工厂模式”(the factory pattern)的一个变形。关键在于，user函数与AX或AY这样的类的信息被完全分离开来了。


为什么重载在继承类中不工作？


这个问题（非常常见）往往出现于这样的例子中：


#include&lt;iostream&gt;

using namespace std;


class B {

public:

int f(int i) { cout &lt;&lt; "f(int): "; return i+1; }

// ...

};


class D : public B {

public:

double f(double d) { cout &lt;&lt; "f(double): "; return d+1.3; }

// ...

};


int main()

{

D* pd = new D;


cout &lt;&lt; pd-&gt;f(2) &lt;&lt; '\n';

cout &lt;&lt; pd-&gt;f(2.3) &lt;&lt; '\n';

}


它输出的结果是：


f(double): 3.3

f(double): 3.6


而不是象有些人猜想的那样：


f(int): 3

f(double): 3.6


换句话说，在B和D之间并没有发生重载的解析。编译器在D的区域内寻找，找到了一个函数double f(double)，并执行了它。它永远不会涉及（被封装的）B的区域。在C++中，没有跨越区域的重载——对于这条规则，继承类也不例外。更多的细节，参见《C++语言的设计和演变》和《C++程序设计语言》。


但是，如果我需要在基类和继承类之间建立一组重载的f()函数呢？很简单，使用using声明：


class D : public B {

public:

using B::f; // make every f from B available

double f(double d) { cout &lt;&lt; "f(double): "; return d+1.3; }

// ...

};


进行这个修改之后，输出结果将是：


f(int): 3

f(double): 3.6


这样，在B的f()和D的f()之间，重载确实实现了，并且选择了一个最合适的f()进行调用。


我能够在构造函数中调用一个虚拟函数吗？


可以，但是要小心。它可能不象你期望的那样工作。在构造函数中，虚拟调用机制不起作用，因为继承类的重载还没有发生。对象先从基类被创建，“基类先于继承类(base before derived)”。


看看这个：


#include&lt;string&gt;

#include&lt;iostream&gt;

using namespace std;


class B {

public:

B(const string&amp; ss) { cout &lt;&lt; "B constructor\n"; f(ss); }

virtual void f(const string&amp;) { cout &lt;&lt; "B::f\n";}

};


class D : public B {

public:

D(const string &amp; ss) :B(ss) { cout &lt;&lt; "D constructor\n";}

void f(const string&amp; ss) { cout &lt;&lt; "D::f\n"; s = ss; }

private:

string s;

};


int main()

{

D d("Hello");

}


程序编译以后会输出：


B constructor

B::f

D constructor


注意不是D::f。设想一下，如果出于不同的规则，B::B()可以调用D::f()的话，会产生什么样的后果：因为构造函数D::D()还没有运行，D::f()将会试图将一个还没有初始化的字符串s赋予它的参数。结果很可能是导致立即崩溃。


析构函数在“继承类先于基类”的机制下运行，因此虚拟机制的行为和构造函数一样：只有本地定义(local definitions)被使用——不会调用虚拟函数，以免触及对象中的（现在已经被销毁的）继承类的部分。


更多的细节，参见《C++语言的设计和演变》13.2.4.2和《C++程序设计语言》15.4.3。


有人暗示，这只是一条实现时的人为制造的规则。不是这样的。事实上，要实现这种不安全的方法倒是非常容易的：在构造函数中直接调用虚拟函数，就象调用其它函数一样。但是，这样就意味着，任何虚拟函数都无法编写了，因为它们需要依靠基类的固定的创建(invariants established by base classes)。这将会导致一片混乱。


有没有“指定位置删除”(placement delete)？


没有，不过如果你需要的话，可以自己写一个。


看看这个指定位置创建(placement new)，它将对象放进了一系列Arena中；


class Arena {

public:

void* allocate(size_t);

void deallocate(void*);

// ...

};


void* operator new(size_t sz, Arena&amp; a)

{

return a.allocate(sz);

}


Arena a1(some arguments);

Arena a2(some arguments);


这样实现了之后，我们就可以这么写：


X* p1 = new(a1) X;

Y* p2 = new(a1) Y;

Z* p3 = new(a2) Z;

// ...


但是，以后怎样正确地销毁这些对象呢？没有对应于这种“placement new”的内建的“placement delete”，原因是，没有一种通用的方法可以保证它被正确地使用。在C++的类型系统中，没有什么东西可以让我们确认，p1一定指向一个由Arena类型的a1分派的对象。p1可能指向任何东西分派的任何一块地方。


然而，有时候程序员是知道的，所以这是一种方法：


template&lt;class T&gt; void destroy(T* p, Arena&amp; a)

{

if (p) {

p-&gt;~T(); // explicit destructor call

a.deallocate(p);

}

}


现在我们可以这么写：


destroy(p1,a1);

destroy(p2,a2);

destroy(p3,a3);


如果Arena维护了它保存着的对象的线索，你甚至可以自己写一个析构函数，以避免它发生错误。


这也是可能的：定义一对相互匹配的操作符new()和delete()，以维护《C++程序设计语言》15.6中的类继承体系。参见《C++语言的设计和演变》10.4和《C++程序设计语言》19.4.5。


我能防止别人继承我自己的类吗？


可以，但你为什么要那么做呢？这是两个常见的回答：


效率：避免我的函数被虚拟调用

安全：保证我的类不被用作一个基类（例如，保证我能够复制对象而不用担心出事）


根据我的经验，效率原因往往是不必要的担心。在C++中，虚拟函数调用是如此之快，以致于它们在一个包含虚拟函数的类中被实际使用时，相比普通的函数调用，根本不会产生值得考虑的运行期开支。注意，仅仅通过指针或引用时，才会使用虚拟调用机制。当直接通过对象名字调用一个函数时，虚拟函数调用的开支可以被很容易地优化掉。


如果确实有真正的需要，要将一个类封闭起来以防止虚拟调用，那么可能首先应该问问为什么它们是虚拟的。我看见过一些例子，那些性能表现不佳的函数被设置为虚拟，没有其他原因，仅仅是因为“我们习惯这么干”。


这个问题的另一个部分，由于逻辑上的原因如何防止类被继承，有一个解决方案。不幸的是，这个方案并不完美。它建立在这样一个事实的基础之上，那就是：大多数的继承类必须建立一个虚拟的基类。这是一个例子：


class Usable;


class Usable_lock {

friend class Usable;

private:

Usable_lock() {}

Usable_lock(const Usable_lock&amp;) {}

};


class Usable : public virtual Usable_lock {

// ...

public:

Usable();

Usable(char*);

// ...

};


Usable a;


class DD : public Usable { };


DD dd; // 错误: DD::DD() 不能访问

// Usable_lock::Usable_lock()是一个私有成员


(来自《C++语言的设计和演变》11.4.3)


为什么不能为模板参数定义约束（constraints）？


可以的，而且方法非常简单和通用。


看看这个：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


如果出现类型错误，可能是发生在相当复杂的for_each()调用时。例如，如果容器的元素类型是int，我们将得到一个和for_each()相关的含义模糊的错误(因为不能够对对一个int值调用Shape::draw的方法)。


为了提前捕捉这个错误，我这样写：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

Shape* p = c.front(); // accept only containers of Shape*s


for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


对于现在的大多数编译器，中间变量p的初始化将会触发一个易于了解的错误。这个窍门在很多语言中都是通用的，而且在所有的标准创建中都必须这样做。在成品的代码中，我也许可以这样写：


template&lt;class Container&gt;

void draw_all(Container&amp; c)

{

typedef typename Container::value_type T;

Can_copy&lt;T,Shape*&gt;(); // accept containers of only Shape*s


for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));

}


这样就很清楚了，我在建立一个断言(assertion)。Can_copy模板可以这样定义：


template&lt;class T1, class T2&gt; struct Can_copy {

static void constraints(T1 a, T2 b) { T2 c = a; b = a; }

Can_copy() { void(*p)(T1,T2) = constraints; }

};


Can_copy(在运行时)检查T1是否可以被赋值给T2。Can_copy&lt;T,Shape*&gt;检查T是否是Shape*类型，或者是一个指向由Shape类公共继承而来的类的对象的指针，或者是被用户转换到Shape*类型的某个类型。注意这个定义被精简到了最小：


一行命名要检查的约束，和要检查的类型

一行列出指定的要检查的约束(constraints()函数)

一行提供触发检查的方法(通过构造函数)


注意这个定义有相当合理的性质：


你可以表达一个约束，而不用声明或复制变量，因此约束的编写者可以用不着去设想变量如何被初始化，对象是否能够被复制，被销毁，以及诸如此类的事情。(当然，约束要检查这些属性的情况时例外。)

使用现在的编译器，不需要为约束产生代码

定义和使用约束，不需要使用宏

当约束失败时，编译器会给出可接受的错误信息，包括“constraints”这个词（给用户一个线索），约束的名字，以及导致约束失败的详细错误（例如“无法用double*初始化Shape*”）。


那么，在C++语言中，有没有类似于Can_copy——或者更好——的东西呢？在《C++语言的设计和演变》中，对于在C++中实现这种通用约束的困难进行了分析。从那以来，出现了很多方法，来让约束类变得更加容易编写，同时仍然能触发良好的错误信息。例如，我信任我在Can_copy中使用的函数指针的方式，它源自Alex Stepanov和Jeremy Siek。我并不认为Can_copy()已经可以标准化了——它需要更多的使用。同样，在C++社区中，各种不同的约束方式被使用；到底是哪一种约束模板在广泛的使用中被证明是最有效的，还没有达成一致的意见。


但是，这种方式非常普遍，比语言提供的专门用于约束检查的机制更加普遍。无论如何，当我们编写一个模板时，我们拥有了C++提供的最丰富的表达力量。看看这个：


template&lt;class T, class B&gt; struct Derived_from {

static void constraints(T* p) { B* pb = p; }

Derived_from() { void(*p)(T*) = constraints; }

};


template&lt;class T1, class T2&gt; struct Can_copy {

static void constraints(T1 a, T2 b) { T2 c = a; b = a; }

Can_copy() { void(*p)(T1,T2) = constraints; }

};


template&lt;class T1, class T2 = T1&gt; struct Can_compare {

static void constraints(T1 a, T2 b) { a==b; a!=b; a&lt;b; }

Can_compare() { void(*p)(T1,T2) = constraints; }

};


template&lt;class T1, class T2, class T3 = T1&gt; struct Can_multiply {

static void constraints(T1 a, T2 b, T3 c) { c = a*b; }

Can_multiply() { void(*p)(T1,T2,T3) = constraints; }

};


struct B { };

struct D : B { };

struct DD : D { };

struct X { };


int main()

{

Derived_from&lt;D,B&gt;();

Derived_from&lt;DD,B&gt;();

Derived_from&lt;X,B&gt;();

Derived_from&lt;int,B&gt;();

Derived_from&lt;X,int&gt;();


Can_compare&lt;int,float&gt;();

Can_compare&lt;X,B&gt;();

Can_multiply&lt;int,float&gt;();

Can_multiply&lt;int,float,double&gt;();

Can_multiply&lt;B,X&gt;();


Can_copy&lt;D*,B*&gt;();

Can_copy&lt;D,B*&gt;();

Can_copy&lt;int,B*&gt;();

}


// 典型的“元素必须继承自Mybase*”约束:


template&lt;class T&gt; class Container : Derived_from&lt;T,Mybase&gt; {

// ...

};


事实上，Derived_from并不检查来源（derivation），而仅仅检查转换（conversion），不过这往往是一个更好的约束。为约束想一个好名字是很难的。


既然已经有了优秀的qsort()函数，为什么还需要一个sort()？


对于初学者来说，


qsort(array,asize,sizeof(elem),elem_compare);


看上去太古怪了，而且比这个更难理解：


sort(vec.begin(),vec.end());


对于专家来说，在元素与比较方式（comparison criteria）都相同的情况下，sort()比qsort()更快，这是很重要的。而且，qsort()是通用的，所以它可以用于不同容器类型、元素类型、比较方式的任意有意义的组合。举例来说：


struct Record {

string name;

// ...

};


struct name_compare { // 使用"name"作为键比较Record

bool operator()(const Record&amp; a, const Record&amp; b) const

{ return a.name&lt;b.name; }

};


void f(vector&lt;Record&gt;&amp; vs)

{

sort(vs.begin(), vs.end(), name_compare());

// ...

} 


而且，很多人欣赏sort()是因为它是类型安全的，使用它不需要进行造型（cast），没有人必须去为基本类型写一个compare()函数。


更多的细节，参见我的文章《将标准C++作为一种新的语言来学习》（Learning C++ as a New language），可以从我的文章列表中找到。


sort()胜过qsort()的主要原因是，比较操作在内联（inlines）上做得更好。


什么是函数对象（function object）？


顾名思义，就是在某种方式上表现得象一个函数的对象。典型地，它是指一个类的实例，这个类定义了应用操作符operator()。


函数对象是比函数更加通用的概念，因为函数对象可以定义跨越多次调用的可持久的部分（类似静态局部变量），同时又能够从对象的外面进行初始化和检查（和静态局部变量不同）。例如：


class Sum {

int val;

public:

Sum(int i) :val(i) { }

operator int() const { return val; } // 取得值


int operator()(int i) { return val+=i; } // 应用

};


void f(vector v)

{

Sum s = 0; // initial value 0

s = for_each(v.begin(), v.end(), s); // 求所有元素的和

cout &lt;&lt; "the sum is " &lt;&lt; s &lt;&lt; "\n";


//或者甚至：

cout &lt;&lt; "the sum is " &lt;&lt; for_each(v.begin(), v.end(), Sum(0)) &lt;&lt; "\n";

}


注意一个拥有应用操作符的函数对象可以被完美地内联化（inline），因为它没有涉及到任何指针，后者可能导致拒绝优化。与之形成对比的是，现有的优化器几乎不能（或者完全不能？）将一个通过函数指针的调用内联化。


在标准库中，函数对象被广泛地使用以获得弹性。


我应该如何对付内存泄漏？


写出那些不会导致任何内存泄漏的代码。很明显，当你的代码中到处充满了new 操作、delete操作和指针运算的话，你将会在某个地方搞晕了头，导致内存泄漏，指针引用错误，以及诸如此类的问题。这和你如何小心地对待内存分配工作其实完全没有关系：代码的复杂性最终总是会超过你能够付出的时间和努力。于是随后产生了一些成功的技巧，它们依赖于将内存分配（allocations）与重新分配（deallocation）工作隐藏在易于管理的类型之后。标准容器（standard containers）是一个优秀的例子。它们不是通过你而是自己为元素管理内存，从而避免了产生糟糕的结果。想象一下，没有string和vector的帮助，写出这个：


#include&lt;vector&gt;

#include&lt;string&gt;

#include&lt;iostream&gt;

#include&lt;algorithm&gt;

using namespace std;


int main() // small program messing around with strings

{

cout &lt;&lt; "enter some whitespace-separated words:\n";

vector&lt;string&gt; v;

string s;

while (cin&gt;&gt;s) v.push_back(s);


sort(v.begin(),v.end());


string cat;

typedef vector&lt;string&gt;::const_iterator Iter;

for (Iter p = v.begin(); p!=v.end(); ++p) cat += *p+"+";

cout &lt;&lt; cat &lt;&lt; '\n';

}


你有多少机会在第一次就得到正确的结果？你又怎么知道你没有导致内存泄漏呢？


注意，没有出现显式的内存管理，宏，造型，溢出检查，显式的长度限制，以及指针。通过使用函数对象和标准算法（standard algorithm），我可以避免使用指针——例如使用迭代子（iterator），不过对于一个这么小的程序来说有点小题大作了。


这些技巧并不完美，要系统化地使用它们也并不总是那么容易。但是，应用它们产生了惊人的差异，而且通过减少显式的内存分配与重新分配的次数，你甚至可以使余下的例子更加容易被跟踪。早在1981年，我就指出，通过将我必须显式地跟踪的对象的数量从几万个减少到几打，为了使程序正确运行而付出的努力从可怕的苦工，变成了应付一些可管理的对象，甚至更加简单了。


如果你的程序还没有包含将显式内存管理减少到最小限度的库，那么要让你程序完成和正确运行的话，最快的途径也许就是先建立一个这样的库。


模板和标准库实现了容器、资源句柄以及诸如此类的东西，更早的使用甚至在多年以前。异常的使用使之更加完善。


如果你实在不能将内存分配/重新分配的操作隐藏到你需要的对象中时，你可以使用资源句柄（resource handle），以将内存泄漏的可能性降至最低。这里有个例子：我需要通过一个函数，在空闲内存中建立一个对象并返回它。这时候可能忘记释放这个对象。毕竟，我们不能说，仅仅关注当这个指针要被释放的时候，谁将负责去做。使用资源句柄，这里用了标准库中的auto_ptr，使需要为之负责的地方变得明确了。


#include&lt;memory&gt;

#include&lt;iostream&gt;

using namespace std;


struct S {

S() { cout &lt;&lt; "make an S\n"; }

~S() { cout &lt;&lt; "destroy an S\n"; }

S(const S&amp;) { cout &lt;&lt; "copy initialize an S\n"; }

S&amp; operator=(const S&amp;) { cout &lt;&lt; "copy assign an S\n"; }

};


S* f()

{

return new S; // 谁该负责释放这个S？

};


auto_ptr&lt;S&gt; g()

{

return auto_ptr&lt;S&gt;(new S); // 显式传递负责释放这个S

}


int main()

{

cout &lt;&lt; "start main\n";

S* p = f();

cout &lt;&lt; "after f() before g()\n";

// S* q = g(); // 将被编译器捕捉

auto_ptr&lt;S&gt; q = g();

cout &lt;&lt; "exit main\n";

// *p产生了内存泄漏

// *q被自动释放

}


在更一般的意义上考虑资源，而不仅仅是内存。


如果在你的环境中不能系统地应用这些技巧（例如，你必须使用别的地方的代码，或者你的程序的另一部分简直是原始人类（译注：原文是Neanderthals，尼安德特人，旧石器时代广泛分布在欧洲的猿人）写的，如此等等），那么注意使用一个内存泄漏检测器作为开发过程的一部分，或者插入一个垃圾收集器（garbage collector）。


我为什么在捕获一个异常之后就不能继续？


换句话说，C++为什么不提供一种简单的方式，让程序能够回到异常抛出点之后，并继续执行？


主要的原因是，如果从异常处理之后继续，那么无法预知掷出点之后的代码如何对待异常处理，是否仅仅继续执行，就象什么也没有发生一样。异常处理者无法知道，在继续之前，有关的上下文环境（context）是否是“正确”的。要让这样的代码正确执行，抛出异常的编写者与捕获异常的编写者必须对彼此的代码与上下文环境都非常熟悉才行。这样会产生非常复杂的依赖性，因此无论在什么情况下，都会导致一系列严重的维护问题。


当我设计C++的异常处理机制时，我曾经认真地考虑过允许这种继续的可能性，而且在标准化的过程中，这个问题被非常详细地讨论过。请参见《C++语言的设计和演变》中的异常处理章节。


在一次新闻组的讨论中，我曾经以一种稍微不同的方式回答过这个问题。


为什么C++中没有相当于realloc()的函数？


如果你需要，你当然可以使用realloc()。但是，realloc()仅仅保证能工作于这样的数组之上：它们被malloc()（或者类似的函数）分配，包含一些没有用户定义的复制构造函数（copy constructors）的对象。而且，要记住，与通常的期望相反，realloc()有时也必须复制它的参数数组。


在C++中，处理内存重新分配的更好的方法是，使用标准库中的容器，例如vector，并让它自我增长。


如何使用异常？


参见《C++程序设计语言》第4章，第8.3节，以及附录E。这个附录针对的是如何在要求苛刻的程序中写出异常安全的代码的技巧，而不是针对初学者的。一个关键的技术是“资源获得即初始化”（resource acquisiton is initialization），它使用一些有析构函数的类，来实现强制的资源管理。


怎样从输入中读取一个字符串？


你可以用这种方式读取一个单独的以空格结束的词：


#include&lt;iostream&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

cout &lt;&lt; "Please enter a word:\n";


string s;

cin&gt;&gt;s;


cout &lt;&lt; "You entered " &lt;&lt; s &lt;&lt; '\n';

}


注意，这里没有显式的内存管理，也没有可能导致溢出的固定大小的缓冲区。


如果你确实想得到一行而不是一个单独的词，可以这样做：



#include&lt;iostream&gt;

#include&lt;string&gt;

using namespace std;


int main()

{

cout &lt;&lt; "Please enter a line:\n";


string s;

getline(cin,s);


cout &lt;&lt; "You entered " &lt;&lt; s &lt;&lt; '\n';

}


在《C++程序设计语言》（可在线获得）的第3章，可以找到一个对诸如字符串与流这样的标准库工具的简介。对于使用C与C++进行简单输入输出的详细比较，参见我的文章《将标准C++作为一种新的语言来学习》(Learning Standard C++ as a New Language)，你可以在本人著作列表(my publications list)中下载到它。


为什么C++不提供“finally”的构造？


因为C++提供了另外一种方法，它几乎总是更好的：“资源获得即初始化”（resource acquisiton is initialization）技术。基本的思路是，通过一个局部对象来表现资源，于是局部对象的析构函数将会释放资源。这样，程序员就不会忘记释放资源了。举例来说：


class File_handle {

FILE* p;

public:

File_handle(const char* n, const char* a)

{ p = fopen(n,a); if (p==0) throw Open_error(errno); }

File_handle(FILE* pp)

{ p = pp; if (p==0) throw Open_error(errno); }


~File_handle() { fclose(p); }


operator FILE*() { return p; }


// ...

};


void f(const char* fn)

{

File_handle f(fn,"rw"); //打开fn进行读写

// 通过f使用文件

}


在一个系统中，需要为每一个资源都使用一个“资源句柄”类。无论如何，我们不需要为每一个资源获得都写出“finally”语句。在实时系统中，资源获得要远远多于资源的种类，因此和使用“finally”构造相比，“资源获得即初始化”技术会产生少得多的代码。


什么是自动指针（auto_ptr），为什么没有自动数组（auto_array）？


auto_ptr是一个非常简单的句柄类的例子，在&lt;memory&gt;中定义，通过“资源获得即初始化”技术支持异常安全。auto_ptr保存着一个指针，能够象指针一样被使用，并在生存期结束时释放指向的对象。举例：


#include&lt;memory&gt;

using namespace std;


struct X {

int m;

// ..

};


void f()

{

auto_ptr&lt;X&gt; p(new X);

X* q = new X;


p-&gt;m++; // 象一个指针一样使用p

q-&gt;m++;

// ...


delete q;

}


如果在...部分抛出了一个异常，p持有的对象将被auto_ptr的析构函数正确地释放，而q指向的X对象则产生了内存泄漏。更多的细节，参见《C++程序设计语言》14.4.2节。


auto_ptr是一个非常简单的类。特别地，它不是一个引用计数（reference counted）的指针。如果你将一个auto_ptr赋值给另一个，那么被赋值的auto_ptr将持有指针，而原来的auto_ptr将持有0。举例：


#include&lt;memory&gt;

#include&lt;iostream&gt;

using namespace std;


struct X {

int m;

// ..

};


int main()

{

auto_ptr&lt;X&gt; p(new X);

auto_ptr&lt;X&gt; q(p);

cout &lt;&lt; "p " &lt;&lt; p.get() &lt;&lt; " q " &lt;&lt; q.get() &lt;&lt; "\n";

}


将会打印出一个指向0的指针和一个指向非0的指针。例如：


p 0x0 q 0x378d0


auto_ptr::get()返回那个辅助的指针。


这种“转移”语义不同于通常的“复制”语义，这是令人惊讶的。特别地，永远不要使用auto_ptr作为一个标准容器的成员。标准容器需要通常的“复制”语义。例如：


std::vector&lt;auto_ptr&lt;X&gt; &gt;v; // 错误


auto_ptr只持有指向一个单独元素的指针，而不是指向一个数组的指针：


void f(int n)

{

auto_ptr&lt;X&gt; p(new X[n]); //错误

// ...

}


这是错误的，因为析构函数会调用delete而不是delete[]来释放指针，这样就不会调用余下的n-1个X的析构函数。


那么我们需要一个auto_array来持有数组吗？不。没有auto_array。原因是根本没有这种需要。更好的解决方案是使用vector：


void f(int n)

{

vector&lt;X&gt; v(n);

// ...

}


当...部分发生异常时，v的析构函数会被正确地调用。


可以混合使用C风格与C++风格的内存分派与重新分配吗？


在这种意义上是可以的：你可以在同一个程序中使用malloc()和new。


在这种意义上是不行的：你不能使用malloc()来建立一个对象，又通过delete来释放它。你也不能用new建立一个新的对象，然后通过free()来释放它，或者通过realloc()在数组中再建立一个新的。


C++中的new和delete操作可以保证正确的构造和析构：构造函数和析构函数在需要它们的时候被调用。C风格的函数alloc(), calloc(), free(), 和realloc()却不能保证这一点。此外，用new和delete来获得和释放的原始内存，并不一定能保证与malloc()和free()兼容。如果这种混合的风格在你的系统中能够运用，只能说是你走运——暂时的。


如果你觉得需要使用realloc()——或者要做更多——考虑使用标准库中的vector。例如：


// 从输入中将词读取到一个字符串vector中


vector&lt;string&gt; words;

string s;

while (cin&gt;&gt;s &amp;&amp; s!=".") words.push_back(s);


vector会视需要自动增长。


更多的例子与讨论，参见我的文章《将标准C++作为一种新的语言来学习》(Learning Standard C++ as a New Language)，你可以在本人著作列表(my publications list)中下载到它。


我为什么必须使用一个造型来转换*void？


在C语言中，你可以隐式地将*void转换为*T。这是不安全的。考虑一下：


#include&lt;stdio.h&gt;


int main()

{

char i = 0;

char j = 0;

char* p = &amp;i;

void* q = p;

int* pp = q; /* 不安全的，在C中可以，C++不行 */


printf("%d %d\n",i,j);

*pp = -1; /* 覆盖了从i开始的内存 */

printf("%d %d\n",i,j);

}


使用一个并不指向T类型的T*将是一场灾难。因此，在C++中，如果从一个void*得到一个T*，你必须进行显式转换。举例来说，要得到上列程序的这个令人别扭的效果，你可以这样写：


int* pp = (int*)q;


或者使用一个新的类型造型，以使这种没有检查的类型转换操作变得更加清晰：


int* pp = static_cast&lt;int*&gt;(q);


造型被最好地避免了。


在C语言中，这种不安全的转换最常见的应用之一，是将malloc()的结果赋予一个合适的指针。例如：


int* p = malloc(sizeof(int));


在C++中，使用类型安全的new操作符：


int* p = new int;


附带地，new操作符还提供了胜过malloc()的新特性：


new不会偶然分配错误的内存数量；

new会隐式地检查内存耗尽情况，而且

new提供了初始化。


举例：


typedef std::complex&lt;double&gt; cmplx;


/* C风格: */

cmplx* p = (cmplx*)malloc(sizeof(int)); /* 错误：类型不正确 */

/* 忘记测试p==0 */

if (*p == 7) { /* ... */ } /* 糟糕，忘记了初始化*p */


// C++风格:

cmplx* q = new cmplx(1,2); // 如果内存耗尽，将抛出一个bad_alloc异常

if (*q == 7) { /* ... */ }


我如何定义一个类内部（in-class）的常量？


如果你需要一个通过常量表达式来定义的常量，例如数组的范围，你有两种选择：


class X {

static const int c1 = 7;

enum { c2 = 19 };


char v1[c1];

char v2[c2];


// ...

};


乍看起来，c1的声明要更加清晰，但是要注意的是，使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式初始化的整型或枚举类型，而且必须是static和const形式。这是很严重的限制：


class Y {

const int c3 = 7; // 错误：不是static

static int c4 = 7; // 错误：不是const

static const float c5 = 7; // 错误：不是整型

};


我倾向使用枚举的方式，因为它更加方便，而且不会诱使我去使用不规范的类内初始化语法。


那么，为什么会存在这种不方便的限制呢？一般来说，类在一个头文件中被声明，而头文件被包含到许多互相调用的单元去。但是，为了避免复杂的编译器规则，C++要求每一个对象只有一个单独的定义。如果C++允许在类内部定义一个和对象一样占据内存的实体的话，这种规则就被破坏了。对于C++在这个设计上的权衡，请参见《C++语言的设计和演变》。


如果你不需要用常量表达式来初始化它，那么可以获得更大的弹性：


class Z {

static char* p; // 在定义中初始化

const int i; // 在构造函数中初始化

public:

Z(int ii) :i(ii) { }

};


char* Z::p = "hello, there";


你可以获取一个static成员的地址，当且仅当它有一个类外部的定义的时候：


class AE {

// ...

public:

static const int c6 = 7;

static const int c7 = 31;

};


const int AE::c7; // 定义


int f()

{

const int* p1 = &amp;AE::c6; // 错误：c6没有左值

const int* p2 = &amp;AE::c7; // ok

// ...

}


为什么delete不会将操作数置0？


考虑一下：


delete p;

// ...

delete p;


如果在...部分没有涉及到p的话，那么第二个“delete p;”将是一个严重的错误，因为C++的实现（译注：原文为a C++ implementation，当指VC++这样的实现了C++标准的具体工具）不能有效地防止这一点（除非通过非正式的预防手段）。既然delete 0从定义上来说是无害的，那么一个简单的解决方案就是，不管在什么地方执行了“delete p;”，随后都执行“p=0;”。但是，C++并不能保证这一点。


一个原因是，delete的操作数并不需要一个左值（lvalue）。考虑一下：


delete p+1;

delete f(x);


在这里，被执行的delete并没有拥有一个可以被赋予0的指针。这些例子可能很少见，但它们的确指出了，为什么保证“任何指向被删除对象的指针都为0”是不可能的。绕过这条“规则”的一个简单的方法是，有两个指针指向同一个对象：


T* p = new T;

T* q = p;

delete p;

delete q; // 糟糕！


C++显式地允许delete操作将操作数左值置0，而且我曾经希望C++的实现能够做到这一点，但这种思想看来并没有在C++的实现中变得流行。


如果你认为指针置0很重要，考虑使用一个销毁的函数：


template&lt;class T&gt; inline void destroy(T*&amp; p) { delete p; p = 0; }


考虑一下，这也是为什么需要依靠标准库的容器、句柄等等，来将对new和delete的显式调用降到最低限度的另一个原因。


注意，通过引用来传递指针（以允许指针被置0）有一个额外的好处，能防止destroy()在右值上（rvalue）被调用：


int* f();

int* p;

// ...

destroy(f()); // 错误：应该使用一个非常量（non-const）的引用传递右值

destroy(p+1); // 错误：应该使用一个非常量（non-const）的引用传递右值


我能够写“void main()”吗？


这种定义：


void main() { /* ... */ }


在C++中从未被允许，在C语言中也是一样。参见ISO C++标准3.6.1[2]或者ISO C标准5.1.2.2.1。规范的实现接受这种方式：


int main() { /* ... */ }


和


int main(int argc, char* argv[]) { /* ... */ }


一个规范的实现可能提供许多版本的main()，但它们都必须返回int类型。main()返回的int值，是程序返回一个值给调用它的系统的方式。在那些不具备这种方式的系统中，返回值被忽略了，但这并不使“void main()”在C++或C中成为合法的。即使你的编译器接受了“void main()”，也要避免使用它，否则你将冒着被C和C++程序员视为无知的风险。


在C++中，main()并不需要包含显式的return语句。在这种情况下，返回值是0，表示执行成功。例如：


#include&lt;iostream&gt;


int main()

{

std::cout &lt;&lt; "This program returns the integer value 0\n";

}


注意，无论是ISO C++还是C99，都不允许在声明中漏掉类型。那就是说，与C89和ARM C++形成对照，当声明中缺少类型时，并不会保证是“int”。于是：


#include&lt;iostream&gt;


main() { /* ... */ }


是错误的，因为缺少main()的返回类型。


为什么我不能重载点符号，::，sizeof，等等？


大多数的运算符能够被程序员重载。例外的是：


. (点符号) :: ?: sizeof


并没有什么根本的原因要禁止重载?:。仅仅是因为，我没有发现有哪种特殊的情况需要重载一个三元运算符。注意一个重载了 表达式1？表达式2：表达式3 的函数，不能够保证表达式2：表达式3中只有一个会被执行。


Sizeof不能够被重载是因为内建的操作（built-in operations），诸如对一个指向数组的指针进行增量操作，必须依靠它。考虑一下：


X a[10];

X* p = &amp;a[3];

X* q = &amp;a[3];

p++; // p指向a[4]

// 那么p的整型值必须比q的整型值大出一个sizeof(X)


所以，sizeof(X)不能由程序员来赋予一个不同的新意义，以免违反基本的语法。


在N::m中，无论N还是m都不是值的表达式；N和m是编译器知道的名字，::执行一个（编译期的）范围解析，而不是表达式求值。你可以想象一下，允许重载x::y的话，x可能是一个对象而不是一个名字空间（namespace）或者一个类，这样就会导致——与原来的表现相反——产生新的语法（允许 表达式1::表达式2）。很明显，这种复杂性不会带来任何好处。


理论上来说，.（点运算符）可以通过使用和-&gt;一样的技术来进行重载。但是，这样做会导致一个问题，那就是无法确定操作的是重载了.的对象呢，还是通过.引用的一个对象。例如：



class Y {

public:

void f();

// ...

};


class X { // 假设你能重载.

Y* p;

Y&amp; operator.() { return *p; }

void f();

// ...

};


void g(X&amp; x)

{

x.f(); // X::f还是Y::f还是错误？

}


这个问题能够用几种不同的方法解决。在标准化的时候，哪种方法最好还没有定论。更多的细节，请参见《C++语言的设计和演变》。


怎样将一个整型值转换为一个字符串？


最简单的方法是使用一个字符串流（stringstream）：


#include&lt;iostream&gt;

#include&lt;string&gt;

#include&lt;sstream&gt;

using namespace std;


string itos(int i) // 将int转换成string

{

stringstream s;

s &lt;&lt; i;

return s.str();

}


int main()

{

int i = 127;

string ss = itos(i);

const char* p = ss.c_str();


cout &lt;&lt; ss &lt;&lt; " " &lt;&lt; p &lt;&lt; "\n";

}


自然地，这种技术能够将任何使用&lt;&lt;输出的类型转换为字符串。对于字符串流的更多说明，参见《C++程序设计语言》21.5.3节。


“int* p”正确还是“int *p”正确？


二者都是正确的，因为二者在C和C++中都是有效的，而且意义完全一样。就语言的定义与相关的编译器来说，我们还可以说“int*p”或者“int * p”。


在“int* p”和“int *p”之间的选择与正确或错误无关，而只关乎风格与侧重点。C侧重表达式；对声明往往比可能带来的问题考虑得更多。另一方面，C++则非常重视类型。


一个“典型的C程序员”写成“int *p”，并且解释说“*p表示一个什么样的int”以强调语法，而且可能指出C（与C++）的语法来证明这种风格的正确性。是的，在语法上*被绑定到名字p上。


一个“典型的C++程序员”写成“int* p”，并且解释说“p是一个指向int的指针类型”以强调类型。是的，p是一个指向int的指针类型。我明确地倾向于这种侧重方向，而且认为对于学好更多的高级C++这是很重要的。


严重的混乱（仅仅）发生在当人们试图在一条声明中声明几个指针的时候：


int* p, p1; // 也许是错的：p1不是一个int*


把*放到名字这一边，看来也不能有效地减少这种错误：


int *p, p1; // 也许是错的？


为每一个名字写一条声明最大程度地解决了问题——特别是当我们初始化变量的时候。人们几乎不会这样写：


int* p = &amp;i;

int p1 = p; // 错误：int用一个int*初始化了


如果他们真的这么干了，编译器也会指出。


每当事情可以有两种方法完成，有人就会迷惑。每当事情仅仅是一个风格的问题，争论就会没完没了。为每一个指针写一条声明，而且永远都要初始化变量，这样，混乱之源就消失了。更多的关于C的声明语法的讨论，参见《C++语言的设计和演变》。


对于我的代码，哪一种布局风格（layout style）是最好的？


这种风格问题属于个人的爱好。人们往往对布局风格的问题持有强烈的意见，不过，也许一贯性比某种特定的风格更加重要。象大多数人一样，我花了很长的时间，来为我的偏好作出一个固定的结论。


我个人使用通常称为“K&amp;R”的风格。当使用C语言没有的构造函数时，需要增加新的习惯，这样就变成了一种有时被称为“Stroustrup”的风格。例如：


class C : public B {

public:

// ...

};


void f(int* p, int max)

{

if (p) {

// ...

}


for (int i = 0; i&lt;max; ++i) {

// ...

}

}


比大多数布局风格更好，这种风格保留了垂直的空格，我喜欢尽可能地在合理的情况下对齐屏幕。对函数开头的大括弧的放置，有助于我第一眼就分别出类的定义和函数的定义。


缩进是非常重要的。


设计问题，诸如作为主要接口的抽象基类的使用，使用模板以表现有弹性的类型安全的抽象，以及正确地使用异常以表现错误，比布局风格的选择要重要得多。


我应该将“const”放在类型之前还是之后？


我把它放在前面，但那仅仅是个人爱好问题。“const T”和“T const”总是都被允许的，而且是等效的。例如：


const int a = 1; // ok

int const b = 2; // also ok


我猜想第一种版本可能会让少数（更加固守语法规范）的程序员感到迷惑。


为什么？当我发明“const”（最初的名称叫做“readonly”，并且有一个对应的“writeonly”）的时候，我就允许它出现在类型之前或之后，因为这样做不会带来任何不明确。标准之前的C和C++规定了很少的（如果有的话）特定的顺序规范。


我不记得当时有过任何有关顺序问题的深入思考或讨论。那时，早期的一些使用者——特别是我——仅仅喜欢这种样子：


const int c = 10;


看起来比这种更好：


int const c = 10;


也许我也受了这种影响：在我最早的一些使用“readonly”的例子中


readonly int c = 10;


比这个更具有可读性：


int readonly c = 10;


我创造的那些最早的使用“const”的（C或C++）代码，看来已经在全球范围内取代了“readonly”。


我记得这个语法的选择在几个人——例如Dennis Ritchie——当中讨论过，但我不记得当时我倾向于哪种语言了。


注意在固定指针（const pointer）中，“const”永远出现在“*”之后。例如：


int *const p1 = q; // 指向int变量的固定指针

int const* p2 = q; //指向int常量的指针

const int* p3 = q; //指向int常量的指针


使用宏有什么问题？


宏不遵循C++中关于范围和类型的规则。这经常导致一些微妙的或不那么微妙的问题。因此，C++提供更适合其他的C++（译注：原文为the rest of C++，当指C++除了兼容C以外的部分）的替代品，例如内联函数、模板与名字空间。


考虑一下：


#include "someheader.h"


struct S {

int alpha;

int beta;

};


如果某人（不明智地）地写了一个叫“alpha”或“beta”的宏，那么它将不会被编译，或者被错误地编译，产生不可预知的结果。例如，“someheader.h”可能包含：


#define alpha 'a'

#define beta b[2]


将宏（而且仅仅是宏）全部大写的习惯，会有所帮助，但是对于宏并没有语言层次上的保护机制。例如，虽然成员的名字包含在结构体的内部，但这无济于事：在编译器能够正确地辨别这一点之前，宏已经将程序作为一个字符流进行了处理。顺便说一句，这是C和C++程序开发环境和工具能够被简化的一个主要原因：人与编译器看到的是不同的东西。


不幸的是，你不能假设别的程序员总是能够避免这种你认为“相当白痴”的事情。例如，最近有人报告我，他们遇到了一个包含goto的宏。我也见过这种情况，而且听到过一些——在很脆弱的时候——看起来确实有理的意见。例如：


#define prefix get_ready(); int ret__

#define Return(i) ret__=i; do_something(); goto exit

#define suffix exit: cleanup(); return ret__


void f()

{

prefix;

// ...

Return(10);

// ...

Return(x++);

//...

suffix;

}


作为一个维护的程序员，就会产生这种印象；将宏“隐藏”到一个头文件中——这并不罕见——使得这种“魔法”更难以被辨别。


一个常见的微妙问题是，一个函数风格的宏并不遵守函数参数传递的规则。例如：


#define square(x) (x*x)


void f(double d, int i)

{

square(d); // 好

square(i++); // 糟糕：这表示 (i++*i++)

square(d+1); //糟糕：这表示(d+1*d+1); 也就是 (d+d+1)

// ...

}


“d+1”的问题，可以通过在“调用”时或宏定义时添加一对圆括号来解决：


#define square(x) ((x)*(x)) /*这样更好 */


但是， i++被执行了两次（可能并不是有意要这么做）的问题仍然存在。


是的，我确实知道有些特殊的宏并不会导致C/C++预处理宏这样的问题。但是，我无心去发展C++中的宏。作为替代，我推荐使用C++语言中合适的工具，例如内联函数，模板，构造函数（用来初始化），析构函数（用来清除），异常（用来退出上下文环境），等等。

--
装B者死于自然灾害！

帖子发的快删的也快,只有灌水是永恒的


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 219.142.139.*]
 
【文章标题】：socket 发送广播包 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30423 【创建时间】：2008-10-10 【作者】：zxqw 【评论】：5 【内容】：发信人: zxqw (Jessica), 信区: SoftDesign
标  题: socket 发送广播包
发信站: 北邮人论坛 (Fri Oct 10 14:40:50 2008), 站内

创建一个socket,bind到本机地址＋某端口，这样是不是只能接收单播包，不能接收广播包了？
为什么我设置static int so_broadcast = 1;
setsockopt(sockfd1, SOL_SOCKET, SO_BROADCAST,&amp;so_broadcast, sizeof(so_broadcast));
之后只能接收单播包不能接收广播包？是不是不bind本地地址和端口就可以？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 193.49.124.*]
 
【文章标题】：[重要]【软件开发版规】 【文章地址】：https://bbs.byr.cn/article/SoftDesign/1 【创建时间】：2004-11-19 【作者】：Orpine 【评论】：0 【内容】：发信人: Orpine (北邮人), 信区: SoftDesign
标  题: [重要]【软件开发版规】
发信站: BBS 北邮人论坛站 (Fri Nov 19 09:57:20 2004), 站内

软件开发版规

1、开版目的：为了增强我国新一代的软件人才的水平，为了促进同学们软件技术的交流，特在北邮人论坛上开辟了一块空间，供大家交流学习。

2、本版发帖要求：

（1）遵守北邮人论坛的一切守则；

（2）任何网友可以参与讨论，发表自己的见解，但是讨论内容必须和软件学习有关；

（3）任何网友可以转发新闻、论文等媒体消息，但是必须和软件（行业）有关，而且需要注明为转贴（论文最好注明出处）；

（3）不得灌水（删），尤其是恶意灌水（封）；

（4）任何网友在提出问题时，请在题目注明所发帖子是属于哪一类别的，本版类别有DELPHI，C/C++/VC++，JAVA，VB等编程语言和开发工具，如不注明，版主有权删除此帖。

（5）任何网友在发表自己作品时请注明原创，请真实的发布软件，如经查出是其他人的作品，版主有权封。

（6）任何网友在发表需要测试的作品时请注明[测试]。

（7）任何网友在发表源代码时请注明[共享]。


（8）本版拒绝发布求枪手程序，作业程序。
3、本版删封条例

（1）严禁发布与软件（行业）以及软件学习无关的帖子（删，封3天）；

（2）严禁灌水（删），严禁恶意灌水（封3天）；

（3）严禁发帖主题不明确（有权删），严禁发布重复主题（警告以后置之不理者封3天）；

（4）严禁原创帖盗用别人作品（封14天）；

（5）严禁发布求软件的信息（删）；

（6）严禁发布求枪手程序作业程序（封10天）；

4、置顶要求
（1）版主发布重要信息；

（2）论坛所发布的合作开发项目置顶，项目组织者拥有解释权，并负保证参与者权益的责任，接受相关部门监督；

5、加精要求

（1）所发主题得到大家好评，对大家有帮助。

（2）内容充实，理论性强，是一篇专业性文章。

（3）提供有价值的源代码。
※ 修改:·Neverwinter 于 Dec 12 16:05:27 修改本文·[FROM: 219.142.136.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 222.28.212.*]
 
【文章标题】：MFC完全结构图 【文章地址】：https://bbs.byr.cn/article/SoftDesign/42 【创建时间】：2005-02-26 【作者】：Toney 【评论】：0 【内容】：发信人: Toney (七月的使者), 信区: SoftDesign
标  题: MFC完全结构图
发信站: BBS 北邮人论坛站 (Sat Feb 26 11:16:58 2005), 站内

送给有需要的同学们

<a target="_blank" href="/att/SoftDesign/0/42/287"><img border="0" title="MFChc.jpg" src="/att/SoftDesign/0/42/287" alt="MFChc.jpg" class="resizeable"></a>
--
缘由天定
          份在人为   


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.196.*]

 
【文章标题】：有人用installshield做过安装程序吗?请教个问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/30416 【创建时间】：2008-10-09 【作者】：vivin 【评论】：6 【内容】：发信人: vivin (阿诺), 信区: SoftDesign
标  题: 有人用installshield做过安装程序吗?请教个问题
发信站: 北邮人论坛 (Thu Oct  9 17:57:48 2008), 站内

任务是为某个应用程序开发的DLL安装到应用程序的家目录，这个DLL是个组件，还需要注册一下，所以就做个安装程序，大概的步骤应该是安装程序搜寻本地机器是否安装了那个应用程序，然后拷贝DLL到程序的家目录，然后执行regsvr32，不知道在installshield下怎么搞啊?那些project的向导应该选哪种?
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 202.108.130.*]
 
【文章标题】：C++高质量编程点滴 【文章地址】：https://bbs.byr.cn/article/SoftDesign/53 【创建时间】：2005-03-17 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: C++高质量编程点滴
发信站: BBS 北邮人论坛站 (Thu Mar 17 18:57:02 2005), 站内

http://blog.csdn.net/i_like_cpp/archive/2005/03/15/320040.aspx

一、你需要一个函数将一个数组赋值为等差数列，并将会在函数的外部使用它。　　

　　不合理：　

　　int *GetArray( int n )
　　{
　　 int *p = new int[n];
　　 for ( int i = 0; i &lt; n; i++ )
　　 {
　 　　p[i] = i;
　　 }
　　 return p;
　　}　 


　　合理：　

　　void GetArray( int *p, int n )
　　{
　　 for ( int i = 0; i &lt; n; i++ )
　　 {
　　 p[i] = i;
　　 }
　　}
　
　　解析：　　

　　检查内存泄露的最好办法，就是检查完全配对的申请和释放，在函数中申请而在外部释放，将导致代码的一致性变差，难以维护。而且，你写的函数不一定是你自己使用的，这样的函数别人会不知道该怎么适当的使用，如果它是一个DLL的导出函数，并且你在不同的平台下使用了，便会导致系统崩溃。最好的解决办法就是在函数调用的外面将内存申请好，函数只对数据进行复制。　　

　　二、你需要写一个类来为你管理一个指针，这个类将封装对指针的申请内存、释放和其它一些基本操作。　

　　不合理：　

　　class A
　　{
　　public:
　　 A( void ) {}
　　 ~A( void ) { delete []m_pPtr; }
　　 void Create( int n ){ m_pPtr = new int[n]; }
　　private:
　　 int *m_pPtr;
　　};　

　　合理：　　

　　class A
　　{
　　public:
　　 A( void ) : m_pPtr(0){}
　　 ~A( void ) { Clear(); }
　　 bool Create( int n ){ if ( m_pPtr ) return false; m_pPtr = new int[n]; return ture; }
　　 void Clear( void ) { delete []m_pPtr; m_pPtr = 0; }
　　private:
　　 int *m_pPtr;
　　}; 

　　解析：　　

　　不合理的代码就在于当你重复调用Create的时候就会造成内存泄露，解决的办法就是在new之前判断一下指针是否为0。要能够有效的执行这个判断，则必须在构造的时候对指针进行初始化，并为这个类添加一个Clear函数来释放内存。　　
　　
　　三、接上题的Create函数，你现在需要根据传入的参数做一些比较复杂的算法操作，并对申请的数组赋值。　　

　　不合理：　

　　bool Create(int *a, int n )
　　{
　　 if ( m_pPtr )
　　 return false;
　　 m_pPtr = new int[n];
　　 for ( int i = 0; i &lt; n; i++ )
　　 {
　　 m_pPtr[i] = 3 / a[i];
　　 }
　　 return true;
　　} 

　　合理：　　

　　template
　　class auto_array　　
　　{
　　public:
　　 explicit auto_array(_Ty *pPtr=0)throw():m_Ptr(pPtr){}
　　 ~auto_array(){delete[]m_Ptr;}
　　 void reset(_Ty *pPtr=0){if(pPtr!=m_Ptr){delete[]m_Ptr;m_Ptr=pPtr;}}
　　 _Ty* release(void){_Ty *pTemp=m_Ptr;m_Ptr=0;return pTemp;}
　　private:
　　 auto_array(const auto_array&amp;other){}
　　 auto_array&amp; operator=(const auto_array&amp; other){}
　　 _Ty *m_Ptr;
　　};
　　bool A::Create(int *a, int n )
　　{
　　 if ( m_pPtr )
　　 return false;
　　 auto_array PtrGuard( new int[n] );
　　 for ( int i = 0; i &lt; n; i++ )
　　 {
　　 if ( 0 == a[i] )
　　 {
　　 return false;
　　 }
　　 PtrGuard .get()[i] = 3 / a[i];
　　 }
　　 m_pPtr = PtrGuard.release();
　　 return true;
　　} 

　　解析：　　

　　在循环中，当参数数组a中的某一个值为0时，将会产生除0异常，那么，这将会导致你在上面为m_pPtr申请的内存不能合理的释放。为了解决这个问题，我们写了一个auto_array作为卫兵来看守企图逃逸的指针。在auto_array对象PtrGuard析构的时候它会同时删除附加在它身上的内存指针。我们首先用PtrGuard来进行所有的指针操作，在确定操作完全结束的最后，把指针再赋给真正的变量，并使PtrGuard放弃对该指针的附加，这样我们就得到了一个最安全的结果。另外需要注意的是，C++的STL库里本来有一个和auto_array功能非常相似的模版类auto_ptr，但是它只支持单个对象的内存，不支持数组，写这样一个auto_array也是不得已而为之。

　　四、你需要开辟一段内存来存放和管理一个4 x 4的矩阵，并单位化之。

　　不合理：

　　int aMatrix[4][4];
　　for ( int i = 0; i &lt; 4; i++ )
　　{
　　 for ( int j = 0; j &lt; 4; j++ )
　　 {
　　 if ( i == j )
　　 {
　　 aMatrix[i][j] = 1;
　　 }
　　 else
　　 {
　　 aMatrix [i][j] = 0;
　　 }
　　 }
　　}　

　　合理：

　　int aMatrix[4 * 4];
　　for ( int i = 0; i &lt; 4; i++ )
　　{
　　 for ( int j = 0; j &lt; 4; j++ )
　　 {
　　 if ( i == j )　
　　 {
　　 aMatrix[ i * 4 + j ] = 1;
　　 }
　　 else
　　 {
　　 aMatrix [ i * 4 + j ] = 0;
　　 }
　　 }
　　}　
　
　　解析：　

　　在任何时候都要避免使用多维数组，数组维数的增加，相应的程序复杂度将会以几何级数的方式增加，也更加的难于理解。　　

　　五、你需要对上面那个矩阵赋值，使它从左上角向右下角按先纵后横的顺序给它赋值

　　不合理：

　　for( int i = 0; i &lt; 4; i++ )
　　{
　　 for ( int j = 0; j &lt; 4; j++ )
　　 {
　　 aMatrix[ j * 4 + i ] = i * 4 + j;
　　 }
　　}　
　
　　合理：

　　for( int i = 0; i &lt; 4; i++ )
　　{
　　 for ( int j = 0; j &lt; 4; j++ )
　　 {
　　 aMatrix[i * 4 + j ] = j * 4 + i;
　　 }
　　} 

　　解析：　　

　　尽量保证顺序的访问数组的每一个元素。由于Windows内存的管理模式，内存是分页管理的。顺序访问数组可以基本保证页面不会来回切换，从而减少了页失效的数量，提高了程序的整体性能。这种性能的提升对于大的数组尤为明显。　　

　　六、你需要用3个float值来表示一个三维的点，并要写一个函数对一个三维点的数组进行计算赋值。　

　　不合理：

　　void foo( float *pPoints[3] )
　　{
　　 float aPoint[3] = { 1.0f, 2.0f, 3.0f };
　　 int nCount = (int)_msize( pPoints );
　　 for ( int i = 0; i &lt; nCount; i++ )
　　 {
　　 pPoints[i][0] = aPoint[0];
　　 pPoints[i][1] = aPoint[1];
　　 pPoints[i][2] = aPoint[2];
　　 }
　　} 

　　合理：

　　struct POINT3
　　{
　　 float x, y, z;
　　};
　　void foo( POINT3 *pPoints, int nCount )
　　{
　　 POINT3 Pt = { 1.0f, 2.0f, 3.0f };
　　 for ( int i = 0; i &lt; nCount; i++ )
　　 {
　　 pPoints[i] = Pt;

　　 }
　　} 

　　解析：　　

　　有两点，一，不要使用_msize对数组的大小进行测定，_msize只能对使用malloc或calloc申请的内存进行大小测定，对于其它的如new或一些API，将会导致程序的崩溃。在设计此类需要传入数组的函数时，别忘了把数组的元素数量也做为参数一并传入，哪怕它是固定的，这将是一个良好的习惯。二，对于float[3]这种类型，尽量避免直接使用它，最好的办法就是用struct对其进行简单的封装，在复制的时候直接使用“=”就可以进行准确的按位赋值了。

　　七、你有一个函数的定义，在这个函数中会new一个比较大的对象Data，并在计算后将它删除。但这个函数将被频繁调用。　　

　　不合理：　　

　　void foo( void )
　　{
　　 Data *p = new Data;
　　 CalcData( p );
　　 delete p;
　　}
　　
　　合理：

　　char Buf[sizeof(DATA)];
　　void foo( void )
　　{
　　 Data *p = new(Buf) Data;
　　 CalcData( p );
　　}
　
　　解析：　　

　　new(buf) type;是定位的new语法，它不会真正的分配内存，而是简单的在指定的已分配的内存起点上划分出一段与类型大小匹配的空间，并直接在这段内存上对该类型进行构造对象，并返回对象的指针。由于它没有真正的分配内存空间，因此它的效率是非常高的，在类似于上述例程中，频繁申请和释放一个大对象的操作，定位的new可以带来很大的效率提升。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.63.*]
 【文章标题】：[转]一篇很不错的Java入门文章--Java学习从入门到精通 【文章地址】：https://bbs.byr.cn/article/SoftDesign/54 【创建时间】：2005-03-17 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: [转]一篇很不错的Java入门文章--Java学习从入门到精通
发信站: BBS 北邮人论坛站 (Thu Mar 17 21:12:39 2005), 站内

作者：robbin
网址：<a target="_blank" href="http://www.fankai.com/">http://www.fankai.com/</a>
转自：<a target="_blank" href="http://blog.csdn.net/dazern/archive/2005/03/17/321882.aspx">http://blog.csdn.net/dazern/archive/2005/03/17/321882.aspx</a>

Java Learning Path （一）、工具篇

一、 JDK (Java Development Kit)

JDK是整个Java的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具和Java基础的类库(rt.jar)。不论什么Java应用服务器实质都是内置了某个版本的JDK。因此掌握JDK是学好Java的第一步。最主流的JDK是Sun公司发布的JDK，除了Sun之外，还有很多公司和组织都开发了自己的JDK，例如IBM公司开发的JDK，BEA公司的Jrocket，还有GNU组织开发的JDK等等。其中IBM的JDK包含的JVM（Java Virtual Machine）运行效率要比Sun JDK包含的JVM高出许多。而专门运行在x86平台的Jrocket在服务端运行效率也要比Sun JDK好很多。但不管怎么说，我们还是需要先把Sun JDK掌握好。

1、 JDK的下载和安装
JDK又叫做J2SE（Java2 SDK Standard Edition），可以从Sun的Java网站上下载到，<a target="_blank" href="http://java.sun.com/j2se/downloads.html">http://java.sun.com/j2se/downloads.html</a> ，JDK当前最新的版本是J2SDK1.4.2，建议下载该版本的JDK，下载页面在这里：<a target="_blank" href="http://java.sun.com/j2se/1.4.2/download.html">http://java.sun.com/j2se/1.4.2/download.html</a>。

下载好的JDK是一个可执行安装程序，默认安装完毕后会在C:\Program Files\Java\目录下安装一套JRE（供浏览器来使用），在C:\j2sdk1.4.2下安装一套JDK（也包括一套JRE）。然后我们需要在环境变量PATH的最前面增加java的路径C:\j2sdk1.4.2\bin。这样JDK就安装好了。

2、 JDK的命令工具
JDK的最重要命令行工具：
java： 启动JVM执行class
javac： Java编译器
jar： Java打包工具
javadoc： Java文档生成器
这些命令行必须要非常非常熟悉，对于每个参数都要很精通才行。对于这些命令的学习，JDK Documentation上有详细的文档。

二、 JDK Documentation

Documentation在JDK的下载页面也有下载连接，建议同时下载Documentation。Documentation是最最重要的编程手册，涵盖了整个Java所有方面的内容的描述。可以这样说，学习Java编程，大部分时间都是花在看这个Documentation上面的。我是随身携带的，写Java代码的时候，随时查看，须臾不离手。

三、 应用服务器(App Server)

App Server是运行Java企业组件的平台，构成了应用软件的主要运行环境。当前主流的App Server是BEA公司的Weblogic Server和IBM公司的Websphere以及免费的Jboss，选择其中一个进行学习就可以了，个人推荐Weblogic，因为它的体系结构更加干净，开发和部署更加方便，是Java企业软件开发人员首选的开发平台。下面简要介绍几种常用的App Server：

1、 Tomcat
Tomcat严格意义上并不是一个真正的App Server，它只是一个可以支持运行Serlvet/JSP的Web容器，不过Tomcat也扩展了一些App Server的功能，如JNDI，数据库连接池，用户事务处理等等。Tomcat被非常广泛的应用在中小规模的Java Web应用中，因此本文做一点下载、安装和配置Tomcat的介绍：

Tomcat是Apache组织下Jakarta项目下的一个子项目，它的主网站是：<a target="_blank" href="http://jakarta.apache.org/tomcat/">http://jakarta.apache.org/tomcat/</a> ，Tomcat最新版本是Tomcat4.1.27，软件下载的连接是：<a target="_blank" href="http://www.apache.org/dist/jakarta/tomcat-4/binaries/">http://www.apache.org/dist/jakarta/tomcat-4/binaries/</a> 。

下载Tomcat既可以直接下载zip包，也可以下载exe安装包（个人建议zip更干净些），不管哪种情况，下载完毕安装好以后（zip直接解压缩就可以了）。需要设置两个环境变量：

JAVA_HOME=C:\j2sdk1.4.2
CATALINA_HOME=D:\tomcat4 (你的Tomcat安装目录Wink

这样就安装好了，启动Tomcat运行CATALINA_HOME\bin\startup.bat，关闭Tomcat运行shutdown.bat脚本。Tomcat启动以后，默认使用8080端口，因此可以用浏览器访问<a target="_blank" href="http://localhost:8080">http://localhost:8080</a>来测试Tomcat是否正常启动。

Tomcat提供了两个Web界面的管理工具，URL分别是：
http://localhost:8080/admin/index.jsp
http://localhost:8080/manager/html
在启用这两个管理工具之前，先需要手工配置一下管理员用户和口令。用一个文本工具打开CATALINA_HOME\conf\tomcat-users.xml这个文件，加入如下几行：

&lt;role rolename="manager"/&gt;
&lt;role rolename="admin"/&gt;
&lt;user username="robbin" password="12345678" roles="admin,manager,tomcat"/&gt;

这样用户“robbin”就具备了超级管理员权限。重新启动Tomcat以后，你就可以使用该用户来登陆如上的两个管理工具，通过Web方式进行Tomcat的配置和管理了。

2、 BEA Weblogic
Weblogic可以到BEA的网站上免费注册之后下载到最新的Weblogic8.1企业版，License可以免费使用1年时间，其实这已经完全足够了。Weblogic的下载连接：<a target="_blank" href="http://commerce.bea.com/index.jsp">http://commerce.bea.com/index.jsp</a>，Weblogic的在线文档：<a target="_blank" href="http://edocs.bea.com/">http://edocs.bea.com/</a> 。

3、 IBM Webshpere
Websphere同样可以下载到免费的试用版本，到IBM的developerWorks网站可以看到Websphere试用产品的下载和相关的Websphere的资料，developerWorks中文网站的连接是：<a target="_blank" href="http://www-900.ibm.com/developerWorks/cn/wsdd/">http://www-900.ibm.com/developerWorks/cn/wsdd/</a> ，Websphere的下载连接：<a target="_blank" href="http://www7b.software.ibm.com/wsdd/downloads/WASsupport.html">http://www7b.software.ibm.com/wsdd/downloads/WASsupport.html</a> 。

4、 Jboss
Jboss是免费开源的App Server，可以免费的从Jboss网站下载：<a target="_blank" href="http://www.jboss.org/index.html">http://www.jboss.org/index.html</a>，然而Jboss的文档是不免费，需要花钱购买，所以为我们学习Jboss设置了一定的障碍。在Jdon上有几篇不错的Jboss配置文档，可以用来参考：<a target="_blank" href="http://www.jdon.com/idea.html">http://www.jdon.com/idea.html</a>

四、 Java应用的运行环境

Java的应用可以简单分为以下几个方面：

1、 Java的桌面应用
桌面应用一般仅仅需要JRE的支持就足够了。

2、 Java Web应用
Java的Web应用至少需要安装JDK和一个web容器（例如Tomcat），以及一个多用户数据库，Web应用至少分为三层：
Browser层：浏览器显示用户页面
Web层：运行Servlet/JSP
DB层：后端数据库，向Java程序提供数据访问服务

3、 Java企业级应用
企业级应用比较复杂，可以扩展到n层，最简单情况会分为4层：
Browser层：浏览器显示用户页面
Client层：Java客户端图形程序（或者嵌入式设备的程序）直接和Web层或者EJB层交互
Web层：运行Servlet/JSP
EJB层：运行EJB，完成业务逻辑运算
DB层：后端数据库，向Java程序提供数据访问服务

4、 Java嵌入式应用
Java嵌入式应用是一个方兴未艾的领域，从事嵌入式开发，需要从Sun下载J2ME开发包，J2ME包含了嵌入式设备专用虚拟机KVM，和普通的JDK中包含的JVM有所不同。另外还需要到特定的嵌入式厂商那里下载模拟器。

Java Learning Path（二）、书籍篇

学习一门新的知识，不可能指望只看一本，或者两本书就能够完全掌握。需要有一个循序渐进的阅读过程。我推荐Oreilly出版的Java系列书籍。

在这里我只想补充一点看法，很多人学习Java是从《Thinking in Java》这本书入手的，但是我认为这本书是不适合初学者的。我认为正确的使用这本书的方法应该是作为辅助的读物。《Thinking in Java》并不是在完整的介绍Java的整个体系，而是一种跳跃式的写作方法，是一种类似tips的方法来对Java很多知识点进行了深入的分析和解释。

对于初学者来说，最好是找一本Java入门的书籍，但是比较完整的循序的介绍Java的语法，面向对象的特性，核心类库等等，在看这本书的同时，可以同步来看《Thinking in Java》，来加深对Java的理解和原理的运用，同时又可以完整的了解Java的整个体系。

对于Java的入门书籍，蔡学镛推荐的是Oreilly的《Exploring Java, 2nd Edition》 或者《Java in a Nutshell,2nd Edition（针对C++背景）》，我并没有看过这两本书。其实我觉得电子工业出版社的《Java 2编程详解》或者《Java 2从入门到精通》就很不错。

在所有的Java书籍当中，其实最最有用的，并不是O'reilly的 Java Serials，真正最最有用处是JDK的Documentation！几乎你想获得的所有的知识在Documentation里面全部都有，其中最主要的部分当然是Java基础类库的API文档，是按照package来组织的，对于每一个class都有详细的解释，它的继承关系，是否实现了某个接口，通常用在哪些场合，还可以查到它所有的public的属性和方法，每个属性的解释，意义，每个方法的用途，调用的参数，参数的意义，返回值的类型，以及方法可能抛出的异常等等。可以这样来说，所有关于Java编程方面的书籍其实都不过是在用比较通俗易懂的语言，和良好的组织方式来介绍Documentation里面的某个package里面包含的一些类的用法而已。所以万变不离其宗，如果你有足够的能力来直接通过Documentation来学习Java的类库，那么基本上就不需要看其他的书籍了。除此之外，Documentation也是编程必备的手册，我的桌面上有三个Documentation的快捷方式，分别是J2SDK1.4.1的Documentation，Servlet2.3的Documentation和J2SDKEE1.3.1的Documentation。有了这个三个Documentation，什么其他的书籍都不需要了。

对于Java Web 编程来说，最核心的是要熟悉和掌握HTTP协议，这个就和Java无关了，在熟悉HTTP协议之后，就需要熟悉Java的实现HTTP协议的类库，也就是Servlet API，所以最重要的东西就是Servlet API。当然对于初学者而言，直接通过Servlet API来学习Web编程有很大的难度，我推荐O'reilly的《Java Server Pages 》这本书来学习Web 编程。

EJB的书籍当中，《Enterprise JavaBeans, 2nd Edition》是一本很不错的书， EJB的学习门槛是比较高，入门很难，但是这本书完全降低了学习的难度，特别重要的一点是，EJB的学习需要结合一种App Server的具体实现，所以在学习EJB的同时，必须同步的学习某种App Server，而这本书相关的出了三本书，分别是Weblogic6.1，Websphere4.0和JBoss3.0上面部署书中例子的实做。真是既有理论，又有实践。在学习EJB的同时，可以边看边做，EJB的学习会变得很轻松。

但是这本书也有一个问题，就是版本比较旧，主要讲EJB1.1规范和部分EJB2.0的规范。而Ed Roman写的《Mastering EJB 2.0》这本书完全是根据EJB2.0规范写的，深入浅出，覆盖了EJB编程的各个方面，并且还有很多编程经验tips，也是学习EJB非常推荐的书籍之一。

如果是结合Weblogic来学习J2EE的话，《J2EE应用与BEA Weblogic Server》绝对是首选读物，虽然是讲述的Weblogic6.0，仍然值得购买，这本书是BEA官方推荐的教材，作者也是BEA公司的工程师。现在中文版已经随处可见了。这本书结合Weblogic介绍了J2EE各个方面的技术在Weblogic平台上的开发和部署，实践指导意义非常强。

在掌握了Java平台基础知识和J2EE方面的知识以后，更进一步的是学习如何运用OO的方法进行软件的设计，那么就一定要学习“设计模式”。Sun公司出版了一本《J2EE核心模式》，是每个开发Java企业平台软件的架构师必备的书籍。这本书全面的介绍了J2EE体系架构的各种设计模式，是设计师的必读书籍。

Java Learning Path（三）过程篇

每个人的学习方法是不同的，一个人的方法不见得适合另一个人，我只能是谈自己的学习方法。因为我学习Java是完全自学的，从来没有问过别人，所以学习的过程基本上完全是自己摸索出来的。我也不知道这种方法是否是比较好的方法，只能给大家提供一点参考了。

学习Java的第一步是安装好JDK，写一个Hello World，? 其实JDK的学习没有那么简单，关于JDK有两个问题是很容易一直困扰Java程序员的地方：一个是CLASSPATH的问题，其实从原理上来说，是要搞清楚JRE的ClassLoader是如何加载Class的；另一个问题是package和import问题，如何来寻找类的路径问题。把这两个问题摸索清楚了，就扫除了学习Java和使用JDK的最大障碍。推荐看一下王森的《Java深度历险》，对这两个问题进行了深入的探讨。

第二步是学习Java的语法。Java的语法是类C++的，基本上主流的编程语言不是类C，就是类C++的，没有什么新东西，所以语法的学习，大概就是半天的时间足够了。唯一需要注意的是有几个不容易搞清楚的关键字的用法，public，protected，private，static，什么时候用，为什么要用，怎么用，这可能需要有人来指点一下，我当初是完全自己琢磨出来的，花了很久的时间。不过后来我看到《Thinking in Java》这本书上面是讲了这些概念的。

第三步是学习Java的面向对象的编程语言的特性的地方。比如继承，构造器，抽象类，接口，方法的多态，重载，覆盖，Java的异常处理机制。对于一个没有面向对象语言背景的人来说，我觉得这个过程需要花很长很长时间，因为学习Java之前没有C++的经验，只有C的经验，我是大概花了一个月左右吧，才彻底把这些概念都搞清楚，把书上面的例子反复的揣摩，修改，尝试，把那几章内容反复的看过来，看过去，看了不下5遍，才彻底领悟了。不过我想如果有C++经验的话，应该一两天时间足够了。那么在这个过程中，可以多看看《Thinking in Java》这本书，对面向对象的讲解非常透彻。可惜的是我学习的时候，并没有看到这本书，所以自己花了大量的时间，通过自己的尝试和揣摩来学会的。

第四步就是开始熟悉Java的类库。Java的基础类库其实就是JDK安装目录下面jre\lib\rt.jar这个包。学习基础类库就是学习rt.jar。基础类库里面的类非常非常多。据说有3000多个，我没有统计过。但是真正对于我们来说最核心的只有4个，分别是
java.lang.*;
java.io.*;
java.util.*;
java.sql.*;

这四个包的学习，每个包的学习都可以写成一本厚厚的教材，而O'reilly也确实是这样做的。我觉得如果时间比较紧，是不可能通过读四本书来学习。我觉得比较好的学习方法是这样的：
首先要通读整个package的框架，了解整个package的class，interface，exception的构成，最好是能够找到介绍整个包框架的文章。这些专门介绍包的书籍的前几章应该就是这些总体的框架内容介绍。

对包整体框架的把握并不是要熟悉每个类的用法，记住它有哪些属性，方法。想记也记不住的。而是要知道包有哪些方面的类构成的，这些类的用途是什么，最核心的几个类分别是完成什么功能的。我在给人培训的时候一般是一次课讲一个包，所以不可能详细的介绍每个类的用法，但是我反复强调，我给你们讲这些包的不是要告诉你们类的方法是怎么调用的，也不要求你们记住类的方法调用，而是要你们了解，Java给我们提供了哪些类，每个类是用在什么场合，当我遇到问题的时候，我知道哪个类，或者哪几个类的组合可以解决我的问题，That'all！，当我们具体写程序的时候，只要你知道该用哪个类来完成你的工作就足够了。编码的时候，具体的方法调用，是边写代码，边查Documentation，所有的东西都在Documentation里面，不要求你一定记住，实际你也记不住3000多个类的总共将近10万个方法调用。所以对每个包的总体框架的把握就变得极为重要。

第五步，通过上面的学习，如果学的比较扎实的话，就打好了Java的基础了，剩下要做的工作是扫清Documentation里面除了上面4个包之外的其他一些比较有用处的类。相信进展到这一步，Java的自学能力已经被培养出来了，可以到了直接学习Documentation的水平了。除了要做GUI编程之外，JDK里面其他会有用处的包是这些：
java.text.*;
java.net.*;
javax.naming.*;
这些包里面真正用的比较多的类其实很少，只有几个，所以不需要花很多时间。

第六步，Java Web 编程，Web编程的核心是HTTP协议，HTTP协议和Java无关，如果不熟悉HTTP协议的话，虽然也可以学好Servlet/JSP编程，但是达不到举一反三，一通百通的境界。所以HTTP协议的学习是必备的。如果熟悉了HTTP协议的话，又有了Java编程的良好的基础，学习Servlet/JSP简直易如反掌，我学习Servlet/JSP就用了不到一周的时间，然后就开始用JSP来做项目了。

在Servlet/JSP的学习中，重头仍然是Servlet Documentation。Servlet API最常用的类很少，花比较少的时间就可以掌握了。把这些类都看一遍，多写几个例子试试。Servlet/JSP编程本质就是在反复调用这些类来通过HTTP协议在Web Server和Brower之间交谈。另外对JSP，还需要熟悉几个常用JSP的标记，具体的写法记不住的话，临时查就是了。

此外Java Web编程学习的重点要放在Web Application的设计模式上，如何进行业务逻辑的分析，并且进行合理的设计，按照MVC设计模式的要求，运用Servlet和JSP分别完成不同的逻辑层，掌握如何在Servlet和JSP之间进行流程的控制和数据的共享，以及Web Application应该如何配置和部署。

第七步，J2EE编程
以上的学习过程如果是比较顺利的话，进行到这一步，难度又陡然提高。因为上面的知识内容都是只涉及一个方面，而像EJB，JMS，JTA等核心的J2EE规范往往是几种Java技术的综合运用的结晶，所以掌握起来难度比较大。

首先一定要学习好JNDI，JNDI是App Server定位服务器资源（EJB组件，Datasouce，JMS）查找方法，如果对JNDI不熟悉的话，EJB，JMS这些东西几乎学不下去。JNDI其实就是javax.naming.*这个包，运用起来很简单。难点在于服务器资源文件的配置。对于服务器资源文件的配置，就需要看看专门的文档规范了，比如web.xml的写法，ejb-jar.xml的写法等等。针对每种不同的App Server，还有自己的服务资源配置文件，也是需要熟悉的。

然后可以学习JTA，主要是要理解JTA对于事务的控制的方法，以及该在什么场合使用JTA。这里可以简单的举个例子，我们知道一般情况可以对于一个数据库连接进行事务控制(conn.setAutoCommit(false),....,conn.commit())，做为一个原子操作，但是假设我的业务需求是要把对两个不同数据库的操作做为一个原子操作，你能做的到吗？这时候只能用JTA了。假设操作过程是先往A数据库插一条记录，然后删除B数据库另一个记录，我们自己写代码是控制不了把整个操作做为一个原子操作的。用JTA的话，由App Server来完成控制。

在学习EJB之前要学习对象序列化和RMI，RMI是EJB的基础。接着学习JMS和EJB，对于EJB来说，最关键是要理解EJB是如何通过RMI来实现对远端对象的调用的，以及在什么情况下要用到EJB。

在学习完EJB，JMS这些东西之后，你可能会意识到要急不可待学习两个领域的知识，一个是UML，另一个是Design Pattern。Java企业软件的设计非常重视框架(Framework)的设计，一个好的软件框架是软件开发成功的必要条件。在这个时候，应该开始把学习的重点放在设计模式和框架的学习上，通过学习和实际的编程经验来掌握EJB的设计模式和J2EE的核心模式。

J2EE规范里面，除了EJB，JMS，JTA，Servlet/JSP，JDBC之外还有很多很多的企业技术，这里不一一进行介绍了。

另外还有一个最新领域Web Services。Web Services也完全没有任何新东西，它像是一种黏合剂，可以把不同的服务统一起来提供一个统一的调用接口，作为使用者来说，我只要获得服务提供者给我的WSDL（对服务的描述），就够了，我完全不知道服务器提供者提供的服务究竟是EJB组件，还是.Net组件，还是什么CORBA组件，还是其他的什么实现，我也不需要知道。Web Services最伟大的地方就在于通过统一的服务提供方式和调用方式，实现了整个Internet服务的共享，是一个非常令人激动的技术领域。Web Services好像目前还没有什么很好的书籍，但是可以通过在网络上面查资料的方式来学习。

Java Learning Path（四） 方法篇

Java作为一门编程语言，最好的学习方法就是写代码。当你学习一个类以后，你就可以自己写个简单的例子程序来运行一下，看看有什么结果，然后再多调用几个类的方法，看看运行结果，这样非常直观的把类给学会了，而且记忆非常深刻。然后不应该满足把代码调通，你应该想想看如果我不这样写，换个方式，再试试行不行。记得哪个高人说过学习编程就是个破坏的过程，把书上的例子，自己学习Documentation编写的例子在运行通过以后，不断的尝试着用不同的方法实现，不断的尝试破坏代码的结构，看看它会有什么结果。通过这样的方式，你会很彻底的很精通的掌握Java。

举个例子，我们都编过Hello World

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello World");
  }
}



很多初学者不是很理解为什么main方法一定要这样来定义public static void main(String[] args)，能不能不这样写？包括我刚学习Java的时候也有这样的疑问。想知道答案吗？很简单，你把main改个名字运行一下，看看报什么错误，然后根据出错信息进行分析；把main的public取掉，在试试看，报什么错误；static去掉还能不能运行；不知道main方法是否一定要传一个String[]数组的，把String[]改掉，改成int[]，或者String试试看；不知道是否必须写args参数名称的，也可以把args改成别的名字，看看运行结果如何。

我当初学习Java的时候就是这样做的，把Hello World程序反复改了七八次，不断运行，分析运行结果，最后就彻底明白为什么了main方法是这样定义的了。

此外，我对于staic，public，private，Exception，try{ }catch {}finally{}等等等等一开始都不是很懂，都是把参考书上面的例子运行成功，然后就开始破坏它，不断的根据自己心里面的疑问来重新改写程序，看看能不能运行，运行出来是个什么样子，是否可以得到预期的结果。这样虽然比较费时间，不过一个例子程序这样反复破坏几次之后。我就对这个相关的知识彻底学通了。有时候甚至故意写一些错误的代码来运行，看看能否得到预期的运行错误。这样对于编程的掌握是及其深刻的。

其中特别值得一提的是JDK有一个非常棒的调试功能，-verbose
java –verbose
javac –verbose 以及其它很多JDK工具都有这个选项
-verbose 可以显示在命令执行的过程中，JVM都依次加载哪里Class，通过这些宝贵的调试信息，可以帮助我们分析出JVM在执行的过程中都干了些什么。

另外，自己在学习过程中，写的很多的这种破坏例程，应该有意识的分门别类的保存下来，在工作中积累的典型例程也应该定期整理，日积月累，自己就有了一个代码库了。遇到类似的问题，到代码库里面 Copy &amp; Paste ，Search &amp; Replace，就好了，极大提高了开发速度。最理想的情况是把一些通用的例程自己再抽象一层，形成一个通用的类库，封装好。那么可复用性就更强了。

所以我觉得其实不是特别需要例程的，自己写的破坏例程就是最好的例子，如果你实在对自己写的代码不放心的话，我强烈推荐你看看JDK基础类库的Java源代码。在JDK安装目录下面会有一个src.zip，解开来就可以完整的看到整个JDK基础类库，也就是rt.jar的Java源代码，你可以参考一下Sun是怎么写Java程序的，规范是什么样子的。我自己在学习Java的类库的时候，当有些地方理解的不是很清楚的时候，或者想更加清晰的理解运作的细节的时候，往往会打开相应的类的源代码，通过看源代码，所有的问题都会一扫而空。

Java Learning Path（五）资源篇

1、 <a target="_blank" href="http://java.sun.com/">http://java.sun.com/</a> (英文)
Sun的Java网站，是一个应该经常去看的地方。不用多说。

2、<a target="_blank" href="http://www-900.ibm.com/developerWorks/cn/">http://www-900.ibm.com/developerWorks/cn/</a>
IBM的developerWorks网站，英语好的直接去英文主站点看。这里不但是一个极好的面向对象的分析设计网站，也是Web Services，Java，Linux极好的网站。强烈推荐！！！

3、<a target="_blank" href="http://www.javaworld.com/">http://www.javaworld.com/</a> (英文)
关于Java很多新技术的讨论和新闻。想多了解Java的方方面面的应用，这里比较好。

4、<a target="_blank" href="http://dev2dev.bea.com.cn/index.jsp">http://dev2dev.bea.com.cn/index.jsp</a>
BEA的开发者园地，BEA作为最重要的App Server厂商，有很多独到的技术，在Weblogic上做开发的朋友不容错过。

5、<a target="_blank" href="http://www.huihoo.com/">http://www.huihoo.com/</a>
灰狐动力网站，一个专业的中间件网站，虽然不是专业的Java网站，但是在J2EE企业应用技术方面有深厚的造诣。

6、<a target="_blank" href="http://www.theserverside.com/">http://www.theserverside.com/</a> (英文)
TheServerSide是一个著名的专门面向Java Server端应用的网站。

7、<a target="_blank" href="http://www.javaresearch.org/">http://www.javaresearch.org/</a>
Java研究组织，有很多优秀的Java方面的文章和教程，特别是在JDO方面的文章比较丰富。

8、<a target="_blank" href="http://www.cnjsp.org/">http://www.cnjsp.org/</a>
JSP技术网站，有相当多的Java方面的文章和资源。

9、<a target="_blank" href="http://www.jdon.com/">http://www.jdon.com/</a>
Jdon论坛，是一个个人性质的中文J2EE专业技术论坛，在众多的Java的中文论坛中，Jdon一个是技术含量非常高，帖子质量非常好的论坛。

10、<a target="_blank" href="http://sourceforge.net/">http://sourceforge.net/</a>
SourgeForge是一个开放源代码软件的大本营，其中也有非常非常丰富的Java的开放源代码的著名的软件
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.63.*]
 【文章标题】：[分享]论如何才能提高软件的开发效率及写代码效率 【文章地址】：https://bbs.byr.cn/article/SoftDesign/55 【创建时间】：2005-03-20 【作者】：chaobill 【评论】：0 【内容】：发信人: chaobill (阿超), 信区: SoftDesign
标  题: [分享]论如何才能提高软件的开发效率及写代码效率
发信站: BBS 北邮人论坛站 (Sun Mar 20 13:36:35 2005), 站内

From www.51js.com
论如何才能提高软件的开发效率及写代码效率

────给初学者的一些感想

 

作者：林宣武       著作权所有，转载请带上作者名字

 

  本文的适应读者：刚毕业的学生,并刚入软件公司同时又打算在软件业有所发展的人

 

 首先让我们看一看刚入软件公司会出现的情况：

1．    你可能会常常发现，写了一段代码后，编译程序时是一大堆的出错 （原因：语法不熟）

──别担心，这是每个程序员必须经历的事，这时候你就需要更大的耐心及细心，

对每一行代码进行仔细人阅读并改正，这个很重要，这可以培养你的理解代码能力，所以要常读程序，不要等到程序运行以后才知道你的程序的结果。

──如何避免：在写代码以前，要认真的学习计算机语言的语法，如关键点，易错点，易忘点。同时要自已动手写自已的测试代码，而尽量不要抄别人的代码示例。即使抄，在学习阶段也尽量不要每一行一模一样的对着抄。而应对着代码示例写有所不同的例子。

比如：在学java 知识点时，你最好建一个工程把所有的代码都写到这个工程中，以便对照分析学习.

 

2.        你可能会常常发现，写完一段码后，编译通过，可是运行起来却出来很多逻辑上的错误。（原因：理解错误或逻辑上想错了）

    ──

──提高逻辑思维和理解能力

3．  拿到一个需求却不知从那里开始(对系统不太了解)

4．  常常为了一个小小的错误用了很长的时间，不知从那里查，也查不出结果

5．  常常做出来的东西是有了东却少了西（考虑不全）

6．  有时为了一个特殊功能模块的实现查了很工时间却没有查出结果来(备查的资料不全)

7．  有时是否要项目经理叫你做东,你做了完全没有必要的西？（沟通不及时）

8．  有时为了能提前完成某一个任务，加班到深夜，可是到了明天却效率低下，还不如不加班（要注意休息）

9．  有时自已认为已测好了好多次，可以保证不会出错，可是经测试人员一测试却很多错误（不够细心或测试方法有问题）

10．              有时为了避免出错，常常全比写代码的时间超出两倍用于测试（方法有误）     

11. 有时写好了一段代码给质量管理人员时却因为代码不够规范而导致重写？（代码不够规范）

 

为了写好代码（包括，代码没有问题，需求符合，健壮性好，总用时小），那我们应该怎么做呢，有没有什么方法没有.

 回答是肯定的！！

可以总结为两大关键点：一是养成好的编程习惯，二是针对自已的工作提高自已的知识含量.

一．    好的编程习惯

1.       写程序前打个草稿可以在心里，最好在纸上：目的要从整体上考虑程序的实现。

如果公司采用建模的方式，有建模工具（rose ，visio ）那是最好不过的了。

 

2．    注意休息，不要浪费自已的休息时间，用去了自已的时间不但会写出的代码因为注意力不集中而会常常出现代码的质量有问题，逻辑常出错

3．    要善于收集相关的专业开发上的资料，以便以后能更快更好的解决问题目。提倡公司能提供内部知识勾通的工具（如知识论坛，内部即时聊天器）；提倡公司内部有技术资料的共享库，提高解决问题的能力.

4．    提高对所写的模块的相关全局把握能力，在写程序中要最好先详细设计后再发布.

5．    要学会与他人沟通如非工程师，学会沟通的不同方式，提高沟通的效率。

 

 

二．    不同的目标不同的知识重点

(一）        目标：程序员

职责：根据详细设计文档，或根据高级程序员的设计进行相关的开发。

1．    要学会看相关的需求文档及详细设计文档。

注意：你必须要通过阅读这些文档把握住其中的重点，关键点，相关易漏点

2．    如果公司里会用UML来相互的沟通，这时你必须要深刻理解UML 的相关知识，一定要注意千万不要对UML图一知半解的情况下，就着写代码，那样会错的很惨。

3．    学好对应的计算机语言的基础知识，如：程序的语法，关键点，易错点，对应的出错如何出理，如何才能把对就的程序写的键壮一些

4．    如果用到数据库的内容，在学会sql的前提下，尽量学会数据库原理中的相关sql内容, 当然为了提高查询的能力也可以增加一点

5．    如果用到面向对像的语言那最好学点相关的设计模式，这样的可以增加代码的扩展性，及可维护性等，能够理解详细设计中的模块间的设计原则这个也可以提高对模块的内容编写的正确性.

6．    你一定要学会公司内部的通用的编码规范。

7．    学习如何做单元测试比较好.必须要熟悉相关的单元测试工具.

8．    要不断的对相关知识进行总结，同时也要必须把相关的资料进行整理和学习，在学习过后的资料中你可以在遇到问题时更快的找到问题的答题。

9．    在开发你必须记录下大家常出错的地方及大家的解决方法，这个对你以后错误的避免有很大的作用.

10．    在写代码中时必须把上面写过代码记在心里，这样就可以养成习惯，提高代码的速度

11．    对数据库操作时，要尽量共用Connection，并小用以减少Connection的数量

(二）    目标：高级程序员

职责：对需求文档进行系统相关模块的详细设计，并负责对程序员的支持及指导和相关核心模块的编写

所以不但要学会相关程序员要的知识，同时还要学会难度比较大的知识。

1． 程序员的知识，如设计模式你一定要不是简单的看要懂，你还要应用设计模式对相应的模块进行相关的详细设计。

2．  要学好相关详细设计的工具做的有的放矢，这样可以更好提高对自已的设计的表达

3．  为了提高系统的运行效率会运用到

a.         数据库的表结构如何建才能使应用的要查询sql 更快。这时可要认真认真的学习一样数据库原理，千万不要以为采用数据库的范式越高系统的运行效率会越好，有时候适当的表冗余可以大幅度的提高系统的查询效率.  同时适当的建索引,视图，存储过程也是提高系统对数据库的查询的效率之一。

b.         学习多线程的编程，不过千万不要以为线程数越多运行的速度会越快，一般线程的数量超过一定的数量后，系统的运行速度反而会变慢。为了应用好多线程，操作系统这本书也要关于同步及相关进程和线程的知识必不可少。

c.         设计好的一程序的好的算法，可要比起解一道同一复杂的数学题，要难的多，所以要在学好的相关数学的知识上（如线性代数，离散数学，概率论，数理统计）。更要深入计算方法，及数据结构，让数学问题用计算机来解决。

         4．为了让系统设计的更加的可扩展性，稳定性，设计模式和软件工程可是不能少的东西。所以必须把设计模式用于模式级的设计.

         5. 如果公司采用的是Rose (UML)进行设计的话，你对于UML 的理解一定要非常的准确，同时你要跟小组中的程序之间进行充分的UML概念上及对应用例图，类型图，对象图，协作图的意思多写一些注释加深大家对你的设计上的理解。

（三）         目标：系统分析员

职责：做好与客户之间的关系，同时对客户的需求要正确的理解，要选择合适的开发技术，同时做好与客户间沟通交流，学会说服对方。

1．  学会对客户的沟通：要正确理解客户的需求同时要保证相互之间的沟通顺畅。

2．  对了解来的需求要能用笔正确的描述下来，并能很好的传叙给其他人。这时要学会用如ROSE 等的软件建模的工具。和powerdesign等的数据库建模工具。和相关的UML,数据流程图及相关的内容的知识。

3．  不但要全面的了解客户的需求而且还要对需求进行未来的可能的改变要有相当多的了解。

4．  全面的了解客户的需求后，要选择合适的相关技术用于开发，：

这时要学习各种知识

a.  先择数据库：db2,infomix ,oracle ,sql server,mysql 的优缺点,可以从中选择最适合的数据库及理由。

b. 设计数据库：要扎实在数据库的理论（数据库原理，数据库系统设计）及相关数据库设计经验，要尽量多的分析过去数据库设计，分析这么设计数据库的好处。这时可能要用到 powerdesign等工具。 

c. 写需求说明文档和概要设计文档，同时要学会要分析相关需求说明文档的需要的内容的相关知识，如人员工时的计算方法， 一般会用 project 来分析相关的项目的内容。

d. 选择合适的程序语言及相关的架构，一般主流的架构是 J2EE和.net的相应的优点及它们之间的结合，如采用soap xml进行相关的结合，或用java-com 桥 进行相关的功能的调用。和它们之间的相关语言优缺点

e.  还要根据b/s,c/s 结构对开发的网络影响的相关内容采取选择。

 

5. 学会说服对方，毕竟客户都不是个个是软件专家，他们的选择有时未必是正确的所以学会说服对方，是系统分析员必备的能力条件.                            

 

 

 

三．    训练的方法：

    

1.       计划行事：

(1 设定你的未来的学习目标

a.         未来要成为什么样的人（主要是工作角色，如程序员，高级程序员，系统分析员）

b.         你近期要成为什么样的人（当前的工作职责是什么，如果只写代码是程序员等）

c.         要完成近期的工作所必须要知识（如java 程序员，要学习java 基础知识，等），关键的知识（如java中关键要用到的知识有，面向对象等）,易错的知识（比较原来的已有知识进行合对）

(2      设定你的学习目标后，并要有针对性的对应目标设定学习时间的按排及学习路线。并直观的记录在案，以便以后随时核对，

(3      常常抽出一定的时间认真核对计划的完成情况，如果没有按时完成计划的内容。分析原因，尽量想法赶上计划内容如果存认是计划有误，要认真总结计划失败出错的原因，对你的未来有很大的帮助。

注意：不要对计划的按排过于乐观 要尽量的考虑实现中的各种情况，同时适当按排一些缓冲时间，以便真正能按照计划行事，以提高按计划行事信心，同时这能有效避免出现计划中途成没有意义的东西。

2．  针对工作角色对自已的能力进行培养和知识进行学习。

关键的能力:

 (1. 记忆能力：要学会把自已的写的代码和改的代码记的清清楚楚。要能提高效率。

 （2． 逻辑思维能力：要多多的看别人的复杂逻辑的代码，分析复杂逻辑的运算。

 （3．全局能力： 不要再范改了东，却西出错。（构造软件这个很重要）

 （4．学习能力： 并不是每个项目都你是所熟悉的项目的，并不是每个项目中的知识你都知道，要掌握最新的技术和最有用的知识，是最关键的。要学会，提高能力，这个东西是永远对自己有好处的。

 （5． 沟通能力； 学会幽默，学会讲故事，学会交朋友，学会礼节。

 （6．自制能力：如果一个人不能自制那这个人以后，不会有很大成果，即使很大机会发展起了，可是因为没有自制能力很容易被人利用，或自己明明知道怎么做，可是就是不能控制自己的欲望.而常做下无法挽回在错误.

 

四．    例：java 程序员的知识结构及学习流程：

  (一) 学习相关工作必须的知识

   1．Java 语言的基础（推荐书：《 java 编程思想》）

关键：

（1.     java 面向对象及对应的程序现实

（2.     java  多线程

（3.     java  网络 socket 

（4.     应用界面

   2．学会用智能集成开发工具jbuilder，eclipse等一种,根据资料里的内容，自已写与例程类似的代码，但注意不要直接抄它，一定要自已写。同时最好写到一个工程中以便对比。

   3．如果用b/s结构要学习jsp的知识（推荐书：《 JSP 2.0技术手册 》）

关键：

（1． 界面处理： 

a . HTML--超文本标志语言:用于显示页面如：超文本链接, 表格,各种标志等。

b. CSS---层叠样式表:控制正文外观的一组格式.用于美化HTML页面。 

c. javaScript-嵌入HTML页面浏览器来执行的脚本语言:让页面可以根据用户的操作或事先设置等在客户端进行动态变化,而且不需传回服务器。比如: 对表单输入的正确性做客户端验证.

（2．jsp元素:如java代码写法，对应标志---jsp:include,jsp:useBean,jsp:setProperty,

jsp:getProperty等.jsp的几大对

 (3.  javaBean及其在jsp 中的调用和相关应用.

 (4. 其他技术：

  a. 如何操作数据库-用jdbc（可能要补充一些数据库的知识，如oracle ,sql server,

包括如何写高效率的查询sql,存储过程等） ,

b. 如何发送email-用javaMail，

c. 如何学习如何用实现文件的上传下载，如果操作文件，

d. 如何操作xml  --用jdom 及 jaxp（这时有必要学习一下xml 的语法如 dtd等）

e. 如何远程方法调用-用 rmi

f. 如何进行消息服务 ---用 jms

 5.再有些公司会用到 J2EE 的架构如 EJB 作为业务逻辑.

(1.EJB中要分清

(2. struts  MVC

(3. Hibernate 操作数据库

 6．最好学习一下UML 

学用Rose建模

 

 

五 忠告：

   1. 不要以为自已很差，要明白每个人都是这样一步一个脚印的走过来的。(我们要有信心)

告诉自已:比尔盖次，也是同我们一样，出生时也是巴掌大.

我们只有多学，多练才可能有出路.

   2. 不要以为自已学的多就很强，世界上的高手多的是，问问自己，你每小时可以写几行代码，代码一次写下来有多少错误，如果你一次写下没有错误，一小时可以写1000代码，那才是真正的高手.

   3 . 不要以为自已没有项目做就会落后于他人，人家是参加了很多项目，可是人家只是项目中的一个小角色，如果我们在空时能都写一些开源的项目，或自己开发和设计一些有用的开源的项目，水平及能力很快就上来了.

   4.   不要以为自己做过很多的项目就很了不起了。你能说你做的项目中，你能体会整个项目为什么要这样设计，为什么要这样开发吗？相信绝大多数是否定的回答。那还不如多学习一些已做的项目，了解他们为什么要这么做，为什么这么开发，多看一下它们的项目的文档，我们能明白很多，这样把他们的经验放于你未来可能要接手的项目，这样不是更好吗？

   5． 不要以为自己的学习能力很牛，你能快速阅读一本书又能快速掌握它的内容吗？


--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.214.*]
 


【文章标题】：【转】：AKA的由来 【文章地址】：https://bbs.byr.cn/article/SoftDesign/89 【创建时间】：2005-04-15 【作者】：AWK 【评论】：0 【内容】：发信人: AWK (awk), 信区: SoftDesign
标  题: 【转】：AKA的由来
发信站: 北邮人论坛 (Fri Apr 15 11:32:39 2005), 站内


　　今年4月份，当我在水木清华上发表那几篇文章的时候，我并没有想过这对我来说究竟意味着什么。

　　那时，我正在做网络教学的课题，并且有了一个自认为很好的想法，我把它叫做eForum。eForum最基本的想法是要把WWW、BBS、FTP、Email、News Group等等这些网络形式集合成一个完整的系统，因为我一直觉得现有的网络教学手段都不够充分。


　　我对这个想法很得意。然而，那时实验室的导师对此却并不怎么看重，而且，我也知道单凭我个人以及我们实验室的力量是无法实现这样一个系统的。

　　比较早的时候，我就开始关注“软件工程版”了。我知道HansB等人曾经在上面说过要通过网络进行协作开发，虽然后来没了下文，不过我知道有许多人是有热情的。于是，我想试一试。


　　我先在自己的机器上建了一个站点，把我的设想讲了讲，并且搞了几篇和软件工程有关的文章，希望与别人交流一下这方面的经验。接着我就跑到软件工程版上一口气发了好几篇文章，大意是：我有一个好想法，大家去我的站点上看看，我们来进行网络协作开发吧，等等。


　　我把开发小组起名叫阿卡，英文AKA。阿卡是《骑鹅旅行记》中的大雁。


　　在接下来的几天里，果然陆陆续续的来了一些人加入这个协作开发之中。


　　于是，我们第一次在水木清华的一个聊天室里碰了面。大家除了七嘴八舌的介绍了一下自己之外，这次讨论并没有什么实质性的成果。因此，在随后发的会议纪要上，我画上了一个苦瓜脸。:(

　　接下来的一个多星期里，我们陷入一中静默之中。我感到有些气馁。一方面是因为缺乏组织的经验；另一方面，也因为遭到实验室其他一些人的反对，使我对通过网络进行协作开发的可行性产生了怀疑。


　　这个网络协作的初次尝试面临着夭折的危险。


　　这时，waterbird和其他一些人在软件工程版发了几篇文章，表达了他们的意见和疑问。


　　我把它看成是对我的质询，并感到有些惭愧。我想，我应该承担起自己的责任，应该有所行动了！


　　于是，我把那段时间一直萦绕于怀的问题提了出来，要求大家回答。其中包括： AKA的组织方式应该怎样，她的未来如何发展等等的一些问题。


　　许多人就此发表了看法，从中也产生了AKA最初的成员。


　　我们再一次在水木清华的聊天室里碰了面，并决定马上在周日在清华礼堂前真正的碰面。当然，现在周五的例会和周日礼堂前的聚会已经成为一个惯例。

　　我们的第一次见面取得了很大的成果。正是在那次讨论中，我们基本确定了AKA的发展基调，也基本确定了AKA所要做的一些事情。


　　我们也意识到，要真正进行网络上的协作开发，还有许多工作要做。而且，eForum这个项目本身对我们来说也太庞大了。于是，我们决定把它先放一放。 就这样，网上协作的开发计划夭折了，而AKA却就此诞生了。


　　之后，我们按照计划改建了站点，成立了几个小组，并由waterbird草拟了章程。


　　这中间，仍旧陆陆续续的有人加入AKA，其中就有iasc，他是HansB的大学同学。

　　然而，期末马上到了，大家都不得不开始忙自己的事情。wuqiong、doc、bornworm和我，都忙着写论文、毕业的事情；HiHint因为实验室的活太忙而暂时退出AKA；HansB、sunray分别远在长沙和南京，也都忙着各自的事情。


　　好几个星期，我下午五点开始在礼堂前面等候，而姗姗而来的却总是只有waterbird和bornworm。有一次，在回去的时候，bornworm曾经问
　　waterbird：你说AKA究竟能坚持多久？


　　是啊，那时，我也常常问自己，我们到底能够坚持多久，而我自己又到底要在这条路上走多远？我也常常希望，终于有一天，自己能够将这一副担子转交给另一个人。

　　就象我在最开始说过的，当我在水木清华上发表那几篇文章的时候，我并没有想过这对我来说究竟意味着什么。


　　我的理想是人文方面的，甚至有一段时间我打算永远放弃在计算机方面的发展。然而，这时候来了AKA，就象一个婴儿出乎父母的意料来到这个世界。


　　我慢慢意识到，这已经不是我个人的事。AKA凝聚了许多人的希望和理想，就如waterbird所说：Aka 是一个信号，是下一个千年的发令枪。我想，我是在无意中扣动了扳机。


　　我知道自己不能退缩，那是可耻的。虽然做这样一件事情对于我这个毫无组织经验的人来说常常显得心有余而力不足。


　　goner曾经跟我说过：也许有一天，大家都会离开AKA，那时你一定要坚持住，坚持就是胜利。我不知道他所说的大家是指那天在一起吃饭的人还是所有的人，我感到有些悲凉，心想：如果AKA注定是一个失败的尝试的话，那么，我将是最后一个倒下的人。


　　goner的话一直在激励着我，我也明白他的意思：离开只是暂时的。毕业、出国、工作，这些都不能阻隔我们的理想。是的，坚持就是胜利。

　　在七月份的时候，我们的计划是：暑假期间尽量采取低调，不要太多引起外界的注意，也尽量避免新成员的加入。要脚踏实地，先把站点和组织结构建设好，然后等开学后再开始正式采取一些行动。


　　然而，情况的发展却并非如此。

　　先是iasc发现了Tachi。Tachi在Banly的“激流”上有一篇文章叫“世纪狂想曲”，描述了他对发展中国信息产业的构想，提议创建一个叫“中国信息技术论坛”的组织。


　　于是，我们就和Tachi联系，双方都有相见恨晚的意思，于是决定合并。合并后的组织正式名称就叫“中国信息技术论坛”，阿卡作为它的昵称。


　　这之后，我就开始着手用Domino改建站点。因为缺少人手，就在水木清华上发表了一个招募志愿者用Domino建立站点的文章。同时，我又发表了一篇“自由程序员之梦”的文章。


　　这几个行动打破了我们原来的计划，引来了不少新的成员加入。这迫使我们不得不加速前进。


　　8月上旬，iasc从武汉来到北京。于是借此机会，我们进行了一次聚会。这次聚会包括：iasc、goner、rivercool、waterbird、BlueOcean、boya、mikehe以及我自己。关于这次聚会的详细情形，我写过一个聚会的报告，在现在的Message版可以找到。


　　从此，我们又恢复了周五例会和周日在礼堂前的聚会。虽然，bornworm已经去了深圳，wuqiong工作太忙不能常来，doc在玉泉路没有条件上网；现在又有了几个新的“老面孔”：goner、rivercool、mikehe......


　　AKA终于逐步走上了轨道。


　　今天，在一段蹒跚的路程之后，AKA终于可以起飞了。然而，我感到：即使现在，我们仍然需要小心谨慎的摸索前进。我始终有着这样的担心，担心有一天由于我们的冒进和过度的膨胀而最终导致AKA的消散。

　　然而，不管怎么说，我想，正是我们这些人，站在了这个时代的最前端。如果历史真的赋予我们这样的角色，需要我们开拓前进，那么，就让我们勇敢的承担起我们的使命来吧！





--
        AWK is a usefull program under UNIX/Linux , I use it as my ID 

        just because it's simple and sounds fluent ! 

                         I like this!!
                    


※ 修改:·AWK 于 Apr 17 12:53:38 修改本文·[FROM: 59.64.214.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.214.*]
 【文章标题】：[转帖]局部变量的作用域--C++编译器如何实现异常处理 【文章地址】：https://bbs.byr.cn/article/SoftDesign/76 【创建时间】：2005-04-04 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: [转帖]局部变量的作用域--C++编译器如何实现异常处理
发信站: BBS 北邮人论坛站 (Mon Apr  4 11:42:00 2005), 站内

from <a target="_blank" href="http://localvar.blogchina.com/">http://localvar.blogchina.com/</a> 

[center]局部变量的作用域[/center]
[center]C++编译器如何实现异常处理[/center]

从实现的角度讲解VC++中的异常处理机制。本文在网上已经有了几个译本，但都不完整，所以我决定自己把它翻译过来。翻译过程中，力求信雅达，不足之处，敬请指出! 
C++编译器如何实现异常处理
作者：Vishal Kochhar  查看原文       翻译：局部变量     email：localvar#sohu.com 

         与传统语言相比，C++的一项革命性创新就是它支持异常处理。传统的错误处理方式经常满足不了要求，而异常处理则是一个极好的替代解决方案。它将正常代码和错误处理代码清晰的划分开来，程序变得非常干净并且容易维护。本文讨论了编译器如何实现异常处理。我将假定你已经熟悉异常处理的语法和机制。本文还提供了一个用于VC++的异常处理库，要用库中的处理程序替换掉VC++提供的那个，你只需要调用下面这个函数： install_my_handler(); 
之后，程序中的所有异常，从它们被抛出到堆栈展开（stack unwinding），再到调用catch块，最后到程序恢复正常运行，都将由我的异常处理库来管理。 
         与其它C++特性一样，C++标准并没有规定编译器应该如何来实现异常处理。这意味着每一个编译器的提供商都可以用它们认为恰当的方式来实现它。下面我会描述一下VC++是怎么做的，但即使你使用其它的编译器或操作系统①，本文也应该会是一篇很好的学习材料。VC++的实现方式是以windows系统的结构化异常处理（SEH）②为基础的。 


结构化异常处理—概述
         在本文的讨论中，我认为异常或者是被明确的抛出的，或者是由于除零溢出、空指针访问等引起的。当它发生时会产生一个中断，接下来控制权就会传递到操作系统的手中。操作系统将调用异常处理程序，检查从异常发生位置开始的函数调用序列，进行堆栈展开和控制权转移。Windows定义了结构"EXCEPTION_REGISTRATION"，使我们能够向操作系统注册自己的异常处理程序。 struct EXCEPTION_REGISTRATION
{
    EXCEPTION_REGISTRATION* prev;
    DWORD handler;
};  
         注册时，只需要创建这样一个结构，然后把它的地址放到FS段偏移0的位置上去就行了。下面这句汇编代码演示了这一操作： mov FS:[0], exc_regp  
prev字段用于建立一个EXCEPTION_REGISTRATION结构的链表，每次注册新的EXCEPTION_REGISTRATION时，我们都要把原来注册的那个的地址存到prev中。 
         那么，那个异常回调函数长什么样呢？在excpt.h中，windows定义了它的原形： EXCEPTION_DISPOSITION (*handler)( 
    _EXCEPTION_RECORD *ExcRecord, 
    void* EstablisherFrame, 
    _CONTEXT *ContextRecord, 
    void* DispatcherContext);  
不要管它的参数和返回值，我们先来看一个简单的例子。下面的程序注册了一个异常处理程序，然后通过除以零产生了一个异常。异常处理程序捕获了它，打印了一条消息就完事大吉并退出了。 #include 
#include 

using std::cout; 
using std::endl; 

struct EXCEPTION_REGISTRATION 
{ 
    EXCEPTION_REGISTRATION* prev; 
    DWORD handler; 
}; 

EXCEPTION_DISPOSITION myHandler( 
    _EXCEPTION_RECORD *ExcRecord, 
    void * EstablisherFrame, 
    _CONTEXT *ContextRecord, 
    void * DispatcherContext) 
{ 
    cout &lt;&lt; "In the exception handler" &lt;&lt; endl; 
    cout &lt;&lt; "Just a demo. exiting..." &lt;&lt; endl; 
    exit(0); 
    return ExceptionContinueExecution; //不会运行到这 
} 

int  g_div = 0; 

void bar() 
{ 
    //初始化一个EXCEPTION_REGISTRATION结构 
    EXCEPTION_REGISTRATION reg, *preg = &amp;reg;  
    reg.handler = (DWORD)myHandler; 

    //取得当前异常处理链的"头" 
    DWORD prev; 
    _asm 
    { 
        mov EAX, FS:[0] 
        mov prev, EAX 
    } 
    reg.prev = (EXCEPTION_REGISTRATION*) prev; 

    //注册！ 
    _asm 
    { 
        mov EAX, preg 
        mov FS:[0], EAX 
    } 

    //产生一个异常 
    int  j = 10 / g_div;  //异常，除零溢出 
} 

int  main() 
{ 
    bar(); 
    return 0; 
} 

/*-------输出------------------- 
In the exception handler 
Just a demo. exiting... 
---------------------------------*/  
        注意EXCEPTION_REGISTRATION必须定义在栈上，并且必须位于比上一个结点更低的内存地址上，windows对此有严格要求，达不到的话，它就会立刻终止进程。

函数和堆栈
        堆栈是用来保存局部对象的连续内存区。更明确的说，每个函数都有一个相关的栈桢（stack frame）来保存它所有的局部对象和表达式计算过程中用到的临时对象，至少理论上是这样的。但现实中，编译器经常会把一些对象放到寄存器中以便能以更快的速度访问。堆栈是一个处理器（CPU）层次的概念，为了操纵它，处理器提供了一些专用的寄存器和指令。  
        图1是一个典型的堆栈，它示出了函数foo调用bar，bar又调用widget时的情景。请注意堆栈是向下增长的，这意味着新压入的项的地址低于原有项的地址。

<a target="_blank" href="/att/SoftDesign/0/76/28596"><img border="0" title="1.gif" src="/att/SoftDesign/0/76/28596" alt="1.gif" class="resizeable"></a>
        通常编译器使用EBP寄存器来指示当前活动的栈桢。本例中，CPU正在运行widget，所以图中的EBP指向了widget的栈桢。编译器在编译时将所有局部对象解析成相对于栈桢指针（EBP）的固定偏移，函数则通过栈桢指针来间接访问局部对象。举个例子，典型的，widget访问它的局部变量时就是通过访问栈桢指针以下的、有着确定位置的几个字节来实现的，比如说EBP-24。 
       上图中也画出了ESP寄存器，它叫栈指针，指向栈的最后一项。在本例中，ESP指着widget的栈桢的末尾，这也是下一个栈桢（如果它被创建的话）的开始位置。 
       处理器支持两种类型的栈操作：压栈（push）和弹栈（pop）。比如， pop EAX 
的作用是从ESP所指的位置读出4字节放到EAX寄存器中，并把ESP加上（记住，栈是向下增长的）4（在32位处理器上）；类似的， 
push EBP 
的作用是把ESP减去4，然后将EBP的值放到ESP指向的位置中去。 
        编译器编译一个函数时，会在它的开头添加一些代码来为其创建并初始化栈桢，这些代码被称为序言（prologue）；同样，它也会在函数的结尾处放上代码来清除栈桢，这些代码叫做尾声（epilogue）。 
        一般情况下，序言是这样的： Push EBP ; 把原来的栈桢指针保存到栈上 
Mov EBP, ESP ; 激活新的栈桢 
Sub ESP, 10 ; 减去一个数字，让ESP指向栈桢的末尾  
       第一条指令把原来的栈桢指针EBP保存到栈上；第二条指令通过让EBP指向主调函数的EBP的保存位置来激活被调函数的栈桢；第三条指令把ESP减去了一个数字，这样ESP就指向了当前栈桢的末尾，而这个数字是函数要用到的所有局部对象和临时对象的大小。编译时，编译器知道函数的所有局部对象的类型和"体积"，所以，它能很容易的计算出栈桢的大小。 
       尾声所做的正好和序言相反，它必须把当前栈桢从栈上清除掉： Mov ESP, EBP 
Pop EBP ; 激活主调函数的栈桢 
Ret ; 返回主调函数  
它让ESP指向主调函数的栈桢指针的保存位置（也就是被调函数的栈桢指针指向的位置），弹出EBP从而激活主调函数的栈桢，然后返回主调函数。 
        一旦CPU遇到返回指令，它就要做以下两件事：把返回地址从栈中弹出，然后跳转到那个地址去。返回地址是主调函数执行call指令调用被调函数时自动压栈的。Call指令执行时，会先把紧随在它后面的那条指令的地址（被调函数的返回地址）压入栈中，然后跳转到被调函数的开始位置。图2更详细的描绘了运行时的堆栈。如图所示，主调函数把被调函数的参数也压进了堆栈，所以参数也是栈桢的一部分。函数返回后，主调函数需要移除这些参数，它通过把所有参数的总体积加到ESP上来达到目的，而这个体积可以在编译时知道： Add ESP, args_size  
当然，也可以把参数的总体积写在被调函数的返回指令的后面，让被调函数去移除参数，下面的指令就在返回主调函数前从栈中移去了24个字节： Ret 24  
取决于被调函数的调用约定（call convention），这两种方式每次只能用一个。你还要注意的是每个线程都有自己独立的堆栈。

<a target="_blank" href="/att/SoftDesign/0/76/41949"><img border="0" title="2.gif" src="/att/SoftDesign/0/76/41949" alt="2.gif" class="resizeable"></a>
C++和异常 
        回忆一下我在第一节中介绍的EXCEPTION_REGISTRATION结构，我们曾用它向操作系统注册了发生异常时要被调用的回调函数。VC++也是这么做的，不过它扩展了这个结构的语义，在它的后面添加了两个新字段： struct EXCEPTION_REGISTRATION 
{ 
    EXCEPTION_REGISTRATION* prev; 
    DWORD handler; 
    int id; 
    DWORD ebp; 
};  
       VC++会为绝大部分函数③添加一个EXCEPTION_REGISTRATION类型的局部变量，它的最后一个字段（ebp）与栈桢指针指向的位置重叠。函数的序言创建这个结构并把它注册给操作系统，尾声则恢复主调函数的EXCEPTION_REGISTRATION。id字段的意义我将在下一节介绍。 
       VC++编译函数时会为它生成两部分数据： 
a）异常回调函数 
b）一个包含函数重要信息的数据结构，这些信息包括catch块、这些块的地址和这些块所关心的异常的类型等等。我把这个结构称为funcinfo，有关它的详细讨论也在下一节。 
       图3是考虑了异常处理之后的运行时堆栈。widget的异常回调函数位于由FS:[0]指向的异常处理链的开始位置（这是由widget的序言设置的）。异常处理程序把widget的funcinfo结构的地址交给函数__CxxFrameHandler，__CxxFrameHandler会检查这个结构看函数中有没有catch块对当前的异常感兴趣。如果没有的话，它就返回ExceptionContinueSearch给操作系统，于是操作系统会从异常处理链表中取得下一个结点，并调用它的异常处理程序（也就是调用当前函数的那个函数的异常处理程序）。

<a target="_blank" href="/att/SoftDesign/0/76/59174"><img border="0" title="3.gif" src="/att/SoftDesign/0/76/59174" alt="3.gif" class="resizeable"></a>
       这一过程将一直进行下去——直到处理程序找到一个能处理当前异常的catch块为止，这时它就不再返回操作系统了。但是在调用catch块之前（由于有funcinfo结构，所以知道catch块的入口，参见图3），必须进行堆栈展开，也就是清理掉当前函数的栈桢下面的所有其他的栈桢。这个操作稍微有点复杂，因为：异常处理程序必须找到异常发生时生存在这些栈桢上的所有局部对象，并依次调用它们的析构函数。后面我将对此进行详细介绍。 
       异常处理程序把这项工作委托给了各个栈桢自己的异常处理程序。从FS:[0]指向的异常处理链的第一个结点开始，它依次调用每个结点的处理程序，告诉它堆栈正在展开。与之相呼应，这些处理程序会调用每个局部对象的析构函数，然后返回。此过程一直进行到与异常处理程序自身相对应的那个结点为止。 
       由于catch块是函数的一部分，所以它使用的也是函数的栈桢。因此，在调用catch块之前，异常处理程序必须激活它所隶属的函数的栈桢。 
       其次，每个catch块都只接受一个参数，其类型是它希望捕获的异常的类型。异常处理程序必须把异常对象本身或者是异常对象的引用拷贝到catch块的栈桢上，编译器在funcinfo中记录了相关信息，处理程序根据这些信息就能知道到哪去拷贝异常对象了。 
       拷贝完异常并激活栈桢后，处理程序将调用catch块。而catch块将把控制权下一步要转移到的地址返回来。请注意：虽然这时堆栈已经展开，栈桢也都被清除了，但它们占据的内存空间并没有被覆盖，所有的数据都还好好的待在栈上。这是因为异常处理程序仍在执行，象其他函数一样，它也需要栈来存放自己的局部对象，而其栈桢就位于发生异常的那个函数的栈桢的下面。catch块返回以后，异常处理程序需要"杀掉"异常对象。此后，它让ESP指向目标函数（控制权要转移到的那个函数）的栈桢的末尾——这样就把（包括它自己的在内的）所有栈桢都删除了，然后再跳转到catch块返回的那个地址去，就胜利的完成整个异常处理任务了。但它怎么知道目标函数的栈桢末尾在哪呢？事实上它没法知道，所以编译器把这个地址保存到了栈桢上（由前言来完成），如图3所示，栈桢指针EBP下面第16个字节就是。 
       当然，catch块也可能抛出新异常，或者是将原来的异常重新抛出。处理程序必须对此有所准备。如果是抛出新异常，它必须杀掉原来的那个；而如果是重新抛出原来的异常，它必须能继续传播（propagate）这个异常。 
       这里我要特别强调一点：由于每个线程有自己独立的堆栈，所以每个线程也都有自己独立的、由FS:[0]指向的EXCEPTION_REGISTRATION链。 
C++和异常—2
       图4是funcinfo的布局，注意这里的字段名可能与VC++编译器实际使用的不完全一致，而且我也只给出了和我们的讨论相关的字段。堆栈展开表（unwind table）的结构留到下节再讨论。

<a target="_blank" href="/att/SoftDesign/0/76/83432"><img border="0" title="4.gif" src="/att/SoftDesign/0/76/83432" alt="4.gif" class="resizeable"></a>
       异常处理程序在函数中查找catch块时，它首先要判断异常发生的位置是否在当前函数（发生异常的那个函数）的一个try块中。是则查找与此try块相关的catch块表，否则直接返回。 
       先来看看它怎样找try块。编译时，编译器给每个try块都分配了start id和end id。通过funcinfo结构，异常处理程序可以访问这两个id，见图4。编译器为函数中的每个try块都生成了相关的数据结构。 
       上一节中，我说过VC++给EXCEPTION_REGISTRATION结构加上了一个id字段。回忆一下图3，这个结构位于函数的栈桢上。异常发生时，处理程序读出这个值，看它是否在try块的两个id确定的区间[start id，end id]中。是的话，异常就发生在这个try块中；否则继续查看try块表中的下一个try块。 
       谁负责更新id的值，它的值又应该是什么呢？原来，编译器会在函数的多个位置安插代码来更新id的值，以反应程序的实时运行状态。比如说，编译器会在进入try块的地方加上一条语句，把try块的start id写到栈桢上。 
       找到try块后，处理程序就遍历与其关联的catch块表，看是否有对当前异常感兴趣的catch块。在try块发生嵌套时，异常将既源于内层try块，也源于外层try块。这种情况下，处理程序应该按先内后外的顺序查找catch块。但它其实没必要关心这些，因为，在try块表中，VC++总是把内层try块放在外层try块的前面。 
       异常处理程序还有一个难题就是"如何根据catch块的相关数据结构判断这个catch块是否愿意处理当前异常"。这是通过比较异常的类型和catch块的参数的类型来完成的。例如下面这个程序： void foo() 
{ 
    try 
    { 
        throw E(); 
    } 
    catch(H) 
    { 
        //. 
    } 
}  
如果H和E的类型完全相同的话，catch块就要捕获这个异常。这意味着处理程序必须在运行时进行类型比较，对C等语言来说，这是不可能的,因为它们无法在运行时得到对象的类型。C++则不同，它有了运行时类型识别（runtime type identification，RTTI），并提供了运行时类型比较的标准方法。C++在标准头文件中定义了type_info类，它能在运行时代表一个类型。catch块数据结构的第二个字段（ptype_info，见图4）是一个指向type_info结构的指针，它在运行时就代表catch块的参数类型。type_info也重载了==运算符，能够指出两种类型是否完全相同。这样，异常处理程序只要比较（调用==运算符）catch块参数的type_info（可以通过catch块的相关数据结构来访问）和异常的type_info是否相同，就能知道catch块是不是愿意捕获当前异常了。 
        catch块的参数类型可以通过funcinfo结构得到，但异常的type_info从哪来呢？当编译器碰到 throw E();  
这条语句时，它会为异常生成一个excpt_info结构，如图5所示。还是要提醒你注意这里用的名字可能与VC++使用的不一致，而且仍然只有与我们的讨论相关的字段。从图中可以看出，异常的type_info可以通过excpt_info结构得到。由于异常处理程序需要拷贝异常对象（在调用catch块之前），也需要消除掉它（在调用catch块之后），所以编译器在这个结构中同时提供了异常的拷贝构造函数、大小和析构函数的信息。

<a target="_blank" href="/att/SoftDesign/0/76/105437"><img border="0" title="5.gif" src="/att/SoftDesign/0/76/105437" alt="5.gif" class="resizeable"></a>
        在catch块的参数是基类，而异常是派生类时，异常处理程序也应该调用catch块。然而，这种情况下，比较它们的type_info绝对是不相等，因为它们本来就不是相同的类型。而且，type_info类也没有提供任何其他函数或运算符来指出一个类是另一个类的基类。但异常处理程序还必须得去调用catch块！为了解决这个问题，编译器只能为处理程序提供更多的信息：如果异常是派生类，那么etypeinfo_table（通过excpt_info访问）将包含多个指向etype_info（扩展了type_info，这个名字是我启的）的指针，它们分别指向了各个基类的etype_info。这样，处理程序就可以把catch块的参数和所有这些type_info比较，只要有一个相同，就调用catch块。 
       在结束这一部分之前，还有最后一个问题：异常处理程序是怎么知道异常和excpt_info结构的？下面我就要回答这个问题。  
       VC++会把throw语句翻译成下面的样子： //throw E(); //编译器会为E生成excpt_info结构 
E e = E(); //在栈上创建异常 
_CxxThrowException(&amp;e, E_EXCPT_INFO_ADDR);  
__CxxThrowException会把控制权连带它的两个参数都交给操作系统（控制权转移是通过软件中断实现的，请参见RaiseException）。而操作系统，在为调用异常回调函数做准备时，会把这两个参数打包到一个_EXCEPTION_RECORD结构中。接着，它从EXCEPTION_REGISTRATION链表的头结点（由FS:[0]指向）开始，依次调用各节点的异常处理程序。而且，指向当前EXCEPTION_REGISTRATION结构的指针也会作为异常处理程序的第二个参数出现。前面已经说过，VC++中的每个函数都在栈上创建并注册了EXCEPTION_REGISTRATION结构。所以传递这个参数可以让处理程序知道很多重要信息，比如说：EXCEPTION_REGISTRATION的id字段（用于查找catch块）、函数的栈桢（用于清理栈桢）和EXCEPTION_REGISTRATION结点在异常链表中的位置（用于堆栈展开）等。第一个参数是指向_EXCEPTION_RECORD结构的指针，通过它可以找到异常和它的excpt_info结构。下面是excpt.h中定义的异常回调函数的原型： EXCEPTION_DISPOSITION (*handler)( 
    _EXCEPTION_RECORD* ExcRecord, 
    void* EstablisherFrame, 
    _CONTEXT *ContextRecord, 
    void* DispatcherContext);  
后两个参数和我们的讨论关系不大。函数的返回值是一个枚举类型（也在excpt.h中定义），我前面已经说过，如果处理程序找不到catch块，它就会向系统返回ExceptionContinueSearch，对本文而言，我们只要知道这一个返回值就行了。_EXCEPTION_RECORD结构是在winnt.h中定义的： struct _EXCEPTION_RECORD 
{ 
    DWORD ExceptionCode; 
    DWORD ExceptionFlags; 
    _EXCEPTION_RECORD* ExcRecord; 
    PVOID ExceptionAddress; 
    DWORD NumberParameters; 
    DWORD ExceptionInformation[15]; 
}EXCEPTION_RECORD;  
       ExceptionInformation数组中元素的个数和类型取决于ExceptionCode字段。如果是C++异常（异常代码是0xe06d7363，源于throw语句），那么数组中将包含指向异常和excpt_info结构的指针；如果是其他异常，那数组中基本上就不会有什么内容，这些异常包括除零溢出、访问违例等，你可以在winnt.h中找到它们的异常代码。 
       ExceptionFlags字段用于告诉异常处理程序应该采取什么操作。如果它是EH_UNWINDING（见Except.inc），那是说堆栈正在展开，这时，处理程序要清理栈桢，然后返回。否则处理程序应该在函数中查找catch块并调用它。清理栈桢意味着必须找到异常发生时生存在栈桢上的所有局部对象,并调用其析构函数，下一节我们将就此进行详细讨论。 
清理栈桢
       C++标准明确指出：堆栈展开工作必须调用异常发生时所有生存的局部对象的析构函数。如下面的代码： int g_i = 0; 
void foo() 
{ 
    T o1, o2; 
    { 
        T o3; 
    } 
    10/g_i; //这里会发生异常 
    T o4; 
    //... 
}  
foo有o1、o2、o3、o4四个局部对象，但异常发生时，o3已经"死亡"，o4还未"出生"，所以异常处理程序应该只调用o1和o2的析构函数。 
        前面已经说过，编译器会在函数的很多地方安插代码来记录当前的运行状态。实际上，编译器在函数中设置了一些关键区域，并为它们分配了id，进入关键区域时要记录它的id，退出时恢复前一个id。try块就是一个例子,其id就是start id。所以，在try块的入口，编译器会把它的start id记到栈桢上去。局部对象从创建到销毁也确定了一个关键区域，或者，换句话说，编译器给每个局部对象分配了唯一的id，例如下面的程序： void foo() 
{ 
    T t1; 
    //. 
}  
编译器会在t1的定义后面（也就是t1创建以后）,把它的id写到栈桢上： void foo() 
{ 
    T t1; 
   _id = t1_id; //编译器插入的语句 
   //. 
}  
上面的_id是编译器偷偷创建的局部变量，它的位置与EXCEPTION_REGISTRATION的id字段重叠。类似的，在调用对象的析构函数前，编译器会恢复前一个关键区域的id。 
        清理栈桢时，异常处理程序读出id的值（通过EXCEPTION_REGISTRATION结构的id字段或栈桢指针EBP下面的4个字节来访问）。这个id可以表明，函数在运行到与它相关联的那个点之前没有发生异常。所有在这一点之前定义的对象都已初始化，应该调用这些对象中的一部分或全部对象的析构函数。请注意某些对象是属于子块（如前面代码中的o3）的，发生异常时可能已经销毁了，不应该调用它们的析构函数。 
        编译器还为函数生成了另一个数据结构——堆栈展开表（unwindtable，我启的名字），它是一个unwind结构的数组，可通过funcinfo来访问，如图4所示。函数的每个关键区域都有一个unwind结构，这些结构在展开表中出现的次序和它们所对应的区域在函数中的出现次序完全相同。一般unwind结构也会关联一个对象（别忘了，每个对象的定义都开辟了关键区域，并有id与其对应），它里面有如何销毁这个对象的信息。每当编译器碰到对象定义，它就生成一小段代码，这段代码知道对象在栈桢上的地址（就是它相对于栈桢指针的偏移），并能销毁它。unwind结构中有一个字段用于保存这段代码的入口地址： typedef void (*CLEANUP_FUNC)(); 
struct unwind 
{ 
    int prev; 
    CLEANUP_FUNC cf; 
};  
try块对应的unwind结构的cf字段是空值NULL，因为没有与它对应的对象，所以也没有东西需要它去销毁。通过prev字段，这些unwind结构也形成了一个链表。异常处理程序清理栈桢时，会读取当前的id值，以它为索引取得展开表中对应的项，并调用其第二个字段指向的清理代码，这样，那个与之关联的对象就被销毁了。然后，处理程序将以当前unwind结构的prev字段为索引，继续在展开表中找下一个unwind结构，调用其清理代码。这一过程将一直重复，直到链表的结尾（prev的值是-1）。图6画出了本节开始时提到的那段代码的堆栈展开表。

<a target="_blank" href="/att/SoftDesign/0/76/115449"><img border="0" title="6.gif" src="/att/SoftDesign/0/76/115449" alt="6.gif" class="resizeable"></a>
        现在把new运算符也加进来，对于下面的代码： T* p = new T();  
系统会首先为T分配内存，然后调用它的构造函数。所以，如果构造函数抛出了异常，系统就必须释放这些内存。因此，动态创建那些拥有"有为的构造函数"的类型时，VC++也为new运算符分配了id，并且堆栈展开表中也有与其对应的项，其清理代码将释放分配的内存空间。调用构造函数前，编译器把new运算符的id存到EXCEPTION_REGISTRATION结构中，构造函数顺利返回后，它再把id恢复成原来的值。 
        更进一步说，构造函数抛出异常时，对象可能刚刚构造了一部分，如果它有子成员对象或子基类对象，并且发生异常时它们中的一部分已经构造完成的话，就必须调用这些对象的析构函数。和普通函数一样，编译器也给构造函数生成了相关的数据来帮助完成这个任务。 
        展开堆栈时，异常处理程序调用的是用户定义的析构函数，这一点你必须注意，因为它也有可能抛出异常！C++标准规定堆栈展开过程中，析构函数不能抛出异常，否则系统将调用std::terminate。 
实现
       本节我们讨论其他三个有待详细解释的问题： 
a) 如何安装异常处理程序 
b) catch块重新抛出异常或抛出新异常时应该如何处理 
c) 如何对所有线程提供异常处理支持 
       随同本文，有一个演示项目，查看其中的readme.txt文件可以得到一些编译方面的帮助①。 
       第一项任务是安装异常处理程序，也就是把VC++的处理程序替换掉。从前面的讨论中，我们已经清楚地知道__CxxFrameHandler函数是VC++所有异常处理工作的入口。编译器为每个函数都生成一段代码，它们在发生异常时被调用，把相应的funcinfo结构的指针交给__CxxFrameHandler。 
       install_my_handler()函数会改写__CxxFrameHandler的入口处的代码，让程序跳转到my_exc_handler()函数。不过，__CxxFrameHandler位于只读的内存页，对它的任何写操作都会导致访问违例，所以必须首先用VirtualProtectEx把该内存页的保护方式改成可读写，等改写完毕后，再改回只读。写入的数据是一个jmp_instr结构。 //install_my_handler.cpp 

#include 
#include "install_my_handler.h" 

//C++默认的异常处理程序 
extern "C" 
EXCEPTION_DISPOSITION __CxxFrameHandler( 
    struct _EXCEPTION_RECORD* ExceptionRecord, 
    void* EstablisherFrame, 
    struct _CONTEXT* ContextRecord, 
    void* DispatcherContext 
    ); 

namespace 
{ 
    char cpp_handler_instructions[5]; 
    bool saved_handler_instructions = false; 
} 

namespace my_handler 
{ 
    //我的异常处理程序 EXCEPTION_DISPOSITION 
    my_exc_handler( 
        struct _EXCEPTION_RECORD *ExceptionRecord, 
        void * EstablisherFrame, 
        struct _CONTEXT *ContextRecord, 
        void * DispatcherContext 
    )  throw(); 

#pragma pack(push, 1) 
    struct jmp_instr 
    { 
        unsigned char jmp; 
        DWORD offset; 
    }; 
#pragma pack(pop) 

    bool WriteMemory(void* loc, void* buffer, int size) 
    { 
        HANDLE hProcess = GetCurrentProcess(); 

        //把包含内存范围[loc，loc+size]的页面的保护方式改成可读写 
        DWORD old_protection; 

        BOOL ret = VirtualProtectEx(hProcess, loc, size, PAGE_READWRITE, &amp;old_protection); 
        if(ret == FALSE) 
            return false; 

        ret = WriteProcessMemory(hProcess, loc, buffer, size, NULL); 

        //恢复原来的保护方式 
        DWORD o2; 
        VirtualProtectEx(hProcess, loc, size, old_protection, &amp;o2); 
        return (ret == TRUE); 
    } 

    bool ReadMemory(void* loc, void* buffer, DWORD size) 
    { 
        HANDLE hProcess = GetCurrentProcess(); 
        DWORD bytes_read = 0; 
        BOOL ret = ReadProcessMemory(hProcess, loc, buffer, size, &amp;bytes_read); 
        return (ret == TRUE &amp;&amp; bytes_read == size); 
    } 

    bool install_my_handler() 
    { 
        void* my_hdlr = my_exc_handler; void* cpp_hdlr = __CxxFrameHandler; 

        jmp_instr jmp_my_hdlr; 
        jmp_my_hdlr.jmp = 0xE9; 
        //从__CxxFrameHandler+5开始计算偏移，因为jmp指令长5字节 
        jmp_my_hdlr.offset = reinterpret_cast&lt;char*&gt;(my_hdlr) - (reinterpret_cast&lt;char*&gt;(cpp_hdlr) + 5); 

        if(!saved_handler_instructions) 
        { 
            if(!ReadMemory(cpp_hdlr, cpp_handler_instructions, sizeof(cpp_handler_instructions))) 
                return false; 
            saved_handler_instructions = true; 
        } 

        return WriteMemory(cpp_hdlr, &amp;jmp_my_hdlr, sizeof(jmp_my_hdlr)); 
    } 

    bool restore_cpp_handler() 
    { 
        if(!saved_handler_instructions) 
            return false; 
        else 
        { 
            void* loc = __CxxFrameHandler; 
            return WriteMemory(loc, cpp_handler_instructions, sizeof(cpp_handler_instructions)); 
        } 
    } 
}  
       编译指令#pragma pack(push, 1)告诉编译器不要在jmp_instr结构中填充任何用于对齐的空间。没有这条指令，jmp_instr的大小将是8字节，而我们需要它是5字节。 
       现在重新回到异常处理这个主题上来。调用catch块时，它可能重新抛出异常或抛出新异常。前一种情况下，异常处理程序必须继续传播（propagate）当前异常；后一种情况下，它需要在继续之前销毁原来的异常。此时，处理程序要面对两个难题："如何知道异常是源于catch块还是程序的其他部分"和"如何跟踪原来的异常"。我的解决方法是：在调用catch块之前，把当前异常保存在exception_storage对象中，并注册一个专用于catch块的异常处理程序——catch_block_protector。调用get_exception_storage()函数，就能得到exception_storage对象： exception_storage* p = get_exception_storage(); 
p-&gt;set(pexc, pexc_info); 
注册 catch_block_protector; 
调用catch块; //....  
        这样，当catch块（重新）抛出异常时，程序将会执行catch_block_protector。如果是抛出了新异常，这个函数可以从exception_storage对象中分离出前一个异常并销毁它；如果是重新抛出原来的异常（可以通过ExceptionInformation数组的前两个元素知道是新异常还是旧异常，后一种情况下着两个元素都是0，参见下面的代码），就通过拷贝ExceptionInformation数组来继续传播它。下面的代码就是catch_block_protector()函数的实现。 //------------------------------------------------------------------- 
// 如果这个处理程序被调用了，可以断定是catch块（重新）抛出了异常。 
// 异常处理程序（my_handler）在调用catch块之前注册了它。其任务是判断 
// catch块抛出了新异常还是重新抛出了原来的异常，并采取相应的操作。 
// 在前一种情况下，它需要销毁传递给catch块的前一个异常对象；在后一种 
// 情况下，它必须找到原来的异常并将其保存到ExceptionRecord中供异常 
// 处理程序使用。 
//------------------------------------------------------------------- 
EXCEPTION_DISPOSITION catch_block_protector( 
        _EXCEPTION_RECORD* ExceptionRecord, 
        void* EstablisherFrame, 
        struct _CONTEXT *ContextRecord, 
        void* DispatcherContext 
        ) throw () 
{ 
    EXCEPTION_REGISTRATION *pFrame; 
    pFrame= reinterpret_cast (EstablisherFrame); 
    if(!(ExceptionRecord-&gt;ExceptionFlags &amp; (_EXCEPTION_UNWINDING | _EXCEPTION_EXIT_UNWIND))) 
    { 
        void *pcur_exc = 0, *pprev_exc = 0; 
        const excpt_info *pexc_info = 0, *pprev_excinfo = 0; 
        exception_storage* p = get_exception_storage(); 
        pprev_exc = p-&gt;get_exception(); 
        pprev_excinfo= p-&gt;get_exception_info(); 
        p-&gt;set(0, 0); 
        bool cpp_exc = ExceptionRecord-&gt;ExceptionCode = = MS_CPP_EXC; 
        get_exception(ExceptionRecord, &amp;pcur_exc); 
        get_excpt_info(ExceptionRecord, &amp;pexc_info); 
        if(cpp_exc &amp;&amp; 0 == pcur_exc &amp;&amp; 0 == pexc_info) //重新抛出 
        { 
            ExceptionRecord-&gt;ExceptionInformation[1] = reinterpret_cast (pprev_exc); 
            ExceptionRecord-&gt;ExceptionInformation[2]= reinterpret_cast (pprev_excinfo); 
        } 
        else 
        { 
            exception_helper::destroy(pprev_exc, pprev_excinfo); 
        } 
    } 
    return ExceptionContinueSearch; 
}  
        下面是get_exception_storage()函数的一个实现： exception_storage* get_exception_storage() 
{ 
    static exception_storage es; 
    return &amp;es; 
}  
        在单线程程序中，这是一个完美的实现。但在多线程中，这就是个灾难了，想象一下多个线程访问它，并把异常对象保存在里面的情景吧。由于每个线程都有自己的堆栈和异常处理链，我们需要一个线程安全的get_exception_storage实现：每个线程都有自己单独的exception_storage，它在线程启动时被创建，并在结束时被销毁。Windows提供的线程局部存储（thread local storage，TLS）可以满足这个要求，它能让每个线程通过一个全局键值来访问为这个线程所私有的对象副本，这是通过TlsGetValue()和TlsSetValue这两个API来完成的。 
        Excptstorage.cpp中给出了get_exception_storage()函数的实现。它会被编译成动态链接库，因为我们可以籍此知道线程的创建和退出——系统在这两种情况下都会调用所有（当前进程加载的）dll的DllMain()函数，这让我们有机会创建特定于线程的数据，也就是exception_storage对象。 //excptstorage.cpp 

#include "excptstorage.h" 
#include 

namespace 
{ 
    DWORD dwstorage; 
} 

namespace my_handler 
{ 
    __declspec(dllexport) exception_storage* get_exception_storage() throw () 
    { 
        void * p = TlsGetValue(dwstorage); 
        return reinterpret_cast (p); 
    } 
} 


BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) 
{ 
    using my_handler::exception_storage; 
    exception_storage *p; 
    switch (ul_reason_for_call) 
    { 
    case DLL_PROCESS_ATTACH: 
        //主线程（第一个线程）不会收到DLL_THREAD_ATTACH通知，所以， 
        //与其相关的操作也放在这了 
        dwstorage = TlsAlloc(); 
        if (-1 == dwstorage) 
            return FALSE; 
        p = new exception_storage(); 
        TlsSetValue(dwstorage, p); 
        break ; 
    case DLL_THREAD_ATTACH: 
        p = new exception_storage(); 
        TlsSetValue(dwstorage, p); 
        break;  
    case DLL_THREAD_DETACH: 
        p = my_handler::get_exception_storage(); 
        delete p; 
        break ; 
    case DLL_PROCESS_DETACH: 
        p = my_handler::get_exception_storage(); 
        delete p; 
        break ; 
    } 
    return TRUE; 
}  

结论
        综上所述，异常处理是在操作系统的协助下，由C++编译器和运行时异常处理库共同完成的。 
注释和参考资料
       ① 本文写作期间，微软发布了Visual Studio 7.0。本文的异常处理库主要是在运行于奔腾处理器的windows2000上使用VC++6.0编译和测试的。但我也在VC++5.0和VC++7.0 beta版上测试过。6.0和7.0之间有一些差别，6.0先把异常（或其引用）拷贝到catch块的栈桢上，然后在调用catch块之前进行堆栈展开；7.0则先进行堆栈展开。在这方面，我的库代码的行为比较接近6.0版。 
       ② 参见Matt Pietrek发表在MSDN上的文章《structured exception handling》。  
       ③ 如果一个函数既不含try块，也没有定义任何具有"有为的析构函数"的对象，那么编译器将不为它生成用于异常处理的数据。
--
相信明天一定会比今天更加美好
每个人都有实现这个信念的责任

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.132.*]

 【文章标题】：Re: [转贴]大学十年——从学习版转过来，挺搞笑，也挺有意思 【文章地址】：https://bbs.byr.cn/article/SoftDesign/94 【创建时间】：2005-04-21 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: Re: [转贴]大学十年——从学习版转过来，挺搞笑，也挺有意思
发信站: BBS 北邮人论坛站 (Thu Apr 21 16:45:06 2005), 站内

浙江大学依山而傍西湖，是个美丽而高贵的大学。1997年春天，我就象干儿子那样挤进她的怀抱，并期望得到关爱。我到了向往已久的计算机辅助设计与图形学（CAD&amp;CG）国家重点实验室读博士学位。导师是石教英教授，石老师虽然年过六旬，但精力充沛，红光满面，施拉普纳不及他半分精神。 
我幸福地幻想着大干一番自己喜爱的专业，并计划在35岁左右成为实验室主任。开学的第一天，我兴冲冲地奔向实验室。进门不到5分钟，就因不懂规矩被看门的年青女子训了几次。为了不再冒犯规矩，我就老老实实地抓起一份计算机报纸并且站着阅读，心想这下不得罪谁了吧！ 
突然一个气得脸色铁青的男人（机房管理员之一）对我断喝：“你在干什么！你怎么可以不经允许就翻看别人的报纸！”似乎我是他一生中见到的最无耻的人。 
我就象一个情窦初开的少年飘飘然地去拥抱梦中情人，不料迎来两个耳光，此下场比《猫和老鼠》中的猫还惨。如果这两个年轻人有幸看到我这篇文章，应该好好悔过自新，她与他的工作态度打击过数十个学生的积极性。我本是因为向往CAD&amp;CG实验室而来的，得到的却是极坏的第一印象。（我博士毕业后，这两人也离开了实验室，我替后来的学生们谢天谢地。） 
CAD&amp;CG实验室在理论研究方面很有名气，但我的兴趣是开发实用的软件，“嫁错人”了。我颇费周折地考入CAD&amp;CG实验室，却尚未热身就全力而退，决心自立门户。至今我都没有用实验室的计算机编过一行程序。 
 
刚读博士时我穷困潦倒，只有一床，一盆，一壶，一碗。我那些穷朋友们象挤牙膏一样挤一些钱资肋我。我买了一台计算机，在宿舍里开发软件产品“可视化软件开发工具 VA 4.0”。1997年8月，我去北京参加首届中国大学生电脑大赛软件展示，路费也是借的。同学为我壮胆时说：“如果不能获奖，就回到实验室干活吧。” 
我说一定会拿第一名，不然去干啥。 
在软件展示时，我们发现很多好的作品是国家的科研项目，根本不是学生个人的作品，违背了竞赛的宗旨。如果允许这样做的话，学校可以运几条生产线过来。我写了一份抗议书，找了十几个人签名（很多人敢恨而不敢签）。但抗议能顶屁用，我参加过的科技竞赛、听过见过的科研鉴定多了，哪一次我没看到虚假？我写抗议书是因为眼里容不得沙子。如果我在北大读政治，恐怕早就遭殃了。 
这次竞赛选出十个“软件明星”，只有我的软件和清华大学博士生的项目值得一看。他的项目水平很高，但那不是他个人的作品（评委甚至认识他的导师，知道项目的来龙去脉）。综合诸多因素，我的作品被评为第一，他的项目被评为第二。组委会来拍电视，可是找不到浙江大学的展板。因为浙江大学没有任何准备，我是一个人来的，我的作品夹在杭电的作品之中，没名没姓。我只好从塑料袋上剪下“浙江大学”四个字，贴在展板上撑撑门面。 
自新中国成立以来，清华大学就一直在浙江大学头上“作威作福”，我好歹也争了一口气。可是颁奖时，组委会竟按地方顺序从北京念起，我沦落到第七，差点咽气。 
我曾在上海的一辆公共汽车上与一位北京来的旅客聊天，此公极健谈。似乎他到上海旅游的目的就是为了发掘北京的优越性。见我挂着浙江大学的红色校徽，且对清华、北大并不神往，不禁十分迷惑，就问：“浙江大学在浦东还是浦西？我要去看看。” 
北京已经是极度优越了，就请不要把什么鸡毛蒜皮的好东西都拿走。 
 
1997年11月，在穷得快挨饿的时候，我获得了中国大学生跨世纪发展基金特等奖（全国共20名，奖金1万元），到人民大会堂领奖。给我们出钱的是一个靠资本运作发财的集团，在宴会前，该集团领导人和我们座谈，他什么不好吹偏偏吹自己是个高科技企业：“我们主要从事生物工程，几年前就掌握了克隆技术，英国的‘克隆羊’简直是小菜一碟。……我们在东北有个农场，新品种的小麦长得比人还高，麦粒跟葡萄一样大，你们不久都会喝到用这种小麦酿的啤酒。……我如果去美国炒个总统，那就跟玩似得。” 
我们几个获奖的博士生吃饱喝足、拿了钱后，关起门来把那个老板臭骂一通，扬长而归。别以为给钱就能让我们说好话！ 
刚拿了“跨世纪发展基金”，又马上获得“浙江省青少年英才奖”，浙江大学也给我发奖学金。比起那些一个月只有300元工资的博士生们，我简直是“暴富”。还了朋友们给我的“救济款”后，仍然是个“富翁”。我老是觉得手头的钱是“抢劫”来的，心里不踏实。于是找浙江大学校团委“诉苦”，请校团委把我的“不义之财”捐给浙大的贫困学生。校团委的老师热情而坦诚，说愿意等我成为真正的富翁时再接受捐款，现在不能让我“杀鸡取卵”。但为了能让我表达心意，建议我资助“希望工程”的中学生，让我选了5个初一的学生，每个学生500元。我轻浮地以为自己真的帮助了5个中学生，直到1998年暑假我见到了其中的一个中学生，才发现自己做的好事只不过杯水车薪而已。我是到了自己贫困失意时才真正去帮助那些孩子的。 
 
在1997年，我在学生时期的荣誉已登峰造极，觉得自己的翅膀已经硬了，不想再混下去。我总以为自己是第二个史玉柱，应该开个软件公司来振兴民族软件产业。我曾到东软集团（沈阳）参加“民族软件产业青年论坛”，大不咧咧地作了一次演讲（现在发现演讲的内容没有一项是可以操作的）。杭州有一个记者来采访我，我谈了一天的理想，记者还是没听明白，干脆自己写新闻报道，并且含蓄地做了一个广告：万事俱备，只待投资。 
由于我能说会道，频频上电视，引来近10个投资者。我选择了一位年龄比我大一倍、非常精明的商人作合伙人，成立了“杭州临境软件开发有限公司”。彼时，我可谓光芒四射，名片上印着“以振兴民族软件产业为已任，做真实、正直、优秀的科技人员。”浙江大学有关部门想开除我，被我“晓之以理、动之以情”安抚住。 
我当时想开发一套名为Soft3D的图形系统，此系统下至开发工具，上至应用软件，无所不包。公司名字起为“临境”有两个含义：一是表示身临其境，这是我对图形技术的追求；二是表示快到了与SGI公司称兄道弟的境界，这是我对事业的追求。“临境”这个名字我在读本科时就已经想好了，1997年底公司成立的那一天，我有一种“媳妇熬成婆”的悲壮感觉。 
我从实验室挖来一位聪明绝顶的硕士生做技术伙伴。他叫周昆，年龄很小（1978年出生），研究能力极强。如果按照浙江大学计算机系博士生毕业的论文要求，他入学读硕士的那一天就可以博士毕业。周昆的头明显比我的大，估计其脑容量至少是我1.5倍。我曾经以师兄的身份为他洗过一双袜子，他因此觉得我是个好人。我俩一拍即合，常常为Soft3D的设计方案自我倾倒。一想到Microsoft公司的二维Windows系统即将被Soft3D打击得狼狈不堪时，我们就乐不可支，冲劲十足。 
我已经把“振兴民族软件产业”列入日程，并且提前担忧将来钱挣得太多用不完该怎么办。1998年5月份，我们做了一套既不是科研又不全象商品的软件。软件产品宣传了几个月，并没有出现订单如潮、接应不暇的局面（事实上压根就没有反应）。我意识到没有找对市场，但仍觉得产品中的一些技术很有价值，将它改装成其它软件也许能开创“东方不亮西方亮”的新局面。 
于是我向只有一面之缘尚在北大方正工作的周鸿袆求助。他是真正的软件高手，当我小心翼翼地展示约10万行C++代码的软件时，他竟在十几分钟内就指出多处重大的设计错误，使我目瞪口呆地意识到整个软件系统的价值为零。那种心痛啊，就象眼睁睁看着孩子被狼吃掉一样。 
到1998年10月，我用光了30万元资金。周鸿袆再一次从北京飞到杭州，三下五除二替我把只活了一年的公司关闭掉。他放心不下，觉得我“恶病需用猛药治”，于是意犹未尽地把我捉到北大方正插在他管辖的部门，让我学习怎样做事情。 
北京寒冷的冬天可以营造一种凄凉的气氛，冲去一切可以自我原谅的借口。我并不是太爱虚荣的人，知道这次失败是我的毛病积累到一定水准忍不住喷发出来的结果。我绝不能以年纪尚轻不太懂市场与管理为理由轻率地敷衍过去。 
从北大方正“劳改”了两个月回来，我心服口服地承认失败了。我把察觉到的数十个毛病列出来，日后一个一个克服掉。现在我能比较清醒地分析我和投资方所犯的主要错误，以祭我那幼年夭折的软件公司。 
我的主要错误： 
（1）年青气盛，在不具备条件的情况下，想一下子做成石破天惊的事。我的设计方案技术难度很大（有一些是热门的研究课题），只有30万元资金的小公司根本没有财力与技术力量去做这种事。 
（2）我以技术为中心而没有以市场为中心去做产品，以为自己喜欢的软件别人也一定喜欢。我涉足的是在国内尚不成气候的市场，我无法估计这市场有多大，人们到底要什么。伙伴们跟着我瞎忙乎一整年，结果做出一个洋洋洒洒没人要的软件。 
（3）我做到了“真实、正直”，但并没有达到优秀的程度。我曾得到很多炫目的荣誉，但学生时代的荣誉只是一种鼓励，并不是对我才能和事业的确认。正因为我不够优秀，学识浅薄，加上没有更高水平的人指点我，才会把事情搞砸了。 
投资方的主要错误： 
（1）投资方是个精明的商人，他把我的设计方案交给美国的一个软件公司分析，结论是否定的。但他觉得我这个人很有利用价值，希望可以做成功其它事情，即使Soft3D软件做不成功，只要挣到钱就行。这种心态使得正确的可行性分析变得毫无价值。 
（2）由于我不懂商业，又象所有单纯的学生那样容易相信别人。他让我写下了不公正的合同，我竟然向他借钱买下本来就属于我的30%技术股份。他名为投资方，实质上双方各出了一半的资金（他出51%，我出49%）。他在明知Soft3D软件不能成功的情况下，却为了占我的便宜而丧失了应有的精明，最终导致双方都损失。 
关闭公司时，他搬走了所有东西。我明明投入了技术，又亏了15万元，却一无所得。几个月后当我意识到不公平而找他协商时，他说：“只能怨你自己愚蠢，读到博士，连张合同都看不懂。”此事充分地显示了我的无知与愚蠢。自己的奋斗没有必要后悔太多，学到的远比失去的多，我相信下一次会做得更好。 
 
公司关闭后，我就面壁反省，补习基础，准备为几年之后“东山再起”养精蓄锐。 
1999年1月，有一个民营企业家G先生向我请教一个问题：“我给一个年轻人投资了100万元，建立一家从事环保信息应用开发的软件公司。他曾许诺一年内创利润上千万元，可是才过去5个月，他就把100万元用完了，什么也没挣到。我实在不明白是怎么回事，请你帮我分析分析。” 
这位G先生年龄有我的2.5倍，曾在西北当过几十年的技术兵，性格豪爽。他投资的那个年轻人叫Y（以下称Y经理），自称有英国的管理学文凭，能对公司的市场、技术、管理一把抓。G先生喜欢说“钱我没问题”，于是想也不想就投了100万元，并且给Y经理40%的股份。 
G先生请Y经理到家里座谈。我那时突然狡猾起来，自称是G先生的远房亲戚，在浙大读半导体物理，特羡慕那些做软件的同龄人，渴望听听Y经理的高见。Y经理果然信口开河，滔滔不绝，连绵不断，如黄河泛滥，一发而不可收拾。我激动地想去参观他的公司和产品，并表示要抛弃物理专业，立马转向软件专业。 
Y经理得意而笑：“对于IT行业你就不懂了，我们经营的是一种理念而不是产品，这是国外最先进的思想。你可以来参观我的公司，但你看不到具体的东西，只能用心去领会。” 
这屁话比曹元朗的诗还臭（《围城》）。我搞软件只有8年功夫，说我不懂IT行业并不过分。可我读了10年大学都没听到过如此“先进”的思想。如果这是英国管理学教育的成果，我认为自己已经发现了这个曾经是“日不落帝国”的衰败的真正原因，有必要找英国首相切磋一番。 
我对G先生说：“Y经理根本不懂技术，为人极其浮夸。应马上关闭公司，以绝后患。那100万元你也亏得起，就买个教训吧。” 
G先生说：“钱我没问题，那100万元就算我在澳门赌博输掉了。” 
1999年5月，G先生又来找我请教另一个问题。 
他说：“小林啊，你上次说得很有道理，我接受了教训。” 
我说：“那是好事，不论年龄大小，知错就改总是好孩子嘛。” 
他叹了一口气：“最近几个月，Y经理又花了我100万元。” 
我当时差点给噎死，气凶凶地训G先生：“我早跟你讲过，Y经理不是好东西，叫你关闭公司你不听，你老说钱没问题，亏你200万元活该。” 
老先生象犯了错误的小孩子：“Y经理每一次向我要钱时，都拍拍胸脯保证下个月就有利润，所以我一而再、再而三地掏钱给他，希望能救活软件公司。现在该怎么办？” 
一个有20名职员的软件公司，程序员只有三四个，连“十羊九牧”都不如。200万元的财务报表中，有100多万元用于吃喝玩乐和行贿。这种公司完全无药可救。台湾作家李敖曾说过：“当你没法扶一个人上马时，也许应该拉他下马”。从5月份到8月份，我行侠仗义，替G先生清理软件公司，根除Y经理这些败类。 
可是难哪，因为G先生投资的公司根本不把G先生放在眼里，又岂能让我插手。就在我想方设法卡住Y经理的脖子时，Y经理总能从G先生那里挖出钱。G先生就象被吸血鬼附身，却仍存幻想：“如果吸血鬼能治好我的病，就让它再吸些血吧。” 
Y经理又和一个来自深圳的骗子H想了注意，教唆G先生再投资100万元新建一个“指纹”公司，说利润将比开发环保信息更加可观（估计要用亿来度量）。就在他们准备签合同之际，我偶尔路过，发现异常，便强行阻止。 
G先生是个好人，但太顽固。好几次我气极想撒手不管，但又不忍心好人被坏人欺负。我曾请求G先生：“我求您别再说钱没有问题，您的私人财产会被人骗光。请让我把这漏洞堵住吧，好让我安心地回学校做完博士学位论文。” 
到8月份，我和G先生的两个儿子，伙同“黑社会”的朋友，强行把那个软件公司搬回G先生的工厂中，辞退所有员工。现在那个软件公司被别人接管，仍然半死不活，好在每月亏损不过几万元，G先生承受得起，我就不再去碰G先生的伤疤。 
我以前从未玩过与人勾心斗角的游戏，此三个月的经历让我疲惫不堪。那个软件公司的员工曾透露，Y经理的英国文凭大约是在上海或杭州某个大专培训班里混来的。方鸿渐买美国克莱顿大学博士文凭尚知羞耻（《围城》），而Y经理却趾高气扬。害得我平白无故为英国教育界担心，回想起英国鬼子曾打劫过中国，倍感耻辱。 
G先生是正人君子，不防小人，实在不是现代的商人。我和他成了忘年交。G先生第一次见到我时问我工资几何，我答曰：“300元，够买几本书。”G先生甚为着急：“这样的条件怎么能生活？你就搬到我家来住吧，我家条件好，你可以安心地学习，将来可为国家多作贡献。”后来他几次相邀，我就看在国家的份上住入他家，一直住到博士毕业。自从读中学以来，我第一次享受食来张口，不用洗衣服的奢侈。唯一的麻烦是我得向很多朋友解释：“我不是被别人养起来了，是为了国家的利益，不得已才这么做的。G先生是男的不是女的，并且没有待出嫁的女儿。” 
 
我在读博士学位的三年半里，经历有点奇特。我遗憾的是“真才实学”没有长进多少，并且没有了在西电那样的纯真友情。略为欣慰的是我做了几件有意义的事情。 
 
我很想讲一讲自己参加希望工程的经历与感受。 
1998年暑假，浙江省云和县梅源中学的老师们带着希望班几名优秀学生来到浙江大学，其中有受我资助的何晓丽同学。我才知道初中学生一个学期的学杂费就要600元。何晓丽哭诉下学期不能再上学，其它的学生处境相似。我以前资助的2000元是5个人3年平均分派的，根本不起作用。 
那时侯，公司倒闭使我债务累累，并且自信心遭受十年来最大的打击。我在入不敷出、心事重重的情况下，没有推卸义务，而是“变本加厉”的去尽这个义务。我在西电的好朋友史江一替我“接管”了一个中学生。有一个小姐追求我，我乘机给她一个活生生的“见面礼”。1999年7月份，我把饭卡送给了一个大学生，自己成了无产阶级。从1997年11月起到我博士毕业期间，我直接或间接地为7个贫困学生捐助了约1万元。我有了几点感受： 
（1）对人的帮助莫过于给予希望。 
（2）人在任何时候都能够帮助比自己更困难的人，哪怕自己处于困境。 
（3）帮助是要负责任的，一定要设法做成有意义的结果。不负责任的帮助就是“施舍”。“施舍”缺乏诚意，不配称为“帮助”。 
不少人曾对我说：“你是做大事的人，不要在小事上浪费精力，更不要为了别人而害了自己。” 
很多人总以为自己将来是伟大人物而不愿做小事，从而到死也没做成什么有价值的事。也有很多人希望自己成功后再去帮助别人，无论他最终成功还是失败，一辈子也没有帮助过人。还有很多人略有权势或略有名气后，便觉得自己吃喝玩乐、放屁、上厕所都是重要的事，在他们最能够帮助人的时候却以“太忙”“没空”为理由不去做好事。 
我也在忙碌、在奋斗，也渴望成为伟大人物，但我希望让有意义的小事充实一生。 
 
我还要讲另一件我常干的小事。 
很多受过高等教育的人保留了随地扔垃圾的“风俗习惯”，这恶习就象脚气那样虽然不致人于死地，但能遗臭万年。即便象浙江大学这等典雅的地方，你都经常可以看见草坪、校门口的废纸、果皮和塑料袋等，垃圾就如同天使脸上的一砣狗屎那样鲜艳，人们竟然无动于衷。我记不请自己多少次当众、当道捡垃圾，可是几年来我都没有在大学里发现第二个做这种事的人。 
我很想对所有的教授、博士、硕士、学士们讲句话：“救人并不只是医生干的事，保护环境也不只是清洁工干的事。只要你多花几秒钟，弯几次腰，就能让环境更加清洁，让心灵更加清洁。我们不必个个道貌岸然，但至少应该做到‘读书明理’。” 
那些正在追我和将要追我的小姐们，你多捡一次垃圾就多一份希望，你丢一次垃圾就不再有希望。 
我这样喋喋不休地讲“希望工程”和“捡垃圾”，并不是在沽名钓誉，也不是在布道，只是希望我这些“金玉良言”能触动更多的自以为自己是高素质的人们。 
 
在浙大的三年半里，我没有对感情“播种”，所以也没有收获，但有一次“艳遇”。 
在关闭公司的那天晚上，人去楼空，我象严监生断气前那样盯着尚未熄灭的灯。这时某大学的一位四年级女生来找我。一年前她曾作为实习记者采访过我，谈得很投机。我知道她是聪明好学的学生，曾大言不惭地教导过她几次。我开公司的一年里几乎没与她来往过，想不到当我成了光杆司令时她还能“兔死狐悲”地来看望我，着实让我感动。 
我不无自嘲地对她说：“你不用安慰我了，这次失败我还能挺得住。” 
她说：“我不是来安慰你的。我一直盼望你的公司倒闭，等了整整一年。在你去北京之前，我有话跟你说。” 
我心下一凉，搞不清什么地方得罪她了，让她如此记恨我。大概是我得意之日教导她时言语过重，伤了她的自尊心。好在我是知错就改的人，当下惭愧地向她道歉。 
她不理会我，说：“你开公司时光环重重，我根本无法靠近你。即便那时我成了你的好朋友，你也不会把我放在眼里。我暗恋你一年了，一直都没跟你讲。我早知道你会失败的，失败时你就剩下一个人，你才会知道我是真心爱你的，而不是冲着其它来的。你是个优秀的理科学生，我是个优秀的文科学生，门当户对，珠帘壁合。请你不要觉得女的追男的很荒唐，我是认真的，请你给我一次机会。” 
我虽然评不上情场高手，好歹也在爱河里游过泳，呛过水。想不到仓促之下，被一女子说得脸红耳赤，无法掩盖窘相。 
我一直认为男人应该勤劳一辈子，好让柔弱的女子舒舒服服地在大树下乘凉。而学习、工作出色的女子只能做朋友，不能做夫人。 
她从小习诗弄文，读大学时蜚声校园。我见到她第一面时就把她归类为事业上的朋友，所以才会正儿八经地与她交谈并教导她。我在西电的两个女朋友就属于读书不太好但比较有魅力的女生，我从来也没有指导过她们学习。如果我喜欢一个女孩子并希望她成为我的女朋友，我早就去追求她了，岂能轮到她追我。 
她见我彷徨不安，便滔滔不绝地例举爱我的“证据”。我开公司一年来发生的事她了如指掌，就象在我的房间里放了窃听器，在我的朋友中安插了间谍。她甚至趁着实习机会跑到团中央去查阅我的老底，有些“光辉记录”我过去的伙伴都未必知道。她思念我时，写了很多诗，留了很多泪…… 
我早知道有些人不编程序、不做实验就能写出论文，难道男女之间不接触也能滋生感情？ 
第一回合我就被她挑翻在地，我莫名其妙地成了“负心郎”，无地自容地把她送走。我以为这是文科女生的风格，就当作一个趣事不放在心上。 
我从北大方正“劳改”回来不久后，她提着一篮鲜花来找我，并对我说了她的梦想：在寒冷的冬天，大地铺满积雪，四野人鸟绝迹。我孤独求败地深居在冷冰冰的小木屋里。在一个狂风呼啸的黄昏，她一手拎着亲手做的饭菜（我想应该有土豆和辣椒），一手拎着一捆木柴，敲开了那扇紧闭的门和心房。终于木屋四壁生辉…… 
我曾对第一个朋友最好的赞美是：“黄蓉很象你。” 
我曾对第二个朋友最深情的话是：“将来咱们老了，我回黄岩当物理老师，你当语文老师。” 
相比之下，我的确不及她浪漫。此后她再找过我几次，当我意识到她动真格的时候，她已不能自拔。爱情是很怪的东西，并不是两个好人在一起就能碰出火花。与其让她长痛，还不如让她狠痛一次。 
我对她说：“我们真的不能在一起。” 
她问为什么？ 
我说：“不为什么，我没有心跳的感觉。” 
她说十年之后再找我。 
我知道她会奋发图强，因为她会一直想着“为什么”，期望让自己有个满意的答案。 这条路8年前我已经走过了。后来她读硕士时我曾再见过她，她在文学上已经有了长足的进步。 
她说将会送给我她的第一本著作，书中开头的几个故事是关于我和她。 
我说看了她的书后一定会写一篇读后感给她。 
她仍然提醒我不要忘记十年后的相约。 
 
我在浙大有一个值得怀念的人，她是管宿舍楼的大妈。在1999年1月至5月，我在博士生宿舍静心修炼内功，大妈就象我的“护法”。晚上九点钟时，她就会烧些东西给我吃。我和大妈非亲非故，同学们都不明白大妈为什么待我好。我想那是因为我没把自己当成“博士”来看，而是当成“人”来看。 
5月份后，我看在国家的份上搬到一个千万富翁家里去住，大妈也调到“熊猫馆”当掌门人。我一般隔几个月去看望大妈一次，中秋节我就和她在一起。朋友们知道我和大妈有这层关系，就纷纷托大妈物色女朋友。 
大妈果然称职，她就象特务那样审视大楼里的女生。可大妈毕竟是大妈，她采用的“标准”是几十年前的版本，无法与现今的兼容。她盯住了不该盯的，却漏掉了不该漏的，至今都未“推销”成功一个。 
这件事让我又明白了关于软件的一个道理：光有完善的数据库还不够，还应该提供很好的搜索引擎。 
 
我相信生活、科学、艺术中的很多道理是相通的，于是就不嫌人笑，写下了十年来的故事，交最后一次作业。 
大学十年给我留下了很多美好的回忆，现在可以打上漂亮的句号了。尽管我即将告别大学，但我会终生学习。也许我成不了天才，但还有机会成为天才的爸爸。 
我想大声呼喊出那种可以用双手把握未来的自豪。 
我要对年轻的朋友们说两句肺腑之言： 
一、主动去创造环境，否则你无法设计人生。 
二、生活和工作要充满激情，否则你无法体会到淋漓尽致的欢乐与痛苦。 
如果我碰到上帝，只会对他说一句话：“你看厕所去吧。”
--
程序是程序员才有的高尚爱好
程序是程序员才懂的欣赏的艺术
程序是只有程序员才能领悟的哲学
程序是永远的程序员的思维的结晶
作为程序员应该以自己是程序员而骄傲


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.141.*]
 【文章标题】：[推荐]  解读char (*(*x())[])() 【文章地址】：https://bbs.byr.cn/article/SoftDesign/88 【创建时间】：2005-04-14 【作者】：buptds 【评论】：0 【内容】：发信人: buptds (北邮纯净水), 信区: SoftDesign
标  题: [推荐]  解读char (*(*x())[])()
发信站: BBS 北邮人论坛站 (Thu Apr 14 11:14:47 2005), 站内

先得明白几个概念
char *
char **
char (* )[]
char *(* )[]




Thinking in C++ 里 作者介绍了一个简单的方法来解读复杂的定义式, 称为right-left guideline. 简单的说就是从中间的变量名开始, 按右-左-右-左...的顺序来读. 以这个题目为例:

char (*(*x())[])()

从x开始:
1.向右看到(), x是一个函数定义, 没有参数;
2.向左看到*, x的返回值是指针;
3.向右看到[], 指针指向数组;
4.向左看到*, 数组的元素也是指针;
5.向右看到(), 指针指向的是函数, 即函数指针, 而且函数没有参数.
6.向左看到char, 函数的返回值是char.

所以, x是一个没有参数的函数, 它的返回值是指向一个数组的指针, 而这个数组的元素是函数指针, 指向的函数没有参数, 且返回char.


++++++++++++++++++++++++++++++++++++++++++++++++++++


根据优先级：
char ( * ( * x ( ) ) [ ] ) ( )
             -----
x()说明x是个函数，函数的参数为空，函数的返回值为下面：

char ( * ( * x ( ) ) [ ] ) ( )
           =------
函数的返回值是个指针， (*x())
char ( * ( * x ( ) ) [ ] ) ( )
         ------------=====
        指向一个数组   (*x())[]

char ( * ( * x ( ) ) [ ] ) ( )
       =----------------
数组的元素是指针(*(*x())[])

char ( * ( * x ( ) ) [ ] ) ( )
==== ----------------------===
而指针是指向函数的(*(*x())[])(),显然，函数的参数为空
函数的返回值为char型









--
从哪里开始，在哪里结束。

※ 修改:·buptds 於 Apr 14 11:16:23 2005 修改本文·[FROM: 59.64.132.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.132.*]
 



【文章标题】：[转帖]超越自我 从程序员到系统分析员 【文章地址】：https://bbs.byr.cn/article/SoftDesign/97 【创建时间】：2005-04-23 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: [转帖]超越自我 从程序员到系统分析员
发信站: BBS 北邮人论坛站 (Sat Apr 23 19:32:23 2005), 站内

转自csdn

超越自我 从程序员到系统分析员 
(2005.04.21) 

大家应该对这两个词很熟悉了,但是对词里包含的意义可能并不是特别清楚。首先必须说明的是,程序员和系统分析员不存在谁高级谁低级的分别，他们是两种职业，对职业技能的要求完全不同。所以厉害的程序员就是系统分析员的说法是不对的。当然，系统分析员的技能要求他必须要懂得如何写程序，但是他的重心在于如何把一个很大的项目切割成适合个人的小块，然后将这些小块组织起来。程序员的职责就是如何更好更快的实现这些小块。 

　　在正式开始之前，我们还是来看在Thinking In Java中作者对分析和设计的一段精辟见解：

　　分析和设计

　　面向对象的范式是思考程序设计时一种新的、而且全然不同的方式，许多人最开始都会在如何构造一个项目上皱起了眉头。事实上，我们可以作出一个“好”的设计，它能充分利用OOP提供的所有优点。

　　请原谅在这里突然出现了OOP这个词，他的意思是面相对象，虽然在之前没有提到，但是在现在OO概念满天飞的软件世界里，大家应该对他不会太陌生。这里我简要的说明一下。在之前我介绍的实际上都是在很早以前程序写作流传下来的经验（什么，教我们老古董，打他！），但是以前的非OO（就是基于过程）的软件设计方法目前在国际上已经很少采用，所以我这里讲软件设计的时候所有的概念都是基于OO的。即使OO的概念很简单的啦，大家思考一下，我们再学习C++的时候一开始使用的类不都是一些动物啦、正方形啦之类的，都是生活中的例子，对吧。其实OO就是我们看世界的一种方式。可是最早由于计算机技术的不发达，我们不得不用一些很奇怪的描述来表达我们的意思，只有这样计算机才能理解，很笨不是吗。比如我们必须使用参数、过程、函数。所以当时的软件设计方法都是基于过程的。举一个简单的例子来显示OO设计方法和基于过程的设计方法之间的差别：一句简单的日常短语－－“我吃饭”，用OO的方法来表述还是“我吃饭”，可是如果用基于过程的方法来描述的话就变成“我吃饭（饭）”，是不是很别扭呢。

　　有关OOP分析与设计的书籍大多数都不尽如人意。其中的大多数书都充斥着莫名其妙的话语、笨拙的笔调以及许多听起来似乎很重要的声明。我认为这种书最好压缩到一章左右的空间，至多写成一本非常薄的书。具有讽剌意味的是，那些特别专注于复杂事物管理的人往往在写一些浅显、明白的书上面大费周章！如果不能说得简单和直接，一定没多少人喜欢看这方面的内容。毕竟，OOP的全部宗旨就是让软件开发的过程变得更加容易。尽管这可能影响了那些喜欢解决复杂问题的人的生计，但为什么不从一开始就把事情弄得简单些呢？因此，希望我能从开始就为大家打下一个良好的基础，尽可能用几个段落来说清楚分析与设计的问题。

　　不要迷失

　　在整个开发过程中，最重要的事情就是：不要将自己迷失！但事实上这种事情很容易发生。大多数方法都设计用来解决最大范围内的问题。当然，也存在一些特别困难的项目，需要作者付出更为艰辛的努力，或者付出更大的代价。但是，大多数项目都是比较“常规”的，所以一般都能作出成功的分析与设计，而且只需用到推荐的一小部分方法。但无论多么有限，某些形式的处理总是有益的，这可使整个项目的开发更加容易，总比直接了当开始编码好！ 也就是说，假如你正在考察一种特殊的方法，其中包含了大量细节，并推荐了许多步骤和文档，那么仍然很难正确判断自己该在何时停止。时刻提醒自己注意以下几个问题：

　　(1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？） 

　　(2) 它们的接口是什么？（需要将什么消息发给每一个对象？）

　　在确定了对象和它们的接口后，便可着手编写一个程序。出于对多方面原因的考虑，可能还需要比这更多的说明及文档，但要求掌握的资料绝对不能比这还少。

　　整个过程可划分为四个阶段，阶段0刚刚开始采用某些形式的结构。

　　阶段0：拟出一个计划

　　第一步是决定在后面的过程中采取哪些步骤。这听起来似乎很简单（事实上，我们这儿说的一切都似乎很简单），但很常见的一种情况是：有些人甚至没有进入阶段1，便忙忙慌慌地开始编写代码。如果你的计划本来就是“直接开始开始编码”，那样做当然也无可非议（若对自己要解决的问题已有很透彻的理解，便可考虑那样做）。但最低程度也应同意自己该有个计划。

　　在这个阶段，可能要决定一些必要的附加处理结构。但非常不幸，有些程序员写程序时喜欢随心所欲，他们认为“该完成的时候自然会完成”。这样做刚开始可能不会有什么问题，但我觉得假如能在整个过程中设置几个标志，或者“路标”，将更有益于你集中注意力。这恐怕比单纯地为了“完成工作”而工作好得多。至少，在达到了一个又一个的目标，经过了一个接一个的路标以后，可对自己的进度有清晰的把握，干劲也会相应地提高，不会产生“路遥漫漫无期”的感觉。

　　从我刚开始学习故事结构起（我想有一天能写本小说出来），就一直坚持这种做法，感觉就象简单地让文字“流”到纸上。在我写与计算机有关的东西时，发现结构要比小说简单得多，所以不需要考虑太多这方面的问题。但我仍然制订了整个写作的结构，使自己对要写什么做到心中有数。因此，即使你的计划就是直接开始写程序，仍然需要经历以下的阶段，同时向自己提出一些特定的问题。

　　阶段1：要制作什么？

　　在上一代程序设计中（即“过程化或程序化设计”），这个阶段称为“建立需求分析和系统规格”。当然，那些操作今天已经不再需要了，或者至少改换了形式。大量令人头痛的文档资料已成为历史。但当时的初衷是好的。需求分析的意思是“建立一系列规则，根据它判断任务什么时候完成，以及客户怎样才能满意”。系统规格则表示“这里是一些具体的说明，让你知道程序需要做什么（而不是怎样做）才能满足要求”。

　　需求分析实际就是你和客户之间的一份合约（即使客户就在本公司内部工作，或者是其他对象及系统）。系统规格是对所面临问题的最高级别的一种揭示，我们依据它判断任务是否完成，以及需要花多长的时间。由于这些都需要取得参与者的一致同意，所以我建议尽可能地简化它们——最好采用列表和基本图表的形式——以节省时间。可能还会面临另一些限制，需要把它们扩充成为更大的文档。 我们特别要注意将重点放在这一阶段的核心问题上，不要纠缠于细枝末节。这个核心问题就是：决定采用什么系统。对这个问题，最有价值的工具就是一个名为“使用条件”的集合。对那些采用“假如……，系统该怎样做？”形式的问题，这便是最有说服力的回答。例如，“假如客户需要提取一张现金支票，但当时又没有这么多的现金储备，那么自动取款机该怎样反应？”对这个问题，“使用条件”可以指示自动取款机在那种“条件”下的正确操作。

　　应尽可能总结出自己系统的一套完整的“使用条件”或者“应用场合”。一旦完成这个工作，就相当于摸清了想让系统完成的核心任务。由于将重点放在“使用条件”上，一个很好的效果就是它们总能让你放精力放在最关键的东西上，并防止自己分心于对完成任务关系不大的其他事情上面。也就是说，只要掌握了一套完整的“使用条件”，就可以对自己的系统作出清晰的描述，并转移到下一个阶段。在这一阶段，也有可能无法完全掌握系统日后的各种应用场合，但这也没有关系。只要肯花时间，所有问题都会自然而然暴露出来。不要过份在意系统规格的“完美”，否则也容易产生挫败感和焦燥情绪。 在这一阶段，最好用几个简单的段落对自己的系统作出描述，然后围绕它们再进行扩充，添加一些“名词”和“动词”。“名词”自然成为对象，而“动词”自然成为要整合到对象接口中的“方法”。只要亲自试着做一做，就会发现这是多么有用的一个工具；有些时候，它能帮助你完成绝大多数的工作。

　　尽管仍处在初级阶段，但这时的一些日程安排也可能会非常管用。我们现在对自己要构建的东西应该有了一个较全面的认识，所以可能已经感觉到了它大概会花多长的时间来完成。此时要考虑多方面的因素：如果估计出一个较长的日程，那么公司也许决定不再继续下去；或者一名主管已经估算出了这个项目要花多长的时间，并会试着影响你的估计。但无论如何，最好从一开始就草拟出一份“诚实”的时间表，以后再进行一些暂时难以作出的决策。目前有许多技术可帮助我们计算出准确的日程安排（就象那些预测股票市场起落的技术），但通常最好的方法还是依赖自己的经验和直觉（不要忘记，直觉也要建立在经验上）。感觉一下大概需要花多长的时间，然后将这个时间加倍，再加上10％。你的感觉可能是正确的；“也许”能在那个时间里完成。但“加倍”使那个时间更加充裕，“10％”的时间则用于进行最后的推敲和深化。但同时也要对此向上级主管作出适当的解释，无论对方有什么抱怨和修改，只要明确地告诉他们：这样的一个日程安排，只是我的一个估计！

　　阶段2：如何构建？

　　在这一阶段，必须拿出一套设计方案，并解释其中包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。此时可考虑采用一种特殊的图表工具：“统一建模语言”（UML）。请到<a target="_blank" href="http://www.rational.com/">http://www.rational.com/</a>去下载一份UML规格书。作为第1阶段中的描述工具，UML也是很有帮助的。此外，还可用它在第2阶段中处理一些图表（如流程图）。当然并非一定要使用UML，但它对你会很有帮助，特别是在希望描绘一张详尽的图表，让许多人在一起研究的时候。除UML外，还可选择对对象以及它们的接口进行文字化描述（《Thinking in C++》里说的那样，但这种方法非常原始，发挥的作用亦较有限。

　　我曾有一次非常成功的咨询经历，那时涉及到一小组人的初始设计。他们以前还没有构建过OOP（面向对象程序设计）项目，将对象画在白板上面。我们谈到各对象相互间该如何沟通（通信），并删除了其中的一部分，以及替换了另一部分对象。这个小组（他们知道这个项目的目的是什么）实际上已经制订出了设计方案；他们自己“拥有”了设计，而不是让设计自然而然地显露出来。我在那里做的事情就是对设计进行指导，提出一些适当的问题，尝试作出一些假设，并从小组中得到反馈，以便修改那些假设。这个过程中最美妙的事情就是整个小组并不是通过学习一些抽象的例子来进行面向对象的设计，而是通过实践一个真正的设计来掌握OOP的窍门，而那个设计正是他们当时手上的工作！

　　作出了对对象以及它们的接口的说明后，就完成了第2阶段的工作。当然，这些工作可能并不完全。有些工作可能要等到进入阶段3才能得知。但这已经足够了。我们真正需要关心的是最终找出所有的对象。能早些发现当然好，但OOP提供了足够完美的结构，以后再找出它们也不迟。

　　阶段3：开始创建

　　读这本书的可能是程序员，现在进入的正是你可能最感兴趣的阶段。由于手头上有一个计划——无论它有多么简要，而且在正式编码前掌握了正确的设计结构，所以会发现接下去的工作比一开始就埋头写程序要简单得多。而这正是我们想达到的目的。让代码做到我们想做的事情，这是所有程序项目最终的目标。但切不要急功冒进，否则只有得不偿失。根据我的经验，最后先拿出一套较为全面的方案，使其尽可能设想周全，能满足尽可能多的要求。给我的感觉，编程更象一门艺术，不能只是作为技术活来看待。所有付出最终都会得到回报。作为真正的程序员，这并非可有可无的一种素质。全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试，也使其更易理解和维护，而那正是一套软件赢利的必要条件。

　　构建好系统，并令其运行起来后，必须进行实际检验，以前做的那些需求分析和系统规格便可派上用场了。全面地考察自己的程序，确定提出的所有要求均已满足。现在一切似乎都该结束了？是吗？

　　阶段4：校订

　　事实上，整个开发周期还没有结束，现在进入的是传统意义上称为“维护”的一个阶段。“维护”是一个比较暧昧的称呼，可用它表示从“保持它按设想的轨道运行”、“加入客户从前忘了声明的功能”或者更传统的“除掉暴露出来的一切臭虫”等等意思。所以大家对“维护”这个词产生了许多误解，有的人认为：凡是需要“维护”的东西，必定不是好的，或者是有缺陷的！因为这个词说明你实际构建的是一个非常“原始”的程序，以后需要频繁地作出改动、添加新的代码或者防止它的落后、退化等。因此，我们需要用一个更合理的词语来称呼以后需要继续的工作。 这个词便是“校订”。换言之，“你第一次做的东西并不完善，所以需为自己留下一个深入学习、认知的空间，再回过头去作一些改变”。对于要解决的问题，随着对它的学习和了解愈加深入，可能需要作出大量改动。进行这些工作的一个动力是随着不断的改革优化，终于能够从自己的努力中得到回报，无论这需要经历一个较短还是较长的时期。

　　什么时候才叫“达到理想的状态”呢？这并不仅仅意味着程序必须按要求的那样工作，并能适应各种指定的“使用条件”，它也意味着代码的内部结构应当尽善尽美。至少，我们应能感觉出整个结构都能良好地协调运作。没有笨拙的语法，没有臃肿的对象，也没有一些华而不实的东西。除此以外，必须保证程序结构有很强的生命力。由于多方面的原因，以后对程序的改动是必不可少。但必须确定改动能够方便和清楚地进行。这里没有花巧可言。不仅需要理解自己构建的是什么，也要理解程序如何不断地进化。幸运的是，面向对象的程序设计语言特别适合进行这类连续作出的修改——由对象建立起来的边界可有效保证结构的整体性，并能防范对无关对象进行的无谓干扰、破坏。也可以对自己的程序作一些看似激烈的大变动，同时不会破坏程序的整体性，不会波及到其他代码。事实上，对“校订”的支持是OOP非常重要的一个特点。

　　通过校订，可创建出至少接近自己设想的东西。然后从整体上观察自己的作品，把它与自己的要求比较，看看还短缺什么。然后就可以从容地回过头去，对程序中不恰当的部分进行重新设计和重新实现（注释⑩）。在最终得到一套恰当的方案之前，可能需要解决一些不能回避的问题，或者至少解决问题的一个方面。而且一般要多“校订”几次才行。

　　构建一套系统时，“校订”几乎是不可避免的。我们需要不断地对比自己的需求，了解系统是否自己实际所需要的。有时只有实际看到系统，才能意识到自己需要解决一个不同的问题。若认为这种形式的校订必然会发生，那么最好尽快拿出自己的第一个版本，检查它是否自己希望的，使自己的思想不断趋向成熟。

　　反复的“校订”同“递增开发”有关密不可分的关系。递增开发意味着先从系统的核心入手，将其作为一个框架实现，以后要在这个框架的基础上逐渐建立起系统剩余的部分。随后，将准备提供的各种功能（特性）一个接一个地加入其中。这里最考验技巧的是架设起一个能方便扩充所有目标特性的一个框架（对这个问题，大家可参考第16章的论述）。这样做的好处在于一旦令核心框架运作起来，要加入的每一项特性就象它自身内的一个小项目，而非大项目的一部分。此外，开发或维护阶段合成的新特性可以更方便地加入。OOP之所以提供了对递增开发的支持，是由于假如程序设计得好，每一次递增都可以成为完善的对象或者对象组。

　　这有点类似“快速造型”。此时应着眼于建立一个简单、明了的版本，使自己能对系统有个清楚的把握。再把这个原型扔掉，并正式地构建一个。快速造型最麻烦的一种情况就是人们不将原型扔掉，而是直接在它的基础上建造。如果再加上程序化设计中“结构”的缺乏，就会导致一个混乱的系统，致使维护成本增加。
计划的回报

　　如果没有仔细拟定的设计图，当然不可能建起一所房子。如建立的是一所狗舍，尽管设计图可以不必那么详尽，但仍然需要一些草图，以做到心中有数。软件开发则完全不同，它的“设计图”（计划）必须详尽而完备。在很长的一段时间里，人们在他们的开发过程中并没有太多的结构，但那些大型项目很容易就会遭致失败。通过不断的摸索，人们掌握了数量众多的结构和详细资料。但它们的使用却使人提心吊胆在意——似乎需要把自己的大多数时间花在编写文档上，而没有多少时间来编程（经常如此）。我希望这里为大家讲述的一切能提供一条折衷的道路。需要采取一种最适合自己需要（以及习惯）的方法。不管制订出的计划有多么小，但与完全没有计划相比，一些形式的计划会极大改善你的项目。请记住：根据估计，没有计划的50％以上的项目都会失败！

　　非常佩服作者对软件构建过程的精辟见解，软件工程是一门内容非常繁杂的学科，但是作者能够用浅显易懂的句子把它描述出来，真的是非常不简单。软件工程最早的提出者并不是计算机的专业人士，而是一位建筑设计师，所以软件工程的很多思想来自于建筑学。经过了几十年的发展，软件工程经历了很多次的蜕变。形成了今天的世界上以一些大公司提出的架构为主的形式：比如微软提出的COM及COM+以及基于其上的DNA体系，SUN提出的EJB，CORBA，还有BEA、WebLogic、IBM等公司的架构。虽然架构有不同，但是他们的思想都是相通的，架构的作用都是起到辅助开发者实现规范的、科学的软件开发过程。至于谈软件项目的管理和开发，那么Rational公司就是这方面的鼻祖。综合来说，目前世界范围内的软件工程提倡的就是以渐进的、螺旋式的开发方法构建基于组件的软件产品。现在说这些东西可能有些画饼的嫌疑，随着我们专题讨论的继续深入，这些概念就会很清晰的展现在面前。

　　虽然很希望能够继续的讨论软件工程方面的东东，但是我们的这个专题毕竟是讨论如何编写优美的程序的，离题还是不要太过分的好，至于软件工程的详细讨论，我会在接下去的专题中继续。在接下去的篇幅中，我们会继续讨论程序员和系统分析员之间的差别。

　　四个阶段

　　这里我不想举一大堆的数字和实例来描述软件危机和论证软件工程的重要性，这方面的资料有很多，如果一一列举的话，会被怀疑别有用心。事实上，建造狗舍和写一个小的软件没有很大的区别。虽然你认为你的能力可以很轻松的完成小型的软件系统，根本不需要任何的计划。好！我来问问你，你在写程序代码的时候，有没有过漏这漏那，程序快接近完成的时候却发现少了一个很重要的模块；有没有过在书写了大量的代码之后觉得自己写出来的东西不堪入目，恨不得重头开始；有没有过写程序花了两天的时间，但是Debug却花了一个星期的时间；有没有过听到软件的使用者说要改需求，你就恨不得狠狠揍他一顿。如果都没有，那么只有两种可能：你是个超级天才，所有人类能够想到的美好品质你都具有，另一种可能：你根本没有开发过软件。

　　即便是个人开发的软件，软件工程科学中也有相应的方法来指导软件的开发过程，这种方法叫做PSP（个人软件开发过程），与此相对的，还有TSP（小组软件开发过程）。这些被事实证明行之有效的方法包括了一整套的规范，帮助你开发你的软件，不让你的程序变得无法控制。可以说，对于任何一个软件系统来说，只要你花一些时间去设计，即便你的设计仅仅只是在草稿纸上随便的涂抹，在软件开发完成后，你就会惊喜的发现，你在软件开发早期的小小投入，已经为你带来了额外的好处。

　　路标和RUP

　　在阶段0中，我想最重要的思想就是就是“路标”的概念了，和这个概念相类似的概念还有“周期”和“里程碑”的概念，这些概念在Rational公司的RUP(Rational Unified Process 软件统一过程)中有详细的论述。不论这些概念叫做什么，他们体现出来的是一种迭代开发的思想。面对当今的复杂的软件系统，使用连续的开发方法：如首先定义整个问题，设计完整的解决方案，编制软件并最终测试产品，是不可能的。需要一种能够通过一系列细化，若干个渐进的反复过程而生成有效解决方案的迭代方法。

　　Rational Unified Process支持专注于处理生命周期中每个阶段中最高风险的迭代开发方法，极大地减少了项目的风险性。迭代方法通过可验证的方法来帮助减少风险－－经常性的，可执行版本使最终用户不断的介入和反馈。因为每个迭代过程以可执行版本告终，开发队伍停留在产生结果上，频繁的状态检查帮助确保项目能按时进行。迭代化方法同样使得需求、特色、日程上战略性的变化更为容易。(出自《Rational Unified Process白皮书》)

　　上面这段好像很复杂，但是他所要说明的思想却是很简单的，就拿搭建狗舍来说，你的第一个“路标”可能是要搭一个框架，这个框架是由几根结实的木头组成，等到框架完成之后，你会把你的小白叫来，让他试一下，糟糕的是，这个框架对于小白来说小了一些，这时候你嘘了一口气，因为你原来是打算把整个狗舍搭好以后再叫小白来试一下的，如果你那样做的话，你剩下的木头可能就不够再盖一间狗舍了。好吧，既然有了些问题，我们就把框架调整一下，可能这个过程也花了你一些木头，不过所幸木头还够。在修整完毕后，你觉得第一步的计划虽然有些挫折，不过仍可以算是成功的，接下来你就要建立第二个“路标”了：第二个的“路标”是为狗舍钉上墙板和做出一个底座，你可能花了一些时间来思考以及和你的小白商量是否要在墙壁上开一个窗户和给底座加上轮子，在决定之后，你很快的达成了第二个“路标”。而且在经过了小白的测试后，你发现完全没有问题，你自己都觉得有些佩服自己了，很快的，你又完成刷油漆等“路标”。整个过程进展的非常顺利，而你在做狗舍方面很有天赋的名声也在你的街坊四邻间不胫而走。

　　很简单是吧，其实本来就是简单的，软件工程的目的就是要把复杂的软件开发过程条理化，简单化。记住，在你使用迭代开发方法的时候，它在每个周期后的产品是一份可执行代码，是一份可以让你的用户品头论足的东西。而这份可执行代码不仅包括了程序本身，可能还有其他的产成品，例如：文档等。

　　问题和场景

　　在阶段1中，非常重要的一点是问题描述，在多数情况下，问题描述来自于你的软件的使用者，就是用户。用户的需求决定了问题描述，糟糕的是，用户多半不懂计算机，对他们来说，他们只能够用日常的语言来表达自己的需要。而你的任务就是要把他们的语言翻译成计算机语言，不过并不是指象C那样的高级语言，而是便于你构造系统的需求描述语言。这同样很简单：你只需要问自己几个问题就可以：在什么场合？有什么条件？做些什么事？回答好这三个问题，你就完成了一个完整的问题描述了。

　　举一个简单的例子：一个银行的信贷系统有这样的问题描述：

　　“若顾客采取信用贷款方式，销售员就请求信用部门的审核人员查核顾客的信用，此时审核人员会向销售员取得顾客信用编号和销货总金额。”

　　在某种条件下应该做什么事情，这就是这个问题描述的表现形式，很简单是吧。

　　实际上，这里可以引申出两个概念：场景(context)和问题(problem)，场景指的是一种特定的情况，会导致某种问题的发生；而问题是在某个场景之中，但它也有可能产生出新的场景。

　　过程和对象

　　有必要说明一下以前基于过程的软件开发和目前基于对象的软件开发的不同。在没有OO的年代里，DFD(Data Flow Diagram 数据流程图)是一份软件设计中的非常重要的文档，注意力的关键也是集中在数据如何在各个系统之间传递。可是在现在的OO概念中，数据大有为消息(message)所替代的趋势。比如你到麦当劳快餐店，要花10块钱买一份汉堡。在DFD的时代，就是这样表示的：

　　如果你用消息表示法来表示话，就是另一种方式：

　　怎么样，你觉得那一种方式更自然呢。(如果你敢回答第一种的话我就...)。再比如上一段话中关于问题描述的例子，如果用传统的数据描述的方法的话，就会是这样子的：

　　“若采取信用贷款方式，销售员就将顾客信用编号及总金额交给信用部门的信用审核人员。”

　　请比较其中的两句话：

　　“若采取信用贷款方式，销售员就将顾客信用编号及总金额交给信用部门的信用审核人员。”

　　“若顾客采取信用贷款方式，销售员就请求信用部门的审核人员查核顾客的信用，此时审核人员会向销售员取得顾客信用编号和销货总金额。”

　　了解其中的不同之处了吗，用自然的语言去描述你的问题，这是写出好的软件的第一步。

系统分析员的语言

　　场景描述是一个很不错的方法，可是随着你对系统的分析的深入，参与开发的人员的增加，你渐渐的感觉这种方法不够用了。原因有很多：文字的描述不够直观，不可能到达一种很细致的程度。这时候就需要一种能够描述问题、描述解决方案、起沟通作用的语言。这就是UML。

　　UML(Unified Modeling Language 统一建模语言)是由Rational公司发明，目前由OMG(标准化对象管理机构)维护。作为一种建模语言,UML的定义包括UML语义和UML表示法两个部分：

　　UML语义　

　　描述基于UML的精确元模型定义。元模型为UML的所有元素在语法和语义上提供了简单、一致、通用的定义性说明,使开发者能在语义上取得一致,消除了因人而异的最佳表达方法所造成的影响。此外UML还支持对元模型的扩展定义。

　　UML表示法　

　　定义UML符号的表示法,为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准。这些图形符号和文字所表达的是应用级的模型,在语义上它是UML元模型的实例。标准建模语言UML的重要内容可以由下列五类图(共9种图形)来定义：用例图、静态图、行为图、交互图、实现图。

　　从应用的角度看,当采用面向对象技术设计系统时,首先是描述需求；其次根据需求建立系统的静态模型，以构造系统的结构；第三步是描述系统的行为。其中在第一步与第二步中所建立的模型都是静态的，包括用例图、类图(包含包)、对象图、组件图和配置图等五个图形，是标准建模语言UML的静态建模机制。其中第三步中所建立的模型或者可以执行，或者表示执行时的时序状态或交互关系。它包括状态图、活动图、顺序图和合作图等四个图形,是标准建模语言UML的动态建模机制。因此，标准建模语言UML的主要内容也可以归纳为静态建模机制和动态建模机制两大类。

　　这样说，你可能还是不了解UML到底是什么，不过UML并不是我们讨论的重点，你只需要知道UML是一种建模语言，他的目的就是在开发团队之间提供一种通用的、简单的沟通机制，并且UML是面相对象的。

　　上面所说的这些就是阶段2的重点所在。使用UML语言对阶段1中提出的问题描述进行深化，从各方各面看待问题：顺序、流程、数据、状态、接口等。最终你得到的是一套完整的文档，做为详细的程序设计的参考和标准。

　　不要累坏自己

　　上面说了这么多在编程之前要做的工作，但是要注意的是，不是所有的开发工作都必须做这么多的工作的。对于你来说，抓住最重要的内容，不要涉及到太多的细节。对你写出来问题描述，必须要仔细的分析，而这里的分析呢，并不是要你用程序来实现你的问题描述，而是你必须从问题描述中分析出对象(object)、事件(event)和消息(message)。例如上面所提到的例子：

　　“若采取信用贷款方式，销售员就将顾客信用编号及总金额交给信用部门的信用审核人员。”

　　你可能看到这句话以后就会在想做一个审核信用的函数，参数部分有信用编号和总金额，然后开始设计程序的细节。如果你是这样干的话，这说明你还没有真正了解OO的思想，你的开发方式仍然停留在以前基于过程的开发方式中。那么面相对象的分析是怎样进行的呢。我们还是来看这段话，撇开你的程序，你的语言，你从这句话中获得了什么信息？是的，你知道说这个企业中有销售员、有信用审核人员；要求审核顾客信用是他们的工作之一；顾客的信用编号和总金额是审核顾客信用的时候的重要信息。这是任何一个普通的人看到这段话后的感觉，这就是OO的分析(在OO中这种的分析方法称为OOAD)。其实是很简单的，和你采用什么样的程序一点关系都没有。

　　软件重用(Reuse)是软件工程中最重要的思想之一，只有软件重用，才能降低软件成本，提高软件的质量。你在对一个软件进行分析的时候，找出可以重用的对象，有助于你开发高效的软件系统。正如前面所说的，你不必把软件分析的过分细致，你只需从中找出关键性的、能够重用的对象就足够了。剩下的事情，就是对这些对象分配属性和方法，并充分的使用这些对象就好了。

　　还是那个例子：我们已经从中看到了一些对象：销售员、信用审核人员。但是他们在系统中不具备重用性，至少是重用性不强。信用部门这个对象也存在这个问题。所以不能够把他们作为底层的对象，我们用一个术语Entity Objects 来称呼底层对象。那什么是软件系统中的Entity Objects呢？毛主席教导我们要透过现象看本质。上面的描述中有很多隐含的信息：

　　顾客请求信用贷款：这里就包括两个Entity Objects：顾客、信用贷款。

　　销售员、信用审核人员都是员工，所以员工也是一个Entity Objects。

　　观察一个Entity Objects，你会发现，Entity Objects已经是最小的单位，是使用软件的用户(这里是银行)最小的单位。当然不但是这个软件有Entity Objects，比如我们最常用的Word，我们可以想象一下它的Entity Objects有什么，可能是一种叫做图元的Entity Objects，一个图元包括了文字、图象以及其他的对象。

　　用OO的方法分析你的软件，从设计到实现都是非常的自然，可能你学习面向对象时是从C++开始的，被其中的虚函数、多态性、多基类继承搞得一头雾水。但是实际上OO的方法要比以前的方法简单的多，不相信？试一试，你就知道了。

　　校订、校订再校订

　　第3个阶段称为校订，这个称呼真是太贴切了，既不是测试，也不是返工。任何事物从诞生起都必须经历不断的改进才有可能成熟。(呵呵，说出这么有哲理的话，我都很佩服自己啊。)软件同样不例外。事实上，在阶段0中，我们就讨论了“路标”的概念，当你的第一个路标达成之后，剩下的应该都是属于校订的事了。通过和用户的交互，确定新的“路标”，不断的改进系统功能，优化系统结构，修正系统Bug。

　　正如作者所说的那样，真正OO的软件是经得起修改的，由于采用了多层的结构以及面向对象的思想，以前软件的致命伤(修改)在新的开发方法面前不会是个大问题。(注意，这并不是说你可以无规划构建你的软件)

　　由于以前的系统大多会将GUI、事务处理、数据存储都做在一起，当你需要修改一个地方的时候，你就会发现问题的严重性：一个小小的需求变动都意味着你的系统将面临伤筋动骨般的修改。在OO的时代里，所有的对象的访问都是通过接口(Interface)进行的，对象中方法的改变并不会接口产生影响，也就是说，调用该接口的模块不用做任何的修改。另外，如果你打算把你的系统的界面从C/S方式向B/S方式改变，同样不会有问题，你可以很容易的把GUI部分从原有的系统中剥离出来。软件的修改对你来说不再是一个恶梦。

--
程序是程序员才有的高尚爱好
程序是程序员才懂的欣赏的艺术
程序是只有程序员才能领悟的哲学
程序是永远的程序员的思维的结晶
作为程序员应该以自己是程序员而骄傲


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.135.*]
 【文章标题】：Joke 【文章地址】：https://bbs.byr.cn/article/SoftDesign/95 【创建时间】：2005-04-23 【作者】：caozihua 【评论】：0 【内容】：发信人: caozihua (潜水员), 信区: SoftDesign
标  题: Joke
发信站: BBS 北邮人论坛站 (Sat Apr 23 16:14:49 2005), 站内

Why do programmers always get Christmas and Halloween mixed up?
(为什么程序员常把圣诞节和万圣节弄混了？)
Because DEC 25 = OCT 31


- "Have you heard about the object-oriennted way to become wealthy?"
(你有没有听过面向对象的致富方法？)
- "No..."
(没有...)
- "Inheritance."
(继承。)  
--
一转身
谁能把感慨抛在脑后
在事过境迁以后
这段情就算曾经刻骨且铭心过
过去了又改变什么
                                      ——蔡健雅 《陌生人》

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.194.*]
 

【文章标题】：[转帖]我是这样领导一个学生项目的 【文章地址】：https://bbs.byr.cn/article/SoftDesign/98 【创建时间】：2005-04-23 【作者】：Neverwinter 【评论】：3 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: [转帖]我是这样领导一个学生项目的
发信站: BBS 北邮人论坛站 (Sat Apr 23 19:41:25 2005), 站内

转自<a target="_blank" href="http://blog.csdn.net">http://blog.csdn.net</a>
转贴声明：本文在某些方面的做法是不当的，不要被迷惑。

我是这样领导一个学生项目的(1) 

    没想到在小组成立的第八天才想起来该为这个项目记下点什么，不是开发设计文档，也不是使用手册或者项目进度表，而是为了我自己的一些回忆。这是我领导的第三个软件开发项目，真正意义上的应当是第一个，因为这次是软件工程课程的实践项目，相比而言以前的两个只能算是体验软件开发的一些经历而已。同样的，作为真正意义上的Leader，或者PM（项目经理Project manager），我还是个新手。毕竟，软件工程这门课刚刚开始五个星期，区区十五个学时还不能带给我一些什么，因而我努力阅读了大量的书目去丰富我的知识体系。我希望这个项目能够获得我期待的成功，至少这门课程的结业成绩能够让我满意，仅此而已。当然，如果能积累下宝贵的丰富经验那便是额外的巨大收获。
    过去的一周让我充实，我从未如此大量的阅读书籍，在过去的七天中，我翻阅了近十本软件工程相关的书籍，它们大多是经典的和有效的，大约六本我仔细钻研了每一个细节，剩余的我循着前人的笔迹也汲取了足够的精华（这些书大多来自图书馆，感谢那些喜欢在书上乱涂乱画的前辈，是他们给我勾勒出了重点）。很难说我究竟学到了什么，技术上的也许没有，或者思想上的本就可以形式化为技术，那我的收获是丰富的。让我寄予期望最多的是著名的《人月神话》，这个书名让我的许多朋友误以为是小说的东西（事实上，人月指的是工作量，月指month），的确是那样迷人。如果说这本书与其它的书籍有什么区别，那就是：我阅读一般的两百页的书籍能够大约为其中的六七个闪光点而激动得手舞足蹈，而这本书有超过十次让我兴奋地从公交车上跳了起来（我不鼓励大家在公车上阅读，对视力的影响的确很大，尽管这是节省时间的一个有效的方法）。我要说的是，仅此而已，毕竟这是一本几十年前的书籍，尽管在它二十岁生日的时候再版过（这也正是我所阅读的版本），然而它并非是专为软件工程而设，尽管被软件工程领域的专家们奉为圣书。
    我的这个小组共有五名成员，很多项目经理不愿意将自己记入到成员数目中，一个典型的说法是：我们小组由我以及另外四名成员构成。这会使得项目经理变得孤立，特别是人人都对上司有天生的反感的情况下，这种现象并不仅仅出现在中国。在上一次的OOP（面向对象项目）中，有三个骨干成员保留到了现在的小组，另外两个中的一个是同样出色的一名成员，也是小组中唯一的女生。最后的一个是一个不折不扣的新兵，是一个还不知道OO为何物的初学者（也许这样说有些自大，似乎我们已经清楚什么是真正的OO一样）。他的加入是一个偶然，纯粹是出于哥们儿义气，这也是大多数学生项目会遇到的问题之一，你不得不去面对一些你并不愿意一同合作的搭档。如何将这样的五个人捏合在一起将成为我们的项目成功的关键。在人面前，技术将变得索然无味，记住这样一个事实，项目管理是面向人的。于是我不得不花去相当多的时间帮助他通过Java来入门，这缘于我对Java的热爱以及Java很可能成为我们的开发语言这一事实（请记住，永远不要做无用功，争取让你现在做的每一件事都可以成为将来迭代的一部分）。
    不要以为开会是一个不好的习惯，适当的会议是必要的，甚至是强行要求的，因为它可以让你的项目受益，我们为什么不适当进行会议呢。我的工作就是从第一次会议开始的，一个惊人的举动就是我决定在今后所有的字面文档和口头交流中都使用英文，为此我们进行了尝试，第一个吃螃蟹的人总是弥足珍贵，你的项目中需要有这样一个人，他有足够的能力，并且愿意尝试新鲜事物，不惧怕枪打出头鸟的传统观点。庆幸的，我们有这样一个组员（多使用“我们”而不是“我”，是每个项目经理应当养成的良好习惯）。于是，英文的交流顺利地展开了，尽管大家还有些约束，特别是那个新兵的四级考试还没有通过，着实让我汗颜。然而，轻车熟路之后一切都没有了障碍，单词成为了我们交流使用最多的单位，而不是句子。
    第一次会议是轻松的，不要指望能通过这次会议得到些什么，这是一次互相熟悉的会议，彼此需要互相熟悉习性、说话的习惯、喜欢的零食甚至迟到的时间，对于一个项目经理，掌握这些更为重要，我无意重复实践的重要性，实际情况的反馈往往是制定今后计划和策略的基础，也是最直接的来源，然而不幸的是，没有人可以为你收集这些资料，你需要做的是默默记在心里，然后转为今后的行动依据，一些估算往往由此而来。
    我们确定了文档的重要性，尽管文档驱动被更多的书籍称作软件开发的黑洞，一些专家认为文档仅仅是官僚主义的作风，当然没有人否认适当的文档是绝对必要的。什么样的文档应当生成呢？你需要将今后可能查阅的资料组织成文档，时刻告诫自己文档是面向未来的，而不是面向过去。单纯的流水账似的总结没有意义，附加上从中获得的经验教训才是这类文档的灵魂。
    还有可笑的预算机制，对于学生项目而言，没有明确的所谓客户的概念，没有人会为你的付出买单，所有的开支都是有去无回的，对于许多并不富裕的学生来说任何的开销都倍加重要，请记住，没有一个一天只能吃一顿肉的孩子会为了打印一百页纸而花去四十块钱，他们更宁愿选择手抄。庆幸的，我们的小组成员虽然不能称得上富裕，但至少可以经常在菜盆中发现牛肉的痕迹。我们的预算（budget）机制很简单，也许称之为报销（reimbursement）机制更为合适：每个人先交十块钱给CFO（首席财政管，我们经常为起了这个名字而感到乐趣），也就是当然不让的那个女生，然后项目总结时一并从中报销开支，多退少补。就像许多班级收班费一样，简单的往往是最好的，因为它易于被最多的人接受。会议在轻松的气氛中结束，伴着混沌和锅贴的香味，看来选择食堂作为会议地点是一个不错的决定，因为这里足够嘈杂，不会让大家觉得拘束而不敢说出真实的想法，即使冷场也可以借用咀嚼的声音来打发无聊的时光。一个更现实的原因是，我们找不到其他的地方能同时拥有灯光、场地以及大声说话的权利了，我们没有会议室可用。请记住，这是一个学生项目。
    第二次会议在一周之后举行，也就是昨天（还记得吗，我是在小组成立的第八天记录下的这篇文章）。一周以来，我明确了一个思想：项目经理必须和首席架构师分开，哪怕是四五个人的小型项目。这得感谢《人月神话》以及其他的软件项目管理的书籍（他们大多来自于机械工业出版社的软件开发技术丛书系列）。在以前的两个项目中，我都将项目管理和系统开发以及首席编程和测试融为一身，以至于曾经一个组员反问道：你都做完了还要我们干吗啊？的确，明确的分工是必要的，用人不疑，疑人不用。一个成功的项目经理应当懂得如何将工作交给适当的人去完成，而不是独自去完成所有的事。于是，我决定由另一个人来担任首席架构师的角色而不是我自己，这在我看来是一个破天荒的决定（尽管有些可笑），很多人（特别是学生和一些积极性不高的人）都会认为技术最好的人理应当成为项目经理，这也许也是我成为项目经理的原因，然而事实上要记住的是，项目经理是管理人的，而不是管理技术的，他所要做的仅仅是辅助首席架构师完成协调的工作，技术的事还是交给别人去完成吧。
    我在图书馆花去了五个小时翻阅了几乎所有关于软件工程方面的国外书籍（不是我对国内的书籍作者有偏见，然而确实国外的教材要优秀的多，当然国内不乏鼎鼎有名的作者和同样鼎鼎有名的著作），从需求分析、设计到质量保证、配置管理，还有CMM，等等一切。我选出了九本书籍作为我们项目的主要参考书目。我为我们的小组设计了五个领导人（感到奇怪吗，我们一共只有五个人而已），分别是需求经理、首席架构师、质量保障经理、测试经理以及项目经理，也就是我自己。九本书的一本是所有人都必须阅读的，另外我为其他每个人选择了相关领域的各两本参考书，我认为它们是可获得的、经典的和有效的参考书，这是我五个小时的全部结晶。在每个阶段或者说每个领域，都会以特定的人为中心，其他人接受他的指派完成任务，这样做的好处是利用有限的人员让每个人能够尽可能多的体验到软件项目的所有阶段，请记住，这是一个学生项目，学习是第一位的。为什么要我亲自去选择参考书，因为我的时间比他们富裕，我免修了本学期的三门其他课程，因而我能够有足够的时间去做这些事情，同时，选择书籍的过程也是自我提升的过程，何乐而不为呢。
    终于有人在第二次会议迟到了，直到我们收拾东西准备离场时才出现，后果就是我们已经分完了所有的职位，她没有选择地成为了需求经理。这并不是什么坏差事，然而对于这样的学生项目，没有真正的客户是一个很困难的问题。需求经理需要有强烈的自虐倾向，需要自己扮演客户、最终用户和需求分析师三个角色（如果你还不清楚客户和最终用户的区别，那太糟糕了。客户是出钱的人，用户是实际使用软件的人），这种经历恐怕是绝无仅有的，试想，一个人需要自己不断给自己出难题，然后去解决，太可怕了。那个新兵选择了质量保障经理，因为他认为这是个轻松的职位，不用太多的编写代码，他讨厌程序设计。事实上，我可以想象当他面对一大堆模型的时候他的反应。在软件项目中，如果你认为某一个职位是轻松的，那唯一的原因是你还没有真正理解这个职位的作用。
    会议中我最后强调的是，每个人都应当适时地召开会议，并非只有项目经理才有权召开会议，如果必要，任何人都可以这样做。另外，软件项目不是生活的全部，每个人应当将更多的精力放到生活中去，比如陪伴自己的家人，或者处理其他学业，这仅仅是一个项目，是诸多生活元素中的一部分，仅此而已。
    一周中我最大的工作是完成了项目计划的草案，这得益于我阅读的几本书籍，当然还有Rational SoDA，这是一个很棒的文档自动化工具，它的文档格式成为了我的设计标准，甚至教会了我许多Microsoft Word的使用技巧，比如自动生成目录。这份草案没有任何实质内容，仅仅是标题性的搭建了框架，所有的内容将在一周之内填充，为什么？因为我们还不知道项目的题目，除此以外的一切都会是徒劳。良好的准备是必要的，在组织任何文档之前都应当先建立模版或者框架，接下来的工作才是用内容去填充框架，而不是线性的编写过程。
    也许我还做过许多别的事，然而八天的缘故已经难以一一记录，有一些大概已经在脑海里永远冬眠了，甚至我自己都难以提取形成文字。庆幸的是每个人同样可以获得这些，只要愿意去阅读一些经典的书籍，总能得到。
    现在我能做的就是静静等待项目题目的出现，还有学习RUP，三个月之后项目交工之时我大约能够读完软件项目最经典的一百本书籍，这会是我最大的收获和骄傲。我喜欢从阅读中得到满足。
--
相信明天一定会比今天更加美好
每个人都有实现这个信念的责任

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.135.*]
 【文章标题】：讨论一下本版的发展 【文章地址】：https://bbs.byr.cn/article/SoftDesign/59 【创建时间】：2005-03-30 【作者】：Neverwinter 【评论】：10 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: 讨论一下本版的发展
发信站: 北邮人论坛 (Wed Mar 30 21:33:00 2005), 站内

软件开发基本上一直都是人气很低的板块，很多时候都是有人在看贴，但没人发贴。提高人气是个很艰巨的难题，我想看一下大家对提高人气有什么好的建议。请参与本版的发展讨论。
--
程序是程序员才有的高尚爱好
程序是程序员才懂的欣赏的艺术
程序是只有程序员才能领悟的哲学
程序是永远的程序员的思维的结晶
作为程序员应该以自己是程序员而骄傲


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 219.142.140.*]
 

【文章标题】：有没有人是研究ESB的 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22395 【创建时间】：2007-11-21 【作者】：vivin 【评论】：2 【内容】：发信人: vivin (阿诺), 信区: SoftDesign
标  题: 有没有人是研究ESB的
发信站: 北邮人论坛 (Wed Nov 21 17:26:52 2007), 站内

望能交流
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.180.*]
 
【文章标题】：如果要编写一个程序实现传输文件功能应该用什么方法呢？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22373 【创建时间】：2007-11-19 【作者】：talentlin8 【评论】：2 【内容】：发信人: talentlin8 (love myself), 信区: SoftDesign
标  题: 如果要编写一个程序实现传输文件功能应该用什么方法呢？
发信站: 北邮人论坛 (Mon Nov 19 13:01:52 2007), 站内

例如在c++中生成的文件传到opnet中，应该使用进程间通信 的方法还是 socket方法。
多谢了 
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.138.*]
 
【文章标题】：[转帖][C++]STL list的一些用法 【文章地址】：https://bbs.byr.cn/article/SoftDesign/102 【创建时间】：2005-04-23 【作者】：Neverwinter 【评论】：0 【内容】：发信人: Neverwinter (我是软件学院的！！！), 信区: SoftDesign
标  题: [转帖][C++]STL list的一些用法
发信站: BBS 北邮人论坛站 (Sat Apr 23 19:49:05 2005), 站内

转自blog.csdn.net
转贴声明：原文名为标准模板库(STL)介绍，但实际上是文不对题，故我将其核心部分提取出来，并换了个题目。

定义一个list
我们可以象这样来定义一个STL的list： 

#include &lt;string&gt;
#include &lt;list&gt;
int main (void) 
{
  list&lt;string&gt; Milkshakes;
  return 0;
}
    这就行了，你已经定义了一个list。简单吗？list&lt;string&gt; Milkshakes这句是你声明了list&lt;string&gt;模板类 的一个实例，然后就是实例化这个类的一个对象。但是我们别急着做这个。在这一步其实你只需要知道你定义了 一个字符串的list。你需要包含提供STL list类的头文件。我用gcc 2.7.2在我的Linux上编译这个测试程序，例如： 

g++ test1.cpp -o test1
    注意iostream.h这个头文件已经被STL的头文件放弃了。这就是为什么这个例子中没有它的原因。 

    现在我们有了一个list，我们可以看实使用它来装东西了。我们将把一个字符串加到这个list里。有一个非常 重要的东西叫做list的值类型。值类型就是list中的对象的类型。在这个例子中,这个list的值类型就是字符串,string ， 这是因为这个list用来放字符串。
--------------------------------------------------------------------------------

使用list的成员函数push_back和push_front插入一个元素到list中
#include &lt;string&gt;
#include &lt;list&gt;

int main (void) 
{
  list&lt;string&gt; Milkshakes;
  Milkshakes.push_back("Chocolate");
  Milkshakes.push_back("Strawberry");
  Milkshakes.push_front("Lime");
  Milkshakes.push_front("Vanilla");
  return 0;
}
我们现在有个4个字符串在list中。list的成员函数push_back()把一个对象放到一个list的后面，而 push_front()把对象放到前面。我通常把一些错误信息push_back()到一个list中去，然后push_front()一个标题到list中， 这样它就会在这个错误消息以前打印它了。

--------------------------------------------------------------------------------

The list member function empty()list的成员函数empty()
    知道一个list是否为空很重要。如果list为空，empty()这个成员函数返回真。 我通常会这样使用它。通篇程序我都用push_back()来把错误消息放到list中去。然后，通过调用empty() 我就可以说出这个程序是否报告了错误。如果我定义了一个list来放信息，一个放警告，一个放严重错误， 我就可以通过使用empty()轻易的说出到底有那种类型的错误发生了。 

    我可以整理这些list，然后在打印它们之前，用标题来整理它们，或者把它们排序成类。 

    这是我的意思： 

 
/*
|| Using a list to track and report program messages and status 
*/
#include &lt;iostream.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;
int main (void) 
{
  #define OK 0 
  #define INFO 1
  #define WARNING 2
  int return_code;
  list&lt;string&gt; InfoMessages;
  list&lt;string&gt; WarningMessages;

  // during a program these messages are loaded at various points
  InfoMessages.push_back("Info: Program started");
  // do work...
  WarningMessages.push_back("Warning: No Customer records have been found");
  // do work...
 
  return_code = OK; 
 
  if  (!InfoMessages.empty()) {          // there were info messages
     InfoMessages.push_front("Informational Messages:");
     // ... print the info messages list, we'll see how later
     return_code = INFO;
  }

  if  (!WarningMessages.empty()) {       // there were warning messages
     WarningMessages.push_front("Warning Messages:");
     // ... print the warning messages list, we'll see how later
     return_code = WARNING;              
  }

  // If there were no messages say so.
  if (InfoMessages.empty() &amp;&amp; WarningMessages.empty()) {
     cout &lt;&lt; "There were no messages " &lt;&lt; endl;
  }

  return return_code;
}

--------------------------------------------------------------------------------

用for循环来处理list中的元素
    我们想要遍历一个list，比如打印一个中的所有对象来看看list上不同操作的结果。要一个元素一个元素的遍历一个list， 我们可以这样做： 

/*
|| How to print the contents of a simple STL list. Whew! 
*/
#include &lt;iostream.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;

int main (void) 
{
  list&lt;string&gt; Milkshakes;
  list&lt;string&gt;::iterator MilkshakeIterator;

  Milkshakes.push_back("Chocolate");
  Milkshakes.push_back("Strawberry");
  Milkshakes.push_front("Lime");
  Milkshakes.push_front("Vanilla");
  
  // print the milkshakes
  Milkshakes.push_front("The Milkshake Menu");
  Milkshakes.push_back("*** Thats the end ***");
  for (MilkshakeIterator=Milkshakes.begin(); 
         MilkshakeIterator!=Milkshakes.end(); 
          ++MilkshakeIterator) 
  {
    // dereference the iterator to get the element
    cout &lt;&lt; *MilkshakeIterator &lt;&lt; endl;
  }     
}
    这个程序定义了一个iterator，MilkshakeIterator。我们把它指向了这个list的第一个元素。 这可以调用Milkshakes.begin()来作到，它会返回一个指向list开头的iterator。然后我们把它和Milkshakes.end()的 返回值来做比较，当我们到了那儿的时候就停下来。 

    容器的end()函数会返回一个指向容器的最后一个位置的iterator。当我们到了那里，就停止操作。 我们不能不理容器的end()函数的返回值。我们仅知道它意味着已经处理到了这个容器的末尾，应该停止处理了。 所有的STL容器都要这样做。 

    在上面的例子中，每一次执行for循环，我们就重复引用iterator来得到我们打印的字符串。 

    在STL编程中，我们在每个算法中都使用一个或多个iterator。我们使用它们来存取容器中的对象。 要存取一个给定的对象，我们把一个iterator指向它，然后间接引用这个iterator。 

    这个list容器，就象你所想的，它不支持在iterator加一个数来指向隔一个的对象。 就是说，我们不能用Milkshakes.begin()+2来指向list中的第三个对象，因为STL的list是以双链的list来实现的， 它不支持随机存取。vector和deque(向量和双端队列)和一些其他的STL的容器可以支持随机存取。 

    上面的程序打印出了list中的内容。任何人读了它都能马上明白它是怎麽工作的。它使用标准的iterator和标准 的list容器。没有多少程序员依赖它里面装的东西， 仅仅是标准的C++。这是一个向前的重要步骤。这个例子使用STL使我们的软件更加标准。 


--------------------------------------------------------------------------------

用STL的通用算法for_each来处理list中的元素
    使用STL list和 iterator，我们要初始化、比较和给iterator增量来遍历这个容器。STL通用的for_each 算法能够减轻我们的工作。 

 /*
|| How to print a simple STL list MkII
*/
#include &lt;iostream.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

PrintIt (string&amp; StringToPrint) {
  cout &lt;&lt; StringToPrint &lt;&lt; endl;
}

int main (void) {
  list&lt;string&gt; FruitAndVegetables;
  FruitAndVegetables.push_back("carrot");
  FruitAndVegetables.push_back("pumpkin");
  FruitAndVegetables.push_back("potato");
  FruitAndVegetables.push_front("apple");
  FruitAndVegetables.push_front("pineapple");
 
  for_each  (FruitAndVegetables.begin(), FruitAndVegetables.end(), PrintIt);
}
    在这个程序中我们使用STL的通用算法for_each()来遍历一个iterator的范围，然后调用PrintIt()来处理每个对象。 我们不需要初始化、比较和给iterator增量。for_each()为我们漂亮的完成了这些工作。我们执行于对象上的 操作被很好的打包在这个函数以外了，我们不用再做那样的循环了，我们的代码更加清晰了。 

    for_each算法引用了iterator范围的概念，这是一个由起始iterator和一个末尾iterator指出的范围。 起始iterator指出操作由哪里开始，末尾iterator指明到哪结束，但是它不包括在这个范围内。 


--------------------------------------------------------------------------------

用STL的通用算法count()来统计list中的元素个数。
     STL的通用算法count()和count_it()用来给容器中的对象记数。就象for_each()一样，count()和count_if() 算法也是在iterator范围内来做的。 

    让我们在一个学生测验成绩的list中来数一数满分的个数。这是一个整型的List。 

 /*
|| How to count objects in an STL list
*/
#include &lt;list&gt;
#include &lt;algorithm&gt;
#
int main (void) 
{
  list&lt;int&gt; Scores;
#
  Scores.push_back(100); Scores.push_back(80);
  Scores.push_back(45); Scores.push_back(75);
  Scores.push_back(99); Scores.push_back(100);
#
  int NumberOf100Scores(0);     
  count (Scores.begin(), Scores.end(), 100, NumberOf100Scores);
#
  cout &lt;&lt; "There were " &lt;&lt; NumberOf100Scores &lt;&lt; " scores of 100" &lt;&lt; endl;
}
    count()算法统计等于某个值的对象的个数。上面的例子它检查list中的每个整型对象是不是100。每次容器中的对象等于100，它就给NumberOf100Scores加1。这是程序的输出： 

  There were 2 scores of 100

--------------------------------------------------------------------------------

用STL的通用算法count_if()来统计list中的元素个数
     count_if()是count()的一个更有趣的版本。他采用了STL的一个新组件，函数对象。count_if() 带一个函数对象的参数。函数对象是一个至少带有一个operator()方法的类。有些STL算法作为参数接收 函数对象并调用这个函数对象的operator()方法。 

    函数对象被约定为STL算法调用operator时返回true或false。它们根据这个来判定这个函数。举个例子会 说的更清楚些。count_if()通过传递一个函数对象来作出比count()更加复杂的评估以确定一个对象是否应该被 记数。在这个例子里我们将数一数牙刷的销售数量。我们将提交包含四个字符的销售码和产品说明的销售记录。 

 
/*
|| Using a function object to help count things
*/
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

const string ToothbrushCode("0003");

class IsAToothbrush 
{
public:  
   bool operator() ( string&amp; SalesRecord ) 
   {
     return SalesRecord.substr(0,4)==ToothbrushCode;
   }     
};

int main (void) 
{
  list&lt;string&gt; SalesRecords;

  SalesRecords.push_back("0001 Soap");
  SalesRecords.push_back("0002 Shampoo");
  SalesRecords.push_back("0003 Toothbrush");
  SalesRecords.push_back("0004 Toothpaste");
  SalesRecords.push_back("0003 Toothbrush");
  
  int NumberOfToothbrushes(0);  
  count_if (SalesRecords.begin(), SalesRecords.end(), 
             IsAToothbrush(), NumberOfToothbrushes);

  cout &lt;&lt; "There were " 
       &lt;&lt; NumberOfToothbrushes 
       &lt;&lt; " toothbrushes sold" &lt;&lt; endl;
}
这是这个程序的输出： 

There were 2 toothbrushes sold
    这个程序是这样工作的：定义一个函数对象类IsAToothbrush，这个类的对象能判断出卖出的是否是牙刷 。如果这个记录是卖出牙刷的记录的话，函数调用operator()返回一个true，否则返回false。 

    count_if()算法由第一和第二两个iterator参数指出的范围来处理容器对象。它将对每个 IsAToothbrush()返回true的容器中的对象增加NumberOfToothbrushes的值。 

    最后的结果是NumberOfToothbrushes这个变量保存了产品代码域为"0003"的记录的个数，也就是牙刷的个数。 

    注意count_if()的第三个参数IsAToothbrush()，它是由它的构造函数临时构造的一个对象。你可以把IsAToothbrush类的一个临时对象 传递给count_if()函数。count_if()将对该容器的每个对象调用这个函数。 

　


--------------------------------------------------------------------------------

使用count_if()的一个更加复杂的函数对象。
    我们可以更进一步的研究一下函数对象。假设我们需要传递更多的信息给一个函数对象。我们不能通过 调用operator来作到这点，因为必须定义为一个list的中的对象的类型。 然而我们通过为IsAToothbrush指出一个非缺省的构造函数就可以用任何我们所需要的信息来初始化它了。 例如，我们可能需要每个牙刷有一个不定的代码。我们可以把这个信息加到下面的函数对象中： 

 
/*
|| Using a more complex function object
*/
#include &lt;iostream.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

class IsAToothbrush 
{
public:
  IsAToothbrush(string&amp; InToothbrushCode) : 
      ToothbrushCode(InToothbrushCode) {}
  bool operator() (string&amp; SalesRecord) 
  {
    return SalesRecord.substr(0,4)==ToothbrushCode;
  }       
private:
  string ToothbrushCode;        
};

int main (void) 
{
  list&lt;string&gt; SalesRecords;

  SalesRecords.push_back("0001 Soap");
  SalesRecords.push_back("0002 Shampoo");
  SalesRecords.push_back("0003 Toothbrush");
  SalesRecords.push_back("0004 Toothpaste");
  SalesRecords.push_back("0003 Toothbrush");
  
  string VariableToothbrushCode("0003");

  int NumberOfToothbrushes(0);  
  count_if (SalesRecords.begin(), SalesRecords.end(), 
              IsAToothbrush(VariableToothbrushCode),
                 NumberOfToothbrushes);
  cout &lt;&lt; "There were  "
       &lt;&lt; NumberOfToothbrushes 
       &lt;&lt; " toothbrushes matching code "
       &lt;&lt; VariableToothbrushCode
       &lt;&lt; " sold" 
       &lt;&lt; endl;
}
程序的输出是： 

There were  2 toothbrushes matching code 0003 sold
    这个例子演示了如何向函数对象传递信息。你可以定义任意你想要的构造函数，你可以再函数对象中做任何你 想做的处理，都可以合法编译通过。 

    你可以看到函数对象真的扩展了基本记数算法。

--------------------------------------------------------------------------------

使用STL通用算法find()在list中查找对象 

　　我们如何在list中查找东西呢？STL的通用算法find()和find_if()可以做这些。 就象for_each(), count(), count_if() 一样，这些算法也使用iterator范围，这个范围指出一个list或任意 其他容器中的一部分来处理。通常首iterator指着开始的位置，次iterator指着停止处理的地方。 由次iterator指出的元素不被处理。 
这是find()如何工作： 

/* 
|| How to find things in an STL list 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 

int main (void) { 
    list&lt;string&gt; Fruit; 
    list&lt;string&gt;::iterator FruitIterator; 

    Fruit.push_back("Apple"); 
    Fruit.push_back("Pineapple"); 
    Fruit.push_back("Star Apple"); 

    FruitIterator = find (Fruit.begin(), Fruit.end(), "Pineapple"); 
  
    if (FruitIterator == Fruit.end()) { 
        cout &lt;&lt; "Fruit not found in list" &lt;&lt; endl; 
    } 
    else { 
        cout &lt;&lt; *FruitIterator &lt;&lt; endl; 
    } 
} 

输出是： 

Pineapple 

如果没有找到指出的对象，就会返回Fruit.end()的值，要是找到了就返回一个指着找到的对象的iterator 


-------------------------------------------------------------------------------- 

使用STL通用算法find_if()在list中搜索对象 


这是find()的一个更强大的版本。这个例子演示了find_if()，它接收一个函数对象的参数作为参数， 并使用它来做更复杂的评价对象是否和给出的查找条件相付。 
假设我们的list中有一些按年代排列的包含了事件和日期的记录。我们希望找出发生在1997年的事件。 

/* 
|| How to find things in an STL list MkII 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
class EventIsIn1997 { 
public: 
    bool operator () (string&amp; EventRecord) { 
        // year field is at position 12 for 4 characters in EventRecord 
        return EventRecord.substr(12,4)=="1997"; 
    } 
}; 
 
int main (void) { 
    list&lt;string&gt; Events; 
 
    // string positions 0123456789012345678901234567890123456789012345 
    Events.push_back("07 January 1995 Draft plan of house prepared"); 
    Events.push_back("07 February 1996 Detailed plan of house prepared"); 
    Events.push_back("10 January 1997 Client agrees to job"); 
    Events.push_back("15 January 1997 Builder starts work on bedroom"); 
    Events.push_back("30 April 1997 Builder finishes work"); 
 
    list&lt;string&gt;::iterator EventIterator = find_if (Events.begin(), Events.end(), EventIsIn1997()); 
 
    // find_if completes the first time EventIsIn1997()() returns true 
    // for any object. It returns an iterator to that object which we 
    // can dereference to get the object, or if EventIsIn1997()() never 
    // returned true, find_if returns end() 
    if (EventIterator==Events.end()) { 
        cout &lt;&lt; "Event not found in list" &lt;&lt; endl; 
    } 
    else { 
        cout &lt;&lt; *EventIterator &lt;&lt; endl; 
    } 
} 

这是程序的输出： 

10 January 1997 Client agrees to job 

-------------------------------------------------------------------------------- 

使用STL通用算法search在list中找一个序列 
一些字符在STL容器中很好处理，让我们看一看一个难处理的字符序列。我们将定义一个list来放字符。 
list&lt;char&gt; Characters; 

现在我们有了一个字符序列，它不用任何帮助就知道然后管理内存。它知道它是从哪里开始、到哪里结束。 它非常有用。我不知道我是否说过以null结尾的字符数组。 

让我们加入一些我们喜欢的字符到这个list中： 

Characters.push_back('\0'); 
Characters.push_back('\0'); 
Characters.push_back('1'); 
Characters.push_back('2'); 

我们将得到多少个空字符呢？ 


int NumberOfNullCharacters(0); 
count(Characters.begin(), Characters.end(), '\0', NumberOfNullCharacters); 
cout &lt;&lt; "We have " &lt;&lt; NumberOfNullCharacters &lt;&lt; endl; 
让我们找字符'1' 

list&lt;char&gt;::iterator Iter; 
Iter = find(Characters.begin(), Characters.end(), '1'); 
cout &lt;&lt; "We found " &lt;&lt; *Iter &lt;&lt; endl; 
这个例子演示了STL容器允许你以更标准的方法来处理空字符。现在让我们用STL的search算法来搜索容器中 的两个null。 
就象你猜的一样，STL通用算法search()用来搜索一个容器，但是是搜索一个元素串，不象find()和find_if() 只搜索单个的元素。 

/* 
|| How to use the search algorithm in an STL list 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
int main ( void){ 
  
    list&lt;char&gt; TargetCharacters; 
    list&lt;char&gt; ListOfCharacters; 
  
    TargetCharacters.push_back('\0'); 
    TargetCharacters.push_back('\0'); 
  
    ListOfCharacters.push_back('1'); 
    ListOfCharacters.push_back('2'); 
    ListOfCharacters.push_back('\0'); 
    ListOfCharacters.push_back('\0'); 
  
    list&lt;char&gt;::iterator PositionOfNulls = search(ListOfCharacters.begin(), ListOfCharacters.end(), TargetCharacters.begin(), TargetCharacters.end()); 
  
    if (PositionOfNulls!=ListOfCharacters.end()) 
        cout &lt;&lt; "We found the nulls" &lt;&lt; endl; 
} 

The output of the program will be 这是程序的输出： 

We found the nulls 

search算法在一个序列中找另一个序列的第一次出现的位置。在这个例子里我们在ListOfCharacters中 找TargetCharacters这个序列的第一次出现，TargetCharacters是包含两个null字符的序列。 
search的参数是两个指着查找目标的iterator和两个指着搜索范围的iterators。 因此我们我们在整个的ListOfCharacters的范围内查找TargetCharacters这个list的整个序列。 

如果TargetCharacters被发现，search就会返回一个指着ListOfCharacters中序列匹配的第一个 字符的iterator。如果没有找到匹配项，search返回ListOfCharacters.end()的值。 



-------------------------------------------------------------------------------- 

使用list的成员函数sort()排序一个list。 


要排序一个list，我们要用list的成员函数sort()，而不是通用算法sort()。所有我们用过的算法都是 通用算法。然而，在STL中有时容器支持它自己对一个特殊算法的实现，这通常是为了提高性能。 
在这个例子中，list容器有它自己的sort算法，这是因为通用算法仅能为那些提供随机存取里面元素 的容器排序，而由于list是作为一个连接的链表实现的，它不支持对它里面的元素随机存取。所以就需要一个特殊的 sort()成员函数来排序list。 

由于各种原因，容器在性能需要较高或有特殊效果需求的场合支持外部函数(extra functions)， 这通过利用构造函数的结构特性可以作到。 


/* 
|| How to sort an STL list 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
PrintIt (string&amp; StringToPrint) { cout &lt;&lt; StringToPrint &lt;&lt; endl;} 
 
int main (void) { 
    list&lt;string&gt; Staff; 
    list&lt;string&gt;::iterator PeopleIterator; 
 
    Staff.push_back("John"); 
    Staff.push_back("Bill"); 
    Staff.push_back("Tony"); 
    Staff.push_back("Fidel"); 
    Staff.push_back("Nelson"); 
 
    cout &lt;&lt; "The unsorted list " &lt;&lt; endl; 
    for_each(Staff.begin(), Staff.end(), PrintIt ; 
 
    Staff.sort(); 
 
    cout &lt;&lt; "The sorted list " &lt;&lt; endl; 
    for_each(Staff.begin(), Staff.end(), PrintIt); 
} 

输出是： 

The unsorted list 
John 
Bill 
Tony 
Fidel 
Nelson 
The sorted list 
Bill 
Fidel 
John 
Nelson 
Tony 

-------------------------------------------------------------------------------- 

用list的成员函数插入元素到list中 
list的成员函数push_front()和push_back()分别把元素加入到list的前面和后面。你可以使用insert() 把对象插入到list中的任何地方。 
insert()可以加入一个对象，一个对象的若干份拷贝，或者一个范围以内的对象。这里是一些 插入对象到list中的例子： 

/* 
|| Using insert to insert elements into a list. 
*/ 
#include &lt;list&gt; 
 
int main (void) { 
    list&lt;int&gt; list1; 
 
    /* 
    || Put integers 0 to 9 in the list 
    */ 
    for (int i = 0; i &lt; 10; ++i) list1.push_back(i); 
 
    /* 
    || Insert -1 using the insert member function 
    || Our list will contain -1,0,1,2,3,4,5,6,7,8,9 
    */ 
        list1.insert(list1.begin(), -1); 
 
    /* 
    || Insert an element at the end using insert 
    || Our list will contain -1,0,1,2,3,4,5,6,7,8,9,10 
    */ 
        list1.insert(list1.end(), 10); 
 
    /* 
    || Inserting a range from another container 
    || Our list will contain -1,0,1,2,3,4,5,6,7,8,9,10,11,12 
    */ 
    int IntArray[2] = {11,12}; 
    list1.insert(list1.end(), &amp;IntArray[0], &amp;IntArray[2]); 
 
    /* 
    || As an exercise put the code in here to print the lists! 
    || Hint: use PrintIt and accept an interger 
    */ 
} 

注意，insert()函数把一个或若干个元素插入到你指出的iterator的位置。你的元素将出现在 iterator指出的位置以前。 


-------------------------------------------------------------------------------- 

List 构造函数 
我们已经象这样定义了list： 

list&lt;int&gt; Fred; 

你也可以象这样定义一个list，并同时初始化它的元素： 

// define a list of 10 elements and initialise them all to 0 
list&lt;int&gt; Fred(10, 0); 
// list now contains 0,0,0,0,0,0,0,0,0,0 

或者你可以定义一个list并用另一个STL容器的一个范围来初始化它，这个STL容器不一定是一个list， 仅仅需要是元素类型相同的的容器就可以。 

vector&lt;int&gt; Harry; 
Harry.push_back(1); 
Harry.push_back(2); 
# 
// define a list and initialise it with the elements in Harry 
list&lt;int&gt; Bill(Harry.begin(), Harry.end()); 
// Bill now contains 1,2 

-------------------------------------------------------------------------------- 

使用list成员函数从list中删除元素 
list成员函数pop_front()删掉list中的第一个元素，pop_back()删掉最后一个元素。 函数erase()删掉由一个iterator指出的元素。还有另一个erase()函数可以删掉一个范围的元素。 

/* 
|| Erasing objects from a list 
*/ 
#include &lt;list&gt; 
 
int main (void) { 
    list&lt;int&gt; list1; // define a list of integers 
 
    /* 
    || Put some numbers in the list 
    || It now contains 0,1,2,3,4,5,6,7,8,9 
    */ 
    for (int i = 0; i &lt; 10; ++i) list1.push_back(i); 
 
    list1.pop_front(); // erase the first element 0 
 
    list1.pop_back(); // erase the last element 9 
 
    list1.erase(list1.begin()); // erase the first element (1) using an iterator 
 
    list1.erase(list1.begin(), list1.end()); // erase all the remaining elements 
 
    cout &lt;&lt; "list contains " &lt;&lt; list1.size() &lt;&lt; " elements" &lt;&lt; endl; 
} 

输出是： 
list contains 0 elements 

-------------------------------------------------------------------------------- 

用list成员函数remove()从list中删除元素。 
list的成员函数remove()用来从list中删除元素。 

/* 
|| Using the list member function remove to remove elements 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
PrintIt (const string&amp; StringToPrint) { 
    cout &lt;&lt; StringToPrint &lt;&lt; endl; 
} 
 
int main (void) { 
    list&lt;string&gt; Birds; 
 
    Birds.push_back("cockatoo"); 
    Birds.push_back("galah"); 
    Birds.push_back("cockatoo"); 
    Birds.push_back("rosella"); 
    Birds.push_back("corella"); 
 
    cout &lt;&lt; "Original list with cockatoos" &lt;&lt; endl; 
    for_each(Birds.begin(), Birds.end(), PrintIt); 
 
    Birds.remove("cockatoo"); 
 
    cout &lt;&lt; "Now no cockatoos" &lt;&lt; endl; 
    for_each(Birds.begin(), Birds.end(), PrintIt); 
} 

输出是： 

Original list with cockatoos 
cockatoo 
galah 
cockatoo 
rosella 
corella 
Now no cockatoos 
galah 
rosella 
corella 

-------------------------------------------------------------------------------- 

使用STL通用算法remove()从list中删除元素 
通用算法remove()使用和list的成员函数不同的方式工作。一般情况下不改变容器的大小。 

/* 
|| Using the generic remove algorithm to remove list elements 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
PrintIt(string&amp; AString) { cout &lt;&lt; AString &lt;&lt; endl; } 
 
int main (void) { 
    list&lt;string&gt; Birds; 
    list&lt;string&gt;::iterator NewEnd; 
 
    Birds.push_back("cockatoo"); 
    Birds.push_back("galah"); 
    Birds.push_back("cockatoo"); 
    Birds.push_back("rosella"); 
    Birds.push_back("king parrot"); 
 
    cout &lt;&lt; "Original list" &lt;&lt; endl; 
    for_each(Birds.begin(), Birds.end(), PrintIt); 
 
    NewEnd = remove(Birds.begin(), Birds.end(), "cockatoo"); 
 
    cout &lt;&lt; endl &lt;&lt; "List according to new past the end iterator" &lt;&lt; endl; 
    for_each(Birds.begin(), NewEnd, PrintIt); 
 
    cout &lt;&lt; endl &lt;&lt; "Original list now. Care required!" &lt;&lt; endl; 
    for_each(Birds.begin(), Birds.end(), PrintIt); 
} 

输出结果将为：
Original list 
cockatoo 
galah 
cockatoo 
rosella 
king parrot 


List according to new past the end iterator 
galah 
rosella 
king parrot 


Original list now. Care required! 
galah 
rosella 
king parrot 
rosella 
king parrot 

通用remove()算法返回一个指向新的list的结尾的iterator。从开始到这个新的结尾（不含新结尾元素）的范围 包含了remove后剩下所有元素。你可以用list成员函数erase函数来删除从新结尾到老结尾的部分。 


-------------------------------------------------------------------------------- 

使用STL通用算法stable_partition()和list成员函数splice()来划分一个list 
　　我们将完成一个稍微有点复杂的例子。它演示STL通用算法stable_partition()算法和一个list成员函数 splice()的变化。注意函数对象的使用和没有使用循环。 通过简单的语句调用STL算法来控制。 
stable_partition()是一个有趣的函数。它重新排列元素，使得满足指定条件的元素排在 不满足条件的元素前面。它维持着两组元素的顺序关系。 

splice 把另一个list中的元素结合到一个list中。它从源list中删除元素。 

在这个例子中，我们想从命令行接收一些标志和四个文件名。文件名必须’按顺序出现。通过使用stable_partition() 我们可以接收和文件名混为任何位置的标志，并且不打乱文件名的顺序就把它们放到一起。 

由于记数和查找算法都很易用，我们调用这些算法来决定哪个标志被设置而哪个标志未被设置。 我发现容器用来管理少量的象这样的动态数据。 

/* 
|| Using the STL stable_partition algorithm 
|| Takes any number of flags on the command line and 
|| four filenames in order. 
*/ 
#include &lt;string&gt; 
#include &lt;list&gt; 
#include &lt;algorithm&gt; 
 
PrintIt ( string&amp; AString { cout &lt;&lt; AString &lt;&lt; endl; } 
 
class IsAFlag { 
public: 
    bool operator () (string&amp; PossibleFlag) { 
        return PossibleFlag.substr(0,1)=="-"; 
    } 
}; 
 
class IsAFileName { 
public: 
    bool operator () (string&amp; StringToCheck) { 
        return !IsAFlag()(StringToCheck); 
    } 
}; 
 
class IsHelpFlag { 
public: 
    bool operator () (string&amp; PossibleHelpFlag) { 
        return PossibleHelpFlag=="-h"; 
    } 
}; 
 
int main (int argc, char *argv[]) { 
 
    list&lt;string&gt; CmdLineParameters; // the command line parameters 
    list&lt;string&gt;::iterator StartOfFiles; // start of filenames 
    list&lt;string&gt; Flags; // list of flags 
    list&lt;string&gt; FileNames; // list of filenames 
 
    for (int i = 0; i &lt; argc; ++i) CmdLineParameters.push_back(argv[i]); 
 
        CmdLineParameters.pop_front(); // we don't want the program name 
 
    // make sure we have the four mandatory file names 
    int NumberOfFiles(0); 
    count_if(CmdLineParameters.begin(), CmdLineParameters.end(), IsAFileName(), NumberOfFiles); 
 
    cout &lt;&lt; "The " &lt;&lt; (NumberOfFiles == 4 ? "correct " : "wrong ") &lt;&lt; "number (" &lt;&lt; NumberOfFiles &lt;&lt; ") of file names were specified" &lt;&lt; endl; 
 
 // move any flags to the beginning 
    StartOfFiles = stable_partition(CmdLineParameters.begin(), CmdLineParameters.end(), IsAFlag()); 
 
    cout &lt;&lt; "Command line parameters after stable partition" &lt;&lt; endl; 
    for_each(CmdLineParameters.begin(), CmdLineParameters.end(), PrintIt); 
 
    // Splice any flags from the original CmdLineParameters list into Flags list. 
    Flags.splice(Flags.begin(), CmdLineParameters, CmdLineParameters.begin(), StartOfFiles); 
 
    if (!Flags.empty()) { 
        cout &lt;&lt; "Flags specified were:" &lt;&lt; endl; 
        for_each(Flags.begin(), Flags.end(), PrintIt); 
    } 
    else { 
        cout &lt;&lt; "No flags were specified" &lt;&lt; endl; 
    } 
 
    // parameters list now contains only filenames. Splice them into FileNames list. 
    FileNames.splice(FileNames.begin(), CmdLineParameters, CmdLineParameters.begin(), CmdLineParameters.end()); 
 
    if (!FileNames.empty()) { 
        cout &lt;&lt; "Files specified (in order) were:" &lt;&lt; endl; 
        for_each(FileNames.begin(), FileNames.end(), PrintIt); 
    } 
    else { 
        cout &lt;&lt; "No files were specified" &lt;&lt; endl; 
    } 
 
    // check if the help flag was specified 
    if (find_if(Flags.begin(), Flags.end(), IsHelpFlag())!=Flags.end()) { 
        cout &lt;&lt; "The help flag was specified" &lt;&lt; endl; 
    } 
 
    // open the files and do whatever you do 
 
} 

给出这样的命令行： 

test17 -w linux -o is -w great 
输出是： 

The wrong number (3) of file names were specified 
Command line parameters after stable partition 
-w 
-o 
-w 
linux 
is 
great 
Flags specified were: 
-w 
-o 
-w 
Files specified (in order) were: 
linux 
is 
great 


--
相信明天一定会比今天更加美好
每个人都有实现这个信念的责任

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 219.142.135.*]
 【文章标题】：请教达人,php+mysql的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22428 【创建时间】：2007-11-22 【作者】：jingyu 【评论】：2 【内容】：发信人: jingyu (buddhaear), 信区: SoftDesign
标  题: 请教达人,php+mysql的问题
发信站: 北邮人论坛 (Thu Nov 22 21:22:21 2007), 站内

我在做留言版的时候留言栏反馈到我的资料库里的  中文汉字为什么会是乱码呢?英文的字都正常/////并且留言时间在资料库里也体现不出来?

不知道为什么?请达人指教,有可能出现的原因告之,万分感谢
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.217.*]
 

【文章标题】：问一个关于手机软件发短信的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22393 【创建时间】：2007-11-21 【作者】：cwjqss 【评论】：2 【内容】：发信人: cwjqss (cwjqss), 信区: SoftDesign
标  题: 问一个关于手机软件发短信的问题
发信站: 北邮人论坛 (Wed Nov 21 14:36:57 2007), 站内

请问如何在手机里，短信发送16进制的代码？谢谢。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 58.207.137.*]
 
【文章标题】：关于IDEA6.0的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22429 【创建时间】：2007-11-22 【作者】：landeqingyun 【评论】：4 【内容】：发信人: landeqingyun (蓝得晴云), 信区: SoftDesign
标  题: 关于IDEA6.0的问题
发信站: 北邮人论坛 (Thu Nov 22 21:40:43 2007), 站内

请问有哪位大侠使用过IDEA6.0 的开发环境么？ 我以前做JSP用的IDEA6.0 ，现在在装后，运行web程序，居然有错！
错误类型是  Address localhost:8080 is already in use
有哪位大侠能帮忙解释下么？万分感谢！！

--
人生若只如初见！

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.139.*]
 
【文章标题】：[求助]关于抓包的软件 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22440 【创建时间】：2007-11-23 【作者】：cypnjupt 【评论】：0 【内容】：发信人: cypnjupt (cyp), 信区: SoftDesign
标  题: [求助]关于抓包的软件
发信站: 北邮人论坛 (Fri Nov 23 13:15:01 2007), 站内

环境: 
1、系统:Ubuntu 7.04 （linux系统）; 2、硬件: TP-Link L-WN650G 无线网卡 （WiFi 802.11g）; 3、驱动: MadiWiFi （一个开源的Linux版 无线驱动程序）
状态:整个系统工作正常，能连上无线网络

目的:
希望能找到某个程序或者软件，做到以下:
1、能够抓包，提取MAC层的包，抽取里面的净荷；
2、能向MAC包里写自己固定内容的净荷，再组装成MAC包，发送出去。

请问，在LINUX下面有这样的软件吗？

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 172.28.81.*]
 
【文章标题】：问个名词 Admin GUI是什么意思？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22460 【创建时间】：2007-11-24 【作者】：maroon 【评论】：1 【内容】：发信人: maroon (mumu), 信区: SoftDesign
标  题: 问个名词 Admin GUI是什么意思？
发信站: 北邮人论坛 (Sat Nov 24 22:24:00 2007), 站内

就是解释一下吧，我真的没查找到
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.138.*]
 
【文章标题】：求助c里关于输入输出流的问题，请进 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22446 【创建时间】：2007-11-24 【作者】：flyshine 【评论】：2 【内容】：发信人: flyshine (bupt小刀), 信区: SoftDesign
标  题: 求助c里关于输入输出流的问题，请进
发信站: 北邮人论坛 (Sat Nov 24 09:56:34 2007), 站内

#include&lt;cstdlib&gt; 
using namespace std; 
int main() 
{ 
    char a, b; 
    printf("fads"); 
    scanf("%c", &amp;a); 
    printf("fadf"); 
    scanf("%c", &amp;b); 
    printf("%c", b); 
     
    system("pause"); 
    return 0; 
} 
这是随便写的一个程序。 按实现的想法。 先输出一段字符，再输入一个字符到a，接着又输出一段字符，再输入一个字符到b，最后输入b。可是。程序结果会有问题。 
这种问题我以前也经常碰到。 

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.235.*]
 
【文章标题】：弱弱地问个汇编问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22444 【创建时间】：2007-11-23 【作者】：dingli1986 【评论】：2 【内容】：发信人: dingli1986 (seaman), 信区: SoftDesign
标  题: 弱弱地问个汇编问题
发信站: 北邮人论坛 (Fri Nov 23 21:05:48 2007), 站内

请问用dos的2ah号功能调用系统日期的时候，存放在cx里的年的格式是16进制的还是BCD码的？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.192.*]
 
【文章标题】：求助：c中怎么把一个整数的各个位上的数字输入数组中 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22014 【创建时间】：2007-10-30 【作者】：li52675 【评论】：6 【内容】：发信人: li52675 (水稻), 信区: SoftDesign
标  题: 求助：c中怎么把一个整数的各个位上的数字输入数组中
发信站: 北邮人论坛 (Tue Oct 30 19:43:10 2007), 站内

c中，初始化一个数组，要求每个元素是一个整数的各个位数上的数字，怎么处理。新手，请解答，谢谢
--
离家在外,你们还好吗?

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.164.*]
 
【文章标题】：[求助]关于c++ stl配接器的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22150 【创建时间】：2007-11-08 【作者】：gill 【评论】：9 【内容】：发信人: gill (拯救撒哈拉之♂寻找眼泪♂), 信区: SoftDesign
标  题: [求助]关于c++ stl配接器的问题
发信站: 北邮人论坛 (Thu Nov  8 12:33:10 2007), 站内

学习配接器，根据《effective stl》第41条写了一段这样的代码 
环境是vc6.0 
#include &lt;iostream&gt; 
#include &lt;vector&gt; 
#include &lt;string&gt; 
#include &lt;algorithm&gt; 
using namespace std; 
class aaa 
{ 
public: 
  void bbb() 
  { 
       cout&lt;&lt;"something"&lt;&lt;endl;         
  } 
}; 
void main() 
{ 
   vector &lt;aaa*&gt; v; 
   v.push_back(new aaa); 
   for_each(v.begin(),v.end(),mem_fun(&amp;aaa::bbb)); 
} 

错误代码如下： 
e:\microsoft visual studio\vc98\include\functional(233) : error C2562: '()' : 'void' function returning a value 
        e:\microsoft visual studio\vc98\include\functional(232) : see declaration of '()' 
        e:\microsoft visual studio\vc98\include\functional(233) : while compiling class-template member function 'void __thiscall std::mem_fun_t&lt;void,class aaa&gt;::operator ()(class aaa *) const' 
Error executing cl.exe. 
 
搞不懂为什么，请高人指点阿！！ 
 
learn.obj - 1 error(s), 0 warning(s) 

--
拯救撒哈拉
我们的行为是灌水，目的是拯救，只要灌的有水准，撒哈拉也有希望的！


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.155.*]
 
【文章标题】：vc2005单步调试如何设置 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22349 【创建时间】：2007-11-18 【作者】：dongdongya 【评论】：8 【内容】：发信人: dongdongya (qingfeng), 信区: SoftDesign
标  题: vc2005单步调试如何设置
发信站: 北邮人论坛 (Sun Nov 18 21:25:08 2007), 站内

谢谢
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.209.*]
 
【文章标题】：【调查】关于Linux下Socket编程的模型 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22106 【创建时间】：2007-11-02 【作者】：acheronfire 【评论】：7 【内容】：发信人: acheronfire (不是神), 信区: SoftDesign
标  题: 【调查】关于Linux下Socket编程的模型
发信站: 北邮人论坛 (Fri Nov  2 11:25:49 2007), 站内

你们会不会用到 select() 函数 和 (u)sleep()函数？

以下的模型有用到吗   "{}"类或函数域
a.
    while(iscontinue){
        ......
        {
            ......
            /* timeout &gt; 0 */
            select(fd, , , , &amp;tv);
            ......
        }
        ......
    }

b.
    while(iscontinue){
        /* usec &gt; 0 */
        usleep(sleepTime)
        ......
        {
            ......
            /* timeout = 0 */
            select(fd, , , , &amp;tv);
            ......
        }
        ......
    }

哪个对性能影响小一些，哪个更常用到呢？
--


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: unknown]
 
【文章标题】：寻找电院陪木根老师的学生 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22149 【创建时间】：2007-11-07 【作者】：zhangxu31666 【评论】：1 【内容】：发信人: zhangxu31666 (babyface), 信区: SoftDesign
标  题: 寻找电院陪木根老师的学生
发信站: 北邮人论坛 (Wed Nov  7 23:09:45 2007), 站内

如题！
听说陪老师的学生是做Symbian操作系统开发的，有个关于文件读写缓存的问题，想请教一下！谢谢！
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.203.*]
 
【文章标题】：微原的课程设计那个时钟的颜色问题 (转载) 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22260 【创建时间】：2007-11-13 【作者】：shaw1987 【评论】：0 【内容】：发信人: shaw1987 (恶魔小狮子的笨蛋赖皮豚---沙沙), 信区: SoftDesign
标  题: 微原的课程设计那个时钟的颜色问题
发信站: 北邮人论坛 (Tue Nov 13 20:18:19 2007), 站内

【 以下文字转载自 StudyShare 讨论区 】
发信人: shaw1987 (恶魔小狮子的笨蛋赖皮豚---沙沙), 信区: StudyShare
标  题: 微原的课程设计那个时钟的颜色问题
发信站: 北邮人论坛 (Tue Nov 13 18:31:23 2007), 站内

怎么加颜色呀。。帮同学问的
--
 *     .           *    .             *      *       *   
     *    . *         *         .             /\   .     
  .     *        *     .    *            /\  //\\    .   
    *        .           *     .   /\   /^ \/  ⿴ \ *    
        ﹉﹋﹌﹋﹉﹋﹌﹋﹉﹌﹋﹉﹉﹋⿲﹋⿰⿷⿰⿴⿴⿺     


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.194.*]
 
【文章标题】：热烈庆祝20071111111111 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22203 【创建时间】：2007-11-11 【作者】：coolfantasy 【评论】：12 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题: 热烈庆祝20071111111111
发信站: 北邮人论坛 (Sun Nov 11 11:11:11 2007), 站内


 ｚｗｚ() 10:57:53
 估计又被bs了 

 windam|棒棒糖() 10:58:14
 听C说有女生投策划的收到了 

 Cool&gt;&gt;富婆杀手() 10:58:35
 周周也可以近似转换成女生 

 ｚｗｚ() 10:58:42
 。。。。。 

 Cool&gt;&gt;富婆杀手() 10:58:47
 强制转换吧 

 windam|棒棒糖() 10:58:58
 动态转换 

 Cool&gt;&gt;富婆杀手() 10:58:59
 (girl)zwz 

 ｚｗｚ() 10:59:02
 不可逆。。。转了就亏了 

 Cool&gt;&gt;富婆杀手() 10:59:08
 还动态。。。 

 Cool&gt;&gt;富婆杀手() 10:59:09
 nb 

 CNLAS|转行不能() 10:59:13
 (girl *)zwz 

 ｚｗｚ() 10:59:16
 。。。。。。 

 ｚｗｚ() 10:59:23
 伪娘么=。= 

 windam|棒棒糖() 10:59:41
 应该用动态绑定，可以表现出来多态的性质。。。嗯。。。 

 CNLAS|转行不能() 10:59:42
 有个把。。。所以是指针型。。 
 
 nez|无冬11:00:43
 java:
 public class NewZwz extends Zwz implements Girl {} 

 ｚｗｚ() 11:00:50
 。。。。。。 

 windam|棒棒糖11:00:56
 。。。 

 ｚｗｚ() 11:01:15
 没女儿。。 

 nez|无冬11:01:15
 封装一下而已 

 ｚｗｚ() 11:01:18
 唉 
 
 windam|棒棒糖11:02:08
 Girl接口的话，岂不是要把所有的Girl纯虚函数都实现出来。。。
 想想包括哪些。。。 
 
 CNLAS|转行不能11:02:41
 你是要ws型的还是正常型的 实现？ 


--
   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 修改:·coolfantasy 于 Nov 11 11:14:03 修改本文·[FROM: 211.68.71.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 211.68.71.*]
 
【文章标题】：求救php高手? 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22252 【创建时间】：2007-11-13 【作者】：jingyu 【评论】：2 【内容】：发信人: jingyu (buddhaear), 信区: SoftDesign
标  题: 求救php高手?
发信站: 北邮人论坛 (Tue Nov 13 15:59:02 2007), 站内

&lt;?php
  for($a=1;$a&lt;10;$a++)
  {
     do
     {
     $b=1;
     echo "$a*$b="$a*$b,"\t\t\t";
     $b++;
     }
     while($b&lt;10)
  echo '&lt;br&gt;';
  }
//很简单的程序,但弄不明白,不知道为什么,跑的是99乘法表/.谢了/.
?&gt;
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.217.*]
 
【文章标题】：一个类如何调用另一个类的对象（关联了某个控件）？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22265 【创建时间】：2007-11-14 【作者】：kangxi 【评论】：0 【内容】：发信人: kangxi (北邮首席无才无貌不缺德单身GG), 信区: SoftDesign
标  题: 一个类如何调用另一个类的对象（关联了某个控件）？
发信站: 北邮人论坛 (Wed Nov 14 11:54:31 2007), 站内

急问！
我用MSFlexGrid控件关联了一个CMSFlexGrid类的对象m_nMSFlexGrid。我在另一个类（View类）中使用m_nMSFlexGrid时，却遇到错误提示：error C2065: 'm_nMSFlexGrid' : undeclared identifier 高人出来解救一下啊 
我在View中类中包含了CMSFlexGrid这个类的头文件了，但还是出错 

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 65.110.147.*]
 
【文章标题】：求助！！我的Pspice8.0软件安装不上是怎么回事？？？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22263 【创建时间】：2007-11-14 【作者】：wyingmn 【评论】：1 【内容】：发信人: wyingmn (wander), 信区: SoftDesign
标  题: 求助！！我的Pspice8.0软件安装不上是怎么回事？？？
发信站: 北邮人论坛 (Wed Nov 14 08:32:55 2007), 站内

望各位指点啊！！！
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.226.*]
 
【文章标题】：[求助]关于数据段，代码段，堆栈段的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22214 【创建时间】：2007-11-11 【作者】：iam456 【评论】：13 【内容】：发信人: iam456 (iamicer), 信区: SoftDesign
标  题: [求助]关于数据段，代码段，堆栈段的问题
发信站: 北邮人论坛 (Sun Nov 11 16:47:54 2007), 站内

是每个应用程序都有各自的数据段，代码段，堆栈段
还是所有的应用程序都共用一个大的数据段，代码段，堆栈段？
另外怎么能通过地址看出是属于哪个段的啊？
请教一下
--


※ 修改:·iam456 于 Nov 11 17:13:00 修改本文·[FROM: 58.30.54.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 58.30.54.*]
 
【文章标题】：谁那有C++标准程序库简体中文版的电子书，我想大概浏览下,3Q 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22058 【创建时间】：2007-10-31 【作者】：jacky888 【评论】：7 【内容】：发信人: jacky888 (地球村村长派驻北邮首席代表), 信区: SoftDesign
标  题: 谁那有C++标准程序库简体中文版的电子书，我想大概浏览下,3Q
发信站: 北邮人论坛 (Wed Oct 31 15:42:25 2007), 站内

RT
--
╭⌒╭⌒╮╭⌒╮～╭⌒╮︶︶,　︶︶ 
,︶︶︶︶,''︶~~ ,''~︶︶　 ,'' 
╬　╱◥███◣╬╬╬╬╬╬╬╬╬╬╬ 
╬ ︱田︱田 田 ︱                  ╬                  
╬　　　　　　欢迎光临偶滴小屋^0^   ╬
╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.239.*]
 
【文章标题】：[求助]Linux里面有查看MAC层包内容的软件吗？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22241 【创建时间】：2007-11-12 【作者】：cypnjupt 【评论】：1 【内容】：发信人: cypnjupt (cyp), 信区: SoftDesign
标  题: [求助]Linux里面有查看MAC层包内容的软件吗？
发信站: 北邮人论坛 (Mon Nov 12 21:53:02 2007), 站内

系统: Linux---ubuntu 7.04 
硬件:TP-Link 550G 的无线网卡 
驱动:MadWiFi 
状态: 无线网卡正常工作 
 
想直接通过某个软件，写MAC包的净荷,之后发出去。或者，通过软件抓包，提取MAC包的净荷 
 
请问有这样的软件吗？ 

--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.228.*]
 
【文章标题】：最近发现javascript也没有想象中那么烂 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22290 【创建时间】：2007-11-15 【作者】：Quake 【评论】：6 【内容】：发信人: Quake (Quake|暴君), 信区: SoftDesign
标  题: 最近发现javascript也没有想象中那么烂
发信站: 北邮人论坛 (Thu Nov 15 17:23:37 2007), 站内

函数就是对象这点还是挺赞的
善于利用这点可以写出挺优雅的程序出来

如回调函数
[quote]function Foo() {
    this.func = null;
    this.bar = function() {
        if (this.func != null) this.func();
    };
}

function Bar() {
    // do something
}

var foo = new Foo();
foo.func = Bar;
foo.bar();
[/quote]

又如自定义forEach
[quote]function forEach(list, func) {
    // 枚举list中的的每一个元素
    var elem = 其中一个元素
    func(elem);
}

function printElem(elem) {
    // do something
}

forEach(list, pringElem);
[/quote]

虽然C/C++也能用类似的方法，不过javascript能做到这点还是值得赞的
--

GL Everyday
GL Everyday
BL Go Away
BL Go Away


※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 124.205.6.*]
 
【文章标题】：VS2005下安装QT 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22289 【创建时间】：2007-11-15 【作者】：lanjianjj 【评论】：1 【内容】：发信人: lanjianjj (菠菜), 信区: SoftDesign
标  题: VS2005下安装QT
发信站: 北邮人论坛 (Thu Nov 15 17:16:35 2007), 站内

我用VS2005PRO
安装了PSDK
安装FTP下的那个QT4.2.0-for-win商业版
在nmake的时候总是出错，说kernel\qeventpatch_win.cpp有一堆错误
但是在VC6下面可以编译通过
请高手帮忙看看
多谢了

--
那晚，我在你背上，任长发肆意飘下，轻轻地吻着你的脸，双手紧紧环住你的颈，
贪婪地吮吸着你的味道，听你急促的呼吸，我真希望永远就这样醉着不要醒来，
就这样，任性而霸道地独占着你所有的宠爱......


※ 修改:·lanjianjj 于 Nov 15 17:19:00 修改本文·[FROM: 59.64.132.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.132.*]
 
【文章标题】：请教vs2005如何添加头文件和库文件 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22000 【创建时间】：2007-10-29 【作者】：wangyiqing 【评论】：0 【内容】：发信人: wangyiqing (王逸清), 信区: SoftDesign
标  题: 请教vs2005如何添加头文件和库文件
发信站: 北邮人论坛 (Mon Oct 29 20:42:40 2007), 站内

在vs2005中要把某个软件的源文件编译成库
这个软件依赖与expat和openssl，编译这个软件的时候报错找不到expat.h和openssl下的某个头文件，请问这种情况应该怎样添加头文件和库文件啊？
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.201.*]
 
【文章标题】：F#成为Visual Studio的上等公民 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21903 【创建时间】：2007-10-24 【作者】：tw 【评论】：4 【内容】：发信人: tw (戾太子), 信区: SoftDesign
标  题: F#成为Visual Studio的上等公民
发信站: 北邮人论坛 (Wed Oct 24 13:10:30 2007), 站内

微软为Visual Studio开发平台添加了最新的稳定版语言F#,成为VS的主要编程语言之一.
F#语言基于功能性编程语言概念.功能性编程语言将计算看做是数学函数的赋值,对于需要使用大量数学符号的某些领域专业人员来说,F#语言的数学特性颇具吸引力.Somasegar表示,F#的目标是成为.Net上的“上等公民”

另外微软研究院也曾对F#语言做出过解释,F#语言集安全、性能、脚本与Modern Runtime系统(Java虚拟机和微软通用Runtime)等多种优势于一体,并支持Python等交互式脚本语言、强类型推理、ML的安全性.另 外,F#语言可以访问access.net库以及其他数据库工具软件.


--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.215.*]
 
【文章标题】：[zz] 可能是史上最长的正则表达式 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22118 【创建时间】：2007-11-04 【作者】：coolfantasy 【评论】：20 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题: [zz] 可能是史上最长的正则表达式
发信站: 北邮人论坛 (Sun Nov  4 13:48:01 2007), 站内

发信人: Dieken (风催草低 - 明月何尝不照人), 信区: Perl
标  题: 可能是史上最长的正则表达式
发信站: 水木社区 (Sun Nov  4 02:56:13 2007), 转信

http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html?

 Mail::RFC822::Address: regexp-based address validation

Mail::RFC822::Address is a Perl module to validate email addresses according to the RFC 822 grammar. It provides the same functionality as RFC::RFC822::Address, but uses Perl regular expressions rather that the Parse::RecDescent parser. This means that the module is much faster to load as it does not need to compile the grammar on startup.

Download Mail::RFC822::Address-0.4.tar.gz or read the documentation.

The grammar described in RFC 822 is suprisingly complex. Implementing validation with regular expressions somewhat pushes the limits of what it is sensible to do with regular expressions, although Perl copes well:

(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)
?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;
@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"
(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;
:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\"
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,
;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?
:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\
]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)
?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["
()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;
@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,
;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".
\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
"()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(
?:\r\n)?[ \t])*))*)?;\s*)
                

This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module). 

--
For people new to the list, the message is:                                      
    <a target="_blank" href="http://thread.gmane.org/gmane.comp.version-control.git/27/focus=217">http://thread.gmane.org/gmane.comp.version-control.git/27/focus=217</a>                                                 
I consider it is _the_ most important message in the whole list                 archive.  If you haven't read it, read it now, print it out,                    read it three more times, place it under the pillow before you
sleep tonight.  Repeat that until you can recite the whole                      message.  It should not take more than a week.
  Re: [ANNOUNCE] Example Cogito Addon - cogito-bundle   Junio C Hamano
http://thread.gmane.org/gmane.comp.version-control.bazaar-ng.general/18006/focus=18494


※ 来源:·水木社区 newsmth.net·[FROM: 61.49.141.*]


--
   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 211.68.71.*]
 
【文章标题】：vol视频点播站开发小组招新启事 (转载) 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22001 【创建时间】：2007-10-29 【作者】：coolfantasy 【评论】：0 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题: vol视频点播站开发小组招新启事
发信站: 北邮人论坛 (Mon Oct 29 20:43:11 2007), 站内

【 以下文字转载自 sysop 讨论区 】
发信人: coolfantasy (Cool), 信区: sysop
标  题: vol视频点播站开发小组招新启事
发信站: 北邮人论坛 (Mon Oct 29 13:52:24 2007), 站内

vol视频点播站(<a target="_blank" href="http://vol.bupt.edu.cn">http://vol.bupt.edu.cn</a>)非正式开放以来，访问量稳步上升，并且拥有高达85%的用户回头率
为了能够把vol打造成一个综合性视频点播网站，给更广范围的用户提供更多的内容和更丰富的功能，现面向全校招聘开发人员
 

开发工作主要涉及以下几个方面：
1）Linux平台下的Web开发
主要应用LAMP(Linux/Apache/MySQL/PHP/Perl)技术构建能应对大流量点播需求的分布式Web站点
2）用户行为的数据挖掘
维护和改进现有的影片推荐关联规则算法；为网站的改进提供数据分析支持
3）Linux平台下的后台程序开发
使用C/C++/Shell/PHP/Perl等语言开发后台程序，自动化完成影片添加、资料更新、服务运行状况监控等任务
4）流媒体播放脚本开发
使用SMIL等技术，优化点播流程，提供更加多样化的播放功能


加入开发小组您能学习到：
1）Linux操作和系统管理
2）LAMP Web开发技能
3）Linux环境下的C/C++开发
4）数据挖掘算法与实际应用
5）SVN/CVS版本控制开发流程
6）流媒体语言


加入的要求是……满足以下任意两项以上即可：
1）喜爱软件开发技术，有一定的课余自由时间
2）了解Linux环境基本操作，熟悉PHP+MySQL网站开发，了解Smarty更佳
3）对算法有所研究，数据挖掘方向更佳，有关联规则应用经验的更佳
4）有Linux C/C++开发经验
5）有流媒体语言开发经验
6）有其他平台的其他语言的Web开发经验，比如Java/dotNet，并有学习LAMP技术的兴趣

 
如果您对这个项目感兴趣，并且能符合要求，请立即发送个人介绍或简历到volbupt (at) gmail (dot) com，我们会及时回应~

 

 

--
   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 修改:·coolfantasy 于 Oct 29 13:52:53 修改本文·[FROM: 211.99.222.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 211.68.71.*]
 
【文章标题】：请教外连接的SQL语句 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21965 【创建时间】：2007-10-28 【作者】：sanyao 【评论】：12 【内容】：发信人: sanyao (五凤居士☆钱塘人家), 信区: SoftDesign
标  题: 请教外连接的SQL语句
发信站: 北邮人论坛 (Sun Oct 28 21:59:25 2007), 站内

我遇到的情况是这样的：
表sometable有如下字段
id
name      
value1
value2
flag
 
 
我希望希望做的外连接如下：select t1.name, sum(t1.value1), t2.value from sometable t1, sometable t2 where t1.name=t2.name(+) and t2.flag='Y' group by t1.name,t2.value
其含义是将库中的value1按name求和，外连接上flag='Y'的value2
 
但在我的环境下，外连接不能这样写，我的通过Spring 的HibernateTemplate的find()方法来执行的，Hibernate版本3.0，数据库oracle9i
 
求教达人如何才能把SQL语句改成可以在我的环境下执行 
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.196.*]
 
【文章标题】：求助! 关于Visual C++ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22003 【创建时间】：2007-10-29 【作者】：tonicpku 【评论】：0 【内容】：发信人: tonicpku (6), 信区: SoftDesign
标  题: 求助! 关于Visual C++
发信站: 北邮人论坛 (Mon Oct 29 21:16:48 2007), 站内

求助Visual C++的建立写法
我写完了以后无法编译
这是为什么啊?

--
好好学习
C++  Java 
有时间还是要玩玩法师的
WOW啊```还是顾C++吧!

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.175.*]
 
【文章标题】：谁能给推荐一个ie下的javascript调试工具，谢谢 【文章地址】：https://bbs.byr.cn/article/SoftDesign/22266 【创建时间】：2007-11-14 【作者】：lhybeyond 【评论】：13 【内容】：发信人: lhybeyond (如果没有可以不填), 信区: SoftDesign
标  题: 谁能给推荐一个ie下的javascript调试工具，谢谢
发信站: 北邮人论坛 (Wed Nov 14 14:15:45 2007), 站内

rt
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 211.91.255.*]
 
【文章标题】：谁有关于基于winsocket2.0的tcp/ip协议通信的参考代码？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21739 【创建时间】：2007-10-14 【作者】：heartremain 【评论】：1 【内容】：发信人: heartremain (五year邮人), 信区: SoftDesign
标  题: 谁有关于基于winsocket2.0的tcp/ip协议通信的参考代码？
发信站: 北邮人论坛 (Sun Oct 14 15:47:48 2007), 站内

谁有关于基于winsocket2.0的tcp通信的参考代码？
c或者c++的？
最好是分两个，server和cilent，可以相互通信的。
最好是有多线程的。
共享一下哈，谢谢。
--
爱情就像发帖子一样，期待别人的回复 。即便是灌水，也执着的刷新。 
很多人回复的，未必是好帖，没人回复的，却有可能是精品。然而，那么多的回帖中，也未必有人真的懂你 。

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.141.*]
 
【文章标题】：求教VC项目结构设置 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21790 【创建时间】：2007-10-16 【作者】：vivin 【评论】：1 【内容】：发信人: vivin (阿诺), 信区: SoftDesign
标  题: 求教VC项目结构设置
发信站: 北邮人论坛 (Tue Oct 16 23:10:55 2007), 站内

看到很多VC项目的结构都是src,lib,conf,include这样的，但是自己按照向导添加的文件一般都是平行的.cpp文件和.h文件是放在一起的，请有经验的达人说说自己是怎么搞的，可以比较方便的就设置好。
谢谢。
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.229.*]
 
【文章标题】：[求助]买二手C++ Primer 第三版中文版 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21791 【创建时间】：2007-10-17 【作者】：woyaokaoyan 【评论】：0 【内容】：发信人: woyaokaoyan (enjoy damn life), 信区: SoftDesign
标  题: [求助]买二手C++ Primer 第三版中文版
发信站: 北邮人论坛 (Wed Oct 17 00:57:41 2007), 站内

价格厚道即可！！！
--
君子性非异也，善假于物也

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 125.33.160.*]
 
【文章标题】：[求助]C++ Primer哪版最好啊？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21752 【创建时间】：2007-10-15 【作者】：Coldplay 【评论】：3 【内容】：发信人: Coldplay (Coldplay), 信区: SoftDesign
标  题: [求助]C++ Primer哪版最好啊？
发信站: 北邮人论坛 (Mon Oct 15 09:38:17 2007), 站内

rt
--
无论贫穷还是富有，健康还是疾病，相爱相依，不离不弃，直到死亡把我们分开


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.186.*]
 
【文章标题】：新手请教接口问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21811 【创建时间】：2007-10-17 【作者】：fairystory 【评论】：0 【内容】：发信人: fairystory (贫颦), 信区: SoftDesign
标  题: 新手请教接口问题
发信站: 北邮人论坛 (Wed Oct 17 15:37:12 2007), 站内

各位达人：
我正为硕士研究方向烦忧，不知做软件接口需要知道哪些基础知识？
达人们给介绍介绍，我好提前准备准备啊，本人对计算机网络、通信等知识都没什么基础的，请达人帮忙啊！
--
Bless all!

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.236.*]
 
【文章标题】：【求助】数据库基本操作 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21808 【创建时间】：2007-10-17 【作者】：heysusan 【评论】：1 【内容】：发信人: heysusan (sue), 信区: SoftDesign
标  题: 【求助】数据库基本操作
发信站: 北邮人论坛 (Wed Oct 17 13:56:08 2007), 站内

求助一下哦

谁有数据库基本操作的电子版资源。基本理论的和sql语句语法的都可以哦^_^

老师的讲义也行~~

十分感谢 (*^__^*)
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.130.39.*]
 
【文章标题】：*和[ ] 的一字之差，程序就“段错误”，牛人给看看！ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21668 【创建时间】：2007-10-11 【作者】：roc212 【评论】：10 【内容】：发信人: roc212 (基督山伯伯), 信区: SoftDesign
标  题: *和[ ] 的一字之差，程序就“段错误”，牛人给看看！
发信站: 北邮人论坛 (Thu Oct 11 14:15:25 2007), 站内

环境：linux，纯c编程
功能：将字符串转换为全部小写的程序。
1·写成 a[] 就正确，返回结果为abcdef
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
char <b>a[]</b> ="abcDEF";
int i,n;
n=strlen(a);
for(i=0;i&lt;=n;i++){
        a[i]=tolower(a[i]);
}
printf("a=%s\n",a);
}

2·写成 *a 就说段错误！ 郁闷了。。。为什么呢？？
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
char <b>*a</b> ="abcDEF";
int i,n;
n=strlen(a);
for(i=0;i&lt;=n;i++){
        a[i]=tolower(a[i]);
}
printf("a=%s\n",a);
}

牛人给解释下:)
--
《北邮研究生》报社征稿活动正在进行中<a target="_blank" href="http://forum.byr.edu.cn/wForum/disparticle.php?boardName=BUPTyb&amp;ID=26&amp;pos=1">http://forum.byr.edu.cn/wForum/disparticle.php?boardName=BUPTyb&amp;ID=26&amp;pos=1</a>
     ====记录北邮研究生自己的故事====
《北邮研究生》--北邮研究生的平台 展现北邮研究生的风采

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 210.25.132.*]
 
【文章标题】：找人一起研究怎么做U盘。。。。。。。 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21824 【创建时间】：2007-10-17 【作者】：staywithyou 【评论】：2 【内容】：发信人: staywithyou (无名氏), 信区: SoftDesign
标  题: 找人一起研究怎么做U盘。。。。。。。
发信站: 北邮人论坛 (Wed Oct 17 16:45:25 2007), 站内

包括PCB，选型，固件开发等
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 221.221.149.*]
 
【文章标题】：小小的编程问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21815 【创建时间】：2007-10-17 【作者】：leominchow 【评论】：6 【内容】：发信人: leominchow (JR_S), 信区: SoftDesign
标  题: 小小的编程问题
发信站: 北邮人论坛 (Wed Oct 17 16:09:23 2007), 站内

代码如下
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct node{
     char word[20]; 
     int counts;  
     struct node *next;
}node,*list;

int InitList(list L)
{
    L=(list)malloc(sizeof(node));
     if(!L) return 0;
    strcpy(L-&gt;word,"test");
    L-&gt;counts=20;
    L-&gt;next=NULL;
     return 1;    
}

int  main()
{
    list L=NULL;
    InitList(L);
    printf("d%",L-&gt;counts);
    return 0;
}
编译通过，执行出错
调试时发现了access violation的错误，GOOGLE后知道可能是内存分配或指针问题，希望高手告之，小弟程序菜鸟，轻度BT
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.132.*]
 
【文章标题】：[合集] 如何写一个判断一个数是否是2的幂次方的宏啊？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21525 【创建时间】：2007-10-03 【作者】：CNLAS 【评论】：0 【内容】：发信人: CNLAS (Ich gewinne bestimmt……), 信区: SoftDesign
标  题: [合集] 如何写一个判断一个数是否是2的幂次方的宏啊？
发信站: 北邮人论坛 (Wed Oct  3 18:24:48 2007), 站内

☆─────────────────────────────────────☆
   tenor (最后的战役) 于  (Sat Sep 22 23:48:40 2007)  提到:


去计算所面试被鄙视了。


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Sat Sep 22 23:59:52 2007)  提到:

同被BS。不会


☆─────────────────────────────────────☆
   daodao (刀刀) 于  (Sun Sep 23 00:07:40 2007)  提到:

余数。。



☆─────────────────────────────────────☆
   coolfantasy (Cool) 于  (Sun Sep 23 00:11:59 2007)  提到:

(n - 1) &amp; n

结果为0的是2的mi



☆─────────────────────────────────────☆
   johnavon (Emacs) 于  (Sun Sep 23 00:12:29 2007)  提到:

很经典的哦
【 在 coolfantasy 的大作中提到: 】
: (n - 1) &amp; n 
: 结果为0的是2的mi 



☆─────────────────────────────────────☆
   tenor (最后的战役) 于  (Sun Sep 23 00:15:16 2007)  提到:


【 在 johnavon 的大作中提到: 】
: 很经典的哦 

这是面试常问的题吧？
唉


☆─────────────────────────────────────☆
   johnavon (Emacs) 于  (Sun Sep 23 00:21:20 2007)  提到:

这个不知道
我们班一个搞ACM的经常给我们“炫耀”类似的东西。。。
【 在 tenor 的大作中提到: 】
: 这是面试常问的题吧？ 
: 唉 



☆─────────────────────────────────────☆
   wks (cloverprince) 于  (Sun Sep 23 00:28:23 2007)  提到:

接着问一下,在知道这个数是2的若干次方的情况下,能不能用宏判断是几次方呢?


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 01:02:13 2007)  提到:

10大留名


☆─────────────────────────────────────☆
   nusher (相逢恨早) 于  (Sun Sep 23 01:06:59 2007)  提到:

技术帖


☆─────────────────────────────────────☆
   IchijyouSan (一条さん|一条大神) 于  (Sun Sep 23 01:07:01 2007)  提到:

听说是十大......


☆─────────────────────────────────────☆
   mmgroup (からす) 于  (Sun Sep 23 01:20:26 2007)  提到:


【 在 coolfantasy 的大作中提到: 】
: (n - 1) &amp; n 
: 结果为0的是2的mi 

顶正解....
判断是否一个1加一堆0……就这样……



☆─────────────────────────────────────☆
   wgynze (cheetah) 于  (Sun Sep 23 01:20:27 2007)  提到:

太技术贴了


☆─────────────────────────────────────☆
   bj2k08 (戒网) 于  (Sun Sep 23 01:23:43 2007)  提到:

哇


☆─────────────────────────────────────☆
   Exciting (Sa) 于  (Sun Sep 23 01:28:10 2007)  提到:

顶！！！
北邮人要多发技术贴！



☆─────────────────────────────────────☆
   thisfeeling (胖胖的尼采) 于  (Sun Sep 23 01:37:17 2007)  提到:

哈哈


☆─────────────────────────────────────☆
   coolfantasy (Cool) 于  (Sun Sep 23 01:46:01 2007)  提到:

#define f(x, y) while ((x = (x &gt;&gt; 1)) != 0) y++;

不要B4我。。。

【 在 wks (cloverprince) 的大作中提到: 】
: 接着问一下,在知道这个数是2的若干次方的情况下,能不能用宏判断是几次方呢? 




☆─────────────────────────────────────☆
   lg200303 (slight) 于  (Sun Sep 23 01:47:40 2007)  提到:

re


☆─────────────────────────────────────☆
   abao (此时 我未成名卿未嫁) 于  (Sun Sep 23 01:51:35 2007)  提到:

受教了


☆─────────────────────────────────────☆
   airbyr (Arcueid.Brunestud) 于  (Sun Sep 23 01:53:52 2007)  提到:

技术难得十大


☆─────────────────────────────────────☆
   angriest (超级无敌小豆芽) 于  (Sun Sep 23 02:07:05 2007)  提到:


【 在 mmgroup 的大作中提到: 】
: 顶正解.... 
: 判断是否一个1加一堆0……就这样…… 
还是不太明白。。


☆─────────────────────────────────────☆
   baoda (baoda) 于  (Sun Sep 23 02:22:01 2007)  提到:

不知道


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 03:04:14 2007)  提到:


【 在 angriest 的大作中提到: 】
: 还是不太明白。。 

2进制位与


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 03:11:32 2007)  提到:


【 在 wks 的大作中提到: 】
: 接着问一下,在知道这个数是2的若干次方的情况下,能不能用宏判断是几次方呢? 


可以验证是否是2的几次方，但是计算出是几次方似乎不好实现。。。。。。


☆─────────────────────────────────────☆
   taotie1984 (北邮人) 于  (Sun Sep 23 03:24:14 2007)  提到:

转换成2进制，判断有几个零就可以知道是几次方了


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 04:10:05 2007)  提到:


【 在 taotie1984 的大作中提到: 】
: 转换成2进制，判断有几个零就可以知道是几次方了 

数据类型是int还是uint还是double？2进制位数不是和数据类型相关么。而且用宏怎么判断有几个0？

给段代码吧。。。。


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Sun Sep 23 08:31:43 2007)  提到:

技术贴啊


☆─────────────────────────────────────☆
   seaver (benny) 于  (Sun Sep 23 08:44:10 2007)  提到:

对 
【 在 zwz 的大作中提到: 】
: 数据类型是int还是uint还是double？2进制位数不是和数据类型相关么。而且用宏怎么判断有几个0？ 
: 给段代码吧。。。。 



☆─────────────────────────────────────☆
   mikebibby (万安人) 于  (Sun Sep 23 08:56:13 2007)  提到:


【 在 coolfantasy 的大作中提到: 】
: (n - 1) &amp; n 
: 结果为0的是2的mi 


相当的不错，呵呵


☆─────────────────────────────────────☆
   feiyangdn (feiyangdn) 于  (Sun Sep 23 09:37:53 2007)  提到:

用汇编实现很简单,主要用到的指令BT,BTR
BT---测试重最右端开始的某位非零
BTR--对某位清零
int xc;//被测试数
int yc;//结果为-1表示非2的幂次方,其他值为相应次方
_asm{  
        mov eax,xc;  
        bt ebx,eax;  /*测试*/
        mov yc,ebx;
        btr eax,ebx;  /*清零*/
        cmp eax,0;   /*判断清掉了xc中可能存在的最低bit的1之后的数是否为0*/
        jnz xxx;   
        mov yc,-1; 
xxx: nop;
    } 

写汇编比较枯燥, 而且容易出错,如果速度没有要求建议不.


☆─────────────────────────────────────☆
   evengine (北邮人) 于  (Sun Sep 23 09:41:45 2007)  提到:

顶关于技术的帖子


☆─────────────────────────────────────☆
   windam (windam) 于  (Sun Sep 23 10:13:29 2007)  提到:

cool的思路果然很快啊。。。
看到问题就有答案了。。。= =



☆─────────────────────────────────────☆
   atian25 (蓝虫|阿天) 于  (Sun Sep 23 10:13:43 2007)  提到:

话说来我这面试的..没几个会回答3388的24点问题.. 真无语...


☆─────────────────────────────────────☆
   skyapple (skyapple) 于  (Sun Sep 23 10:20:21 2007)  提到:

2的密次方 即 2的0,1,2,3....次方，即1,2,4,8....
用二进制表示就是
1
10
100
1000
10000
.....
依次右移判断是否为零不就行了...



☆─────────────────────────────────────☆
   alloon (07新人已经登场|八卦帮之地水师) 于  (Sun Sep 23 10:37:32 2007)  提到:

以后我就去投奔你了。。。
【 在 atian25 的大作中提到: 】
: 话说来我这面试的..没几个会回答3388的24点问题.. 真无语... 



☆─────────────────────────────────────☆
   daHe (嗜血的罗密欧) 于  (Sun Sep 23 10:54:36 2007)  提到:


【 在 skyapple 的大作中提到: 】
: 2的密次方 即 2的0,1,2,3....次方，即1,2,4,8.... 
: 用二进制表示就是 
: 1 
: ................... 


这样简单的描述很多人都会，关键是写出代码就难了


☆─────────────────────────────────────☆
   Barbarosa (巴巴罗沙是海盗) 于  (Sun Sep 23 11:00:17 2007)  提到:

位运算很强大，技术贴得顶


☆─────────────────────────────────────☆
   daHe (嗜血的罗密欧) 于  (Sun Sep 23 11:03:18 2007)  提到:


【 在 wks 的大作中提到: 】
: 接着问一下,在知道这个数是2的若干次方的情况下,能不能用宏判断是几次方呢? 

如果该数是int型，至少有下面这种方法；long型也可以如法炮制的写下去，无非就是再长一些。如果是float或double型，就先强制转换成int或者long。
#define f(n)    (n==0)+\
                     (n==2)*1+\
                     (n==4)*2+\
                     (n==8)*3+\
                     (n==16)*4+\
                     (n==32)*5+\
                     (n==64)*6+\
                     (n==128)*7


☆─────────────────────────────────────☆
   flyinghawk (鹰击长空) 于  (Sun Sep 23 11:07:31 2007)  提到:


【 在 feiyangdn 的大作中提到: 】
用汇编实现很简单,主要用到的指令BT,BTR
BT---测试重最右端开始的某位非零
BTR--对某位清零
int xc;//被测试数
int yc;//结果为-1表示非2的幂次方,其他值为相应次方
_asm{  
        mov eax,xc;  
        bt ebx,eax;  /*测试*/
        mov yc,ebx;
        btr eax,ebx;  /*清零*/
        cmp eax,0;   /*判断清掉了xc中可能存在的最低bit的1之后的数是否为0*/
        jnz xxx;    
        mov yc,-1;  
xxx: nop;
    }

厉害啊



☆─────────────────────────────────────☆
   zhizi (一一) 于  (Sun Sep 23 11:22:21 2007)  提到:

我就是顶一下~


☆─────────────────────────────────────☆
   vivin (阿诺) 于  (Sun Sep 23 11:48:20 2007)  提到:

受教了.
【 在 coolfantasy 的大作中提到: 】
: (n - 1) &amp; n 
: 结果为0的是2的mi 



☆─────────────────────────────────────☆
   fullhappy (游泳的鱼) 于  (Sun Sep 23 11:57:38 2007)  提到:



受教了


☆─────────────────────────────────────☆
   freewings (新的旅程) 于  (Sun Sep 23 12:31:03 2007)  提到:

用二进制思考比较直接，一个1跟一堆0 就容易理解了


☆─────────────────────────────────────☆
   phoenix1104 (Ashlee Simpson) 于  (Sun Sep 23 12:39:37 2007)  提到:

嗯
【 在 johnavon 的大作中提到: 】
: 这个不知道 
: 我们班一个搞ACM的经常给我们“炫耀”类似的东西。。。 



☆─────────────────────────────────────☆
   Kadon (SeekIng) 于  (Sun Sep 23 12:41:05 2007)  提到:

俺水平太低 看不懂


☆─────────────────────────────────────☆
   wks (cloverprince) 于  (Sun Sep 23 13:35:07 2007)  提到:

没有bs的意思.
这几天编程碰巧遇到了这个问题需要解决.
谢谢啦.

【 在 coolfantasy 的大作中提到: 】
: #define f(x, y) while ((x = (x &gt;&gt; 1)) != 0) y++; 
: 不要B4我。。。 



☆─────────────────────────────────────☆
   lili (lili) 于  (Sun Sep 23 13:49:02 2007)  提到:

ding


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 15:20:56 2007)  提到:


【 在 daHe 的大作中提到: 】
: 这样简单的描述很多人都会，关键是写出代码就难了 

&gt;&gt;和 &amp;0x01,这个不难，问题是在不知道数据类型的情况下用一个宏同时判断多个位，这个比较难


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 15:26:31 2007)  提到:


【 在 atian25 的大作中提到: 】
: 话说来我这面试的..没几个会回答3388的24点问题.. 真无语... 


这个我会。。。。恩


☆─────────────────────────────────────☆
   kai (雅典娜的凯子) 于  (Sun Sep 23 16:07:56 2007)  提到:

技术贴上十大了，一定要顶


☆─────────────────────────────────────☆
   xiaojia164 (【顶你小分队】│虢虓湛卢) 于  (Sun Sep 23 16:10:07 2007)  提到:

原来位运算如此强大。


☆─────────────────────────────────────☆
   maroon (mumu) 于  (Sun Sep 23 18:44:35 2007)  提到:


【 在 coolfantasy 的大作中提到: 】
: (n - 1) &amp; n 
: 结果为0的是2的mi 
受教了，
不过这个队所有类型的数都成立么？


☆─────────────────────────────────────☆
   keen (keen) 于  (Sun Sep 23 19:48:05 2007)  提到:

gongtongxuexi


☆─────────────────────────────────────☆
   jhx0129 (jhx) 于  (Sun Sep 23 20:28:10 2007)  提到:

不看都知道你牛
【 在 feiyangdn 的大作中提到: 】
: 用汇编实现很简单,主要用到的指令BT,BTR 
: BT---测试重最右端开始的某位非零 
: BTR--对某位清零 
: ................... 



☆─────────────────────────────────────☆
   AgCl (0o游水部o0【一等公爵】|SANJI) 于  (Sun Sep 23 20:28:12 2007)  提到:

看到最后"的宏"两个字就不知道在说什么了


☆─────────────────────────────────────☆
   SunFlowers () 于  (Sun Sep 23 21:03:21 2007)  提到:

问一下  宏写成这样

我   printf("%d\n", f(x,y)) 能运行吗？

【 在 coolfantasy 的大作中提到: 】
: #define f(x, y) while ((x = (x &gt;&gt; 1)) != 0) y++; 
: 不要B4我。。。 



☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Sun Sep 23 22:10:45 2007)  提到:


【 在 SunFlowers 的大作中提到: 】
: 问一下  宏写成这样 
: 我   printf("%d\n", f(x,y)) 能运行吗？ 

这样语法不通啊


☆─────────────────────────────────────☆
   IchijyouSan (一条さん|一条大神) 于  (Sun Sep 23 22:15:30 2007)  提到:


【 在 SunFlowers 的大作中提到: 】
: 问一下  宏写成这样 
: 我   printf("%d\n", f(x,y)) 能运行吗？ 
所以要换个宏啊
比如说
f(x) (log(x)/log(2))

嗯


☆─────────────────────────────────────☆
   yanhui (ScST^05409-&gt;(伊斯蘭)) 于  (Sun Sep 23 22:25:00 2007)  提到:

十大。。





☆─────────────────────────────────────☆
   czyoyo (yoyo～★｀喜欢小猫咪) 于  (Sun Sep 23 22:44:17 2007)  提到:

为什么一点都看不懂．．哭


☆─────────────────────────────────────☆
   Bergwolf (计忆邮心|Kinight) 于  (Sun Sep 23 23:56:46 2007)  提到:

        这种题直觉都该从位运算做文章
        对数运算确实比较新颖^_^

【 在 IchijyouSan (一条さん|一条大神) 的大作中提到: 】
: 所以要换个宏啊 
: 比如说 
: f(x) (log(x)/log(2)) 
: ................... 



☆─────────────────────────────────────☆
   famed123 (^_^) 于  (Mon Sep 24 00:40:39 2007)  提到:

希望以后多看到这种十大楼。。。。。。。。
少些囧楼上十大就好咯


☆─────────────────────────────────────☆
   aguar (aguar) 于  (Mon Sep 24 00:44:07 2007)  提到:

恩 受教


☆─────────────────────────────────────☆
   powerclark (powerclark) 于  (Mon Sep 24 08:27:45 2007)  提到:

bd


☆─────────────────────────────────────☆
   dexter88 (Dexter) 于  (Mon Sep 24 11:42:30 2007)  提到:

慢慢来，别急，多接触接触就看知道他们在说什么了，编程的一步一步的学.......
ps:我也看不懂:)
【 在 czyoyo 的大作中提到: 】
: 为什么一点都看不懂．．哭 



 【文章标题】：[合集] [原创]貌似是微软的bug 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21526 【创建时间】：2007-10-03 【作者】：CNLAS 【评论】：0 【内容】：发信人: CNLAS (Ich gewinne bestimmt……), 信区: SoftDesign
标  题: [合集] [原创]貌似是微软的bug
发信站: 北邮人论坛 (Wed Oct  3 18:25:03 2007), 站内

☆─────────────────────────────────────☆
   hman (Richard) 于  (Mon Sep 24 11:09:31 2007)  提到:

这段程序的结果尽然是这样的。

#include &lt;iostream&gt; 
 
using namespace std; 

#pragma pack(1)
struct A 
{
	char t:4;
	char k:4;
	unsigned short i:8;
	unsigned long m;
};
#pragma pack()
 
int main(int argc, char *argv[]) 
{	
	cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl; 
	cout &lt;&lt; sizeof(A) &lt;&lt; endl;
	return 0;  
}

结果是:
4
7
Press any key to continue

在gcc上运行的结果是
4
6
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.180.*]


☆─────────────────────────────────────☆
   janeyre (菲靡之音) 于  (Mon Sep 24 16:21:10 2007)  提到:

囧，内存分配是往4个字节的边缘的
你自己再看看书...


☆─────────────────────────────────────☆
   UnrealT (UT) 于  (Mon Sep 24 16:26:57 2007)  提到:

sizeof这个运算很多时候都是跟cpu、编译器相关的
所以不要依赖sizeof


☆─────────────────────────────────────☆
   MasterZhang (忧郁的思想者) 于  (Mon Sep 24 17:12:38 2007)  提到:

用Java吧


☆─────────────────────────────────────☆
   hman (Richard) 于  (Mon Sep 24 21:07:50 2007)  提到:


【 在 janeyre 的大作中提到: 】
: 囧，内存分配是往4个字节的边缘的 
: 你自己再看看书... 
我只想把这个问题弄清楚。

不知道你看过那个 C结构体大小的那个贴没有。
地址是这个
http://forum.byr.edu.cn/wForum/disparticle.php?boardName=SoftDesign&amp;ID=20992&amp;pos=1
按照上面的规则，我做了一下计算。
1) 成员数据对齐 
#pragma pack(1) 
struct test_t { 
 char t:4;  /* 长度0.5 &lt; 1 按1对齐；起始offset=0 0%1=0；存放位置区间[0] */ 
 char k:4;  /* 长度0.5&lt;1 按1对齐；起始offset=0 0%1=0；存放位置区间[0]这个我已经在VC6的调试环境下看过了的确是放在一个字节里的。 */ 
 unsigned short i:8; /* 长度1 &gt; 1 按1对齐；起始offset=1 1%1=0；存放位置区间[1] */ 
 unsigned long m;  /* 长度4 &gt;1 按1对齐；起始offset=3  3%1=0；存放位置区间[2,3,4,5] */ 
}; 
#pragma pack() 
成员总大小=6 
 
2) 整体对齐 
整体对齐系数 = min((max(int,short,long), 1) = 1 
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 6 /* 6%1=0 */ [注1] 

不知道我这样理解是不是又问题。如果有问题请帮我指出，多谢。


☆─────────────────────────────────────☆
   hman (Richard) 于  (Mon Sep 24 21:10:52 2007)  提到:


【 在 UnrealT 的大作中提到: 】
: sizeof这个运算很多时候都是跟cpu、编译器相关的 
: 所以不要依赖sizeof 

那要是这样的话，我使用#pragma pack()也不能统一么？


☆─────────────────────────────────────☆
   CNLAS (Ich gewinne bestimmt……) 于  (Mon Sep 24 21:41:32 2007)  提到:

8. 含位域结构体的 sizeof
前面已经说过，位域成员不能单独被取 sizeof 值，我们这里要讨论的是含有位域的结构 
体的 sizeof ，只是考虑到其特殊性而将其专门列了出来。 
C99 规定 int 、 unsigned int 和 bool 可以作为位域类型，但编译器几乎都对此作了扩展， 
允许其它类型类型的存在。 
使用位域的主要目的是压缩存储，其大致规则为： 
1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的 sizeof 大小，则后面的字 
段将紧邻前一个字段存储，直到不能容纳为止； 
2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的 sizeof 大小，则后面的字 
段将从新的存储单元开始，其偏移量为其类型大小的整数倍； 
<b>3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异， VC6 采取不压缩方 
式， Dev-C++ 采取压缩方式； </b>
4) 如果位域字段之间穿插着非位域字段，则不进行压缩； 
5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。 




☆─────────────────────────────────────☆
   rebirthatsix (茫犭者) 于  (Mon Sep 24 21:45:54 2007)  提到:

re cc


 

【文章标题】：关于gcc优化选项，结果完全confusing... 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21496 【创建时间】：2007-10-01 【作者】：ericyosho 【评论】：6 【内容】：发信人: ericyosho (ericyosho), 信区: SoftDesign
标  题: 关于gcc优化选项，结果完全confusing...
发信站: 北邮人论坛 (Mon Oct  1 23:38:05 2007), 站内

写了一个很简单的测试代码。

#include &lt;stdio.h&gt;

int main() {
    const int i = 1;
    int* p = (int*)&amp;i;
    (*p)++;
    printf("%d    %d\n", *p, i);
    printf("%p    %p\n", p, &amp;i);
    return 0;
}

如果不加任何的-O选项，直接编译 gcc -o test.exe test.c
结果发现 i 的值也变为了2，说明const并没有起作用。
如果加了-O1选项，结果 i 的值仍然为1，此时两个地址却仍然是相同的，有点诡异。
然后按照man的解释，把-O1所对应的优化选项一个个显式地使用，像这样
gcc -fdefer-pop -fmerge-constants ... -o test.exe test.c
发现结果和不加优化选项时一样，难道写-O1和一个个显示写还有差别？

完全地被打败了……
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.229.*]
 
【文章标题】：学C#,用什么书比较好? 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21448 【创建时间】：2007-09-28 【作者】：HiCoco 【评论】：5 【内容】：发信人: HiCoco (COCO), 信区: SoftDesign
标  题: 学C#,用什么书比较好?
发信站: 北邮人论坛 (Fri Sep 28 20:52:52 2007), 站内

想学C#,用哪本书比较好?
请哪位过来人能指点一下~
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.162.*]
 
【文章标题】：[合集] 新手问个问题:JAVA和C++两个一起学，都想学好，合适吗？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21527 【创建时间】：2007-10-03 【作者】：CNLAS 【评论】：0 【内容】：发信人: CNLAS (Ich gewinne bestimmt……), 信区: SoftDesign
标  题: [合集] 新手问个问题:JAVA和C++两个一起学，都想学好，合适吗？
发信站: 北邮人论坛 (Wed Oct  3 18:25:17 2007), 站内

☆─────────────────────────────────────☆
   warmtea (温一壶茶（虎虎）) 于  (Mon Sep 24 15:03:44 2007)  提到:

菜鸟来个sf。。。。我编的程很少，所以同站在这个角度，可以给你一些我的看法
个人觉得，无所谓，不过没有必要一起学，可以先学JAVA，相对来说，它的各方面都比较单纯，容易上手……。比如它里面没有指针，不能从多个类继承，引入接口概念等，还有写概念如同步啊，容器啊，这些概念在教程里都会讲的比较清晰，个人认为比较好学。如果你只是用纯c++，一些不一样的地方明确一下就OK，语言基本是一样的。不过，作为一个菜鸟，一旦我用到MFC，就完全不会考虑程序结构什么的了，基本上就只是把该添的添了，然后很拙劣地实现了功能就OK……。
如果你想实现win下面的一些小软件什么的，可以用C#，这个和JAVA也很像，如果你学C++是为了以后做一些算法啊什么的，可以先把算法的基础打好，现在做搜索啊，数据挖掘啊什么的喜欢用C++，多媒体开发方面也多。JAVA一般做一些B/S的系统，这里面可以应用一些框架技术什么的，还有很多通信相关的应用开发，你可以使用web的那一套做用户前台和管理后台，使用sip servlet等做呼叫逻辑等。
呃，我说的很混乱了……总之你还是先想想你以后的研究方向，然后努力学相关的很多知识吧，语言只是很少的一部分。。。。。


☆─────────────────────────────────────☆
   coolfantasy (Cool) 于  (Mon Sep 24 16:00:31 2007)  提到:

"两个都爱 两个都伤害" -- 莫文蔚


☆─────────────────────────────────────☆
   UnrealT (UT) 于  (Mon Sep 24 16:21:18 2007)  提到:


【 在 warmtea 的大作中提到: 】
: 如果你只是用纯c++ 
请问什么是纯C++？


☆─────────────────────────────────────☆
   warmtea (温一壶茶（虎虎）) 于  (Mon Sep 24 16:26:16 2007)  提到:

不知道……我说的话历来以信口开河著称……
我的意思是不涉及一些平台相关的类库什么的……
【 在 UnrealT 的大作中提到: 】
: 请问什么是纯C++？ 



☆─────────────────────────────────────☆
   mmgroup (からす) 于  (Mon Sep 24 16:31:44 2007)  提到:


【 在 UnrealT 的大作中提到: 】
: 请问什么是纯C++？ 

Omniplatform?


☆─────────────────────────────────────☆
   littleboy (would you love me ?) 于  (Mon Sep 24 16:36:51 2007)  提到:

一口吃成胖子吃死得了。
【 在 siye2004 (siye2004) 的大作中提到: 】
: RT 




☆─────────────────────────────────────☆
   MasterZhang (忧郁的思想者) 于  (Mon Sep 24 17:11:41 2007)  提到:

有同时用移动和联通的吗?


☆─────────────────────────────────────☆
   siye2004 (siye2004) 于  (Mon Sep 24 17:24:15 2007)  提到:

我就是不知道以后的研究方向啊，实验室没什么项目~~


☆─────────────────────────────────────☆
   siye2004 (siye2004) 于  (Mon Sep 24 17:28:30 2007)  提到:

热心人啊~~~，有耐心写这么多的字，THANKS!
【 在 warmtea 的大作中提到: 】
: 菜鸟来个sf。。。。我编的程很少，所以同站在这个角度，可以给你一些我的看法 
: 个人觉得，无所谓，不过没有必要一起学，可以先学JAVA，相对来说，它的各方面都比较单纯，容易上手……。比如它里面没有指针，不能从多个类继承，引入接口概念等，还有写概念如同步啊，容器啊，这些概念在教程里都会讲的比较清晰，个人认为比较好学。如果你只是用纯c++，一些不一样的地方明确一下就OK，语言基本是一样的。不过，作为一个菜鸟，一旦我用到MFC，就完全不会考虑程序结构什么的了，基本上就只是把该添的添了，然后很拙劣地实现了功能就OK……。 
: 如果你想实现win下面的一些小软件什么的，可以用C#，这个和JAVA也很像，如果你学C++是为了以后做一些算法啊什么的，可以先把算法的基础打好，现在做搜索啊，数据挖掘啊什么的喜欢用C++，多媒体开发方面也多。JAVA一般做一些B/S的系统，这里面可以应用一些框架技术什么的，还有很多通信相关的应用开发，你可以使用web的那一套做用户前台和管理后台，使用sip servlet等做呼叫逻辑等。 
: ................... 



☆─────────────────────────────────────☆
   siye2004 (siye2004) 于  (Mon Sep 24 17:29:27 2007)  提到:

现在迷茫的很啊，实验室没项目，没方向，该学什么东西？？？


☆─────────────────────────────────────☆
   coolfantasy (Cool) 于  (Mon Sep 24 17:31:18 2007)  提到:

建议新手还是从C语言开始

两本书《深入理解计算机系统》和《The C Programming Language》





☆─────────────────────────────────────☆
   UnrealT (UT) 于  (Mon Sep 24 17:35:49 2007)  提到:


【 在 siye2004 的大作中提到: 】
: 现在迷茫的很啊，实验室没项目，没方向，该学什么东西？？？ 
你对将来有什么规划吗？
如果连这个都没有的话，去学点哲学吧


☆─────────────────────────────────────☆
   siye2004 (siye2004) 于  (Mon Sep 24 17:39:59 2007)  提到:

这和人生规划什么的没什么关系吧，考之前也不知道实验室是这个样子啊。只是技术方面还是个新手
【 在 UnrealT 的大作中提到: 】
: 你对将来有什么规划吗？ 
: 如果连这个都没有的话，去学点哲学吧 



☆─────────────────────────────────────☆
   LoveRose (江南西道|tuoqi-开始还债) 于  (Mon Sep 24 18:49:16 2007)  提到:


【 在 coolfantasy 的大作中提到: 】
: 建议新手还是从C语言开始 
: 两本书《深入理解计算机系统》和《The C Programming Language》 
C++Primer 4也可以


☆─────────────────────────────────────☆
   zwz (ERA-The Mass) 于  (Mon Sep 24 20:05:15 2007)  提到:


【 在 MasterZhang 的大作中提到: 】
: 有同时用移动和联通的吗? 


有。。。。。。。有的手机支持双模双卡双待机

=。=


☆─────────────────────────────────────☆
   catseye (Lisa) 于  (Mon Sep 24 20:28:43 2007)  提到:

俨然不合适
把一个弄通了再弄另一个
一起学，学着学着你就把一个当成另一个了


☆─────────────────────────────────────☆
   siye2004 (siye2004) 于  (Mon Sep 24 20:44:11 2007)  提到:

恩


☆─────────────────────────────────────☆
   tuna (金枪鱼) 于  (Mon Sep 24 23:54:40 2007)  提到:

c primer plus !!不错！


☆─────────────────────────────────────☆
   Kumbayaco (拉·甘地 ※ 冥中冥) 于  (Tue Sep 25 00:58:49 2007)  提到:

同新手~还是悠着点好~


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Tue Sep 25 01:13:18 2007)  提到:

话说，如果不是搞软件这一行的，也没有必要学java吧。。。
学点C还是比较有用的。不一定要C++啦。。。

有一技之长就好啦，也不要看着周围的人会编程，就想也要学。找自己的长处发挥到极致就好了。


☆─────────────────────────────────────☆
   yunfeng2000 (晨曦) 于  (Tue Sep 25 09:09:10 2007)  提到:

可以一起学，但要有所偏重，C++可以让你理解程序的运行机理，java可以让你更好的理解OOP的思想。互相辅助。学到最后，就会理解编程语言其实都是相通的


☆─────────────────────────────────────☆
   cryptclark () 于  (Tue Sep 25 09:23:49 2007)  提到:

你先问下自己，自己以后的打算是什么，为什么学习C++，为什么学习JAVA
JAVA适合做上层应用，web开发等，手机应用软件等
C++靠底层一些，开发一些系统级的软件，如驱动开发（当然也要用C），通信
软件，图像处理（效率要求高），还有系统核心编程得用C++
但是C++很复杂，学好拉也会让人更深入的理解计算机运行原理，不是读完C++Primer
就可以认为自己懂的，要好几年的实践来磨练
JAVA上手容易些，我有一年C#经验，JAVA接触不多，不过C#和JAVA很像，学过的
都知道，微软就是抄袭拉JAVA的模式。
所以先看你自己以后的规划拉，不要盲目地拿本书就看，我也不是高手，凭自己经验，
说的不对的请多多包涵。


☆─────────────────────────────────────☆
   month10day10 (mjj的男人) 于  (Tue Sep 25 12:30:03 2007)  提到:

学数学是王道 真的
有学另一个语言的功夫还不如把算法的基本功打扎实了


☆─────────────────────────────────────☆
   month10day10 (mjj的男人) 于  (Tue Sep 25 13:32:02 2007)  提到:


【 在 cryptclark 的大作中提到: 】
: 你先问下自己，自己以后的打算是什么，为什么学习C++，为什么学习JAVA 
: JAVA适合做上层应用，web开发等，手机应用软件等 
: C++靠底层一些，开发一些系统级的软件，如驱动开发（当然也要用C），通信 
: ................... 

听某高人说C++的入门时间是5年


☆─────────────────────────────────────☆
   nioxt (nioxt) 于  (Tue Sep 25 23:02:48 2007)  提到:

门槛可真高……


☆─────────────────────────────────────☆
   succubus (悲运的巫女——被诅咒的Cassandra) 于  (Wed Sep 26 00:02:28 2007)  提到:

把c学好
算法和数据结构学好
如果能学好操作系统和汇编更好
其他的看到时候用啥吧
语言不过是衣服
把基础打牢了其他都不在话下


 
【文章标题】：SIP 消息返回415不支持的媒体类型,这谁碰到过? 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21536 【创建时间】：2007-10-04 【作者】：bbsbyr 【评论】：2 【内容】：发信人: bbsbyr (NO), 信区: SoftDesign
标  题: SIP 消息返回415不支持的媒体类型,这谁碰到过?
发信站: 北邮人论坛 (Thu Oct  4 10:10:33 2007), 站内

RT
--
我的QMD!

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.239.*]
 
【文章标题】：[合集] 征师傅学习制作游戏 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20160 【创建时间】：2007-07-30 【作者】：CNLAS 【评论】：0 【内容】：发信人: CNLAS (Ich gewinne bestimmt……), 信区: SoftDesign
标  题: [合集] 征师傅学习制作游戏
发信站: 北邮人论坛 (Mon Jul 30 00:37:27 2007), 站内

☆─────────────────────────────────────☆
   X22 (X) 于  (Thu Jul 26 02:52:00 2007)  提到:

征师傅学习制作游戏
本人想学习制作游戏,不过我只会写算法程序,其他的什么也不会了
所以希望有会做游戏的高手赐教,或带我一起制作,愿意作徒弟


☆─────────────────────────────────────☆
   hisashi (斩杀天使的恐怖骑士) 于  (Thu Jul 26 09:33:25 2007)  提到:

学习一下win sdk编程，仿照directx文档写几个小程序，下载一个renderware学习使用，上gameres看看


☆─────────────────────────────────────☆
   CNLAS (Ich gewinne bestimmt……) 于  (Thu Jul 26 11:32:32 2007)  提到:

看你想做那个方面的了。。。个人感觉最有前途但也最难的部分就是脚本虚拟机。。。
其他的全都是API调用。。。找各种Reference慢慢翻吧。。。
脚本虚拟机才是最能体现程序员对计算机系统和计算机语言以及游戏设计思想的理解的重要部分。。。

当然。。。你要不做引擎部分就当我啥都没说好了。。。




☆─────────────────────────────────────☆
   zwz (Claymore No.47 Logo) 于  (Thu Jul 26 11:57:44 2007)  提到:


【 在 CNLAS 的大作中提到: 】
: 看你想做那个方面的了。。。个人感觉最有前途但也最难的部分就是脚本虚拟机。。。 
: 其他的全都是API调用。。。找各种Reference慢慢翻吧。。。 
: 脚本虚拟机才是最能体现程序员对计算机系统和计算机语言以及游戏设计思想的理解的重要部分。。。 
: ................... 

war3 的worldedit太牛了，以前觉得sc的地图编辑器就很牛了。。。。。


☆─────────────────────────────────────☆
   windam (windam) 于  (Thu Jul 26 12:03:24 2007)  提到:

脚本系统只能算游戏中的一小部分。
应该说现在比较成规模的游戏都至少有几个部分：图形渲染部分、脚本部分、AI部分、美工部分、剧本部分。
每一个部分都是缺一不可的。程序写得再好，没有好的剧本或者创意，游戏也没法搭建起来，同样的引擎再牛，没有一流的美工贴图模型，也玩不转。
想学着做游戏的话应该在了解所有流程的基础上，专精一个方向。
从程序方面说，
如果做渲染引擎。那就不能仅仅停留在使用DXAPI的程度上，应该自己去看图形算法，自己学各种有用的数值算法，等等。不仅仅能用DX，还要知道DX为什么设计成这样。
如果自己写脚本引擎，那就得深入了解编译原理，自己动手写一个编译器，即使很简陋，收获也会很大。
如果学AI，那就要看一些经典的算法，不仅仅要知道、会用，还得能根据实际情况更改算法，提出新算法等等。像A*用在寻路中、躲避追逐的算法用在游戏中NPC以及怪物的互动中、遗传算法用在策略选择上等等。
= =
做游戏要求的东西太多了，一个人根本不可能全学完。找个自己感兴趣而且转型也容易的方向钻研吧。。。



☆─────────────────────────────────────☆
   zwz (Claymore No.47 Logo) 于  (Thu Jul 26 12:10:59 2007)  提到:

游戏类型很多，现在玩的游戏就是静态画+文本。按键翻页。。。。。。。
=。=

这种游戏就是美工+剧本。。。。。程序是个人就能写


☆─────────────────────────────────────☆
   hisashi (斩杀天使的恐怖骑士) 于  (Thu Jul 26 13:47:19 2007)  提到:

看你的发展方向是什么，如果是想进游戏公司求职那逻辑算法，图形显示熟悉一种即可，如果是自己想独立做游戏还是从图形图像开始吧，算法是次要的，因为外观不好而不玩一个游戏的远比算法不好而不玩一个游戏的多。至于脚本引擎，不是打击你们，不是很重要，随手写写的东西，根本谈不上工作量


☆─────────────────────────────────────☆
   kissme (kissme) 于  (Thu Jul 26 14:41:05 2007)  提到:

基本上同意4楼和6楼的观点.
如果你找到做游戏的公司,并说你只会算法,那多半人家会只让你做算法了.
个人做游戏时,尽量不要求大.根据自己的方向,能不自己做的就可以使用别人的.
我现在在做一个游戏脚本引擎(二次封装,不是最基础的那种...),
最近停滞了好长一段时间,估计不久后会继续做.
像我这种情况的就很想找现成的算法.来实现我的作品.


☆─────────────────────────────────────☆
   X22 (X) 于  (Fri Jul 27 00:15:50 2007)  提到:

可以和这位大牛一起做吗?

【 在 kissme 的大作中提到: 】
: 基本上同意4楼和6楼的观点. 
: 如果你找到做游戏的公司,并说你只会算法,那多半人家会只让你做算法了. 
: 个人做游戏时,尽量不要求大.根据自己的方向,能不自己做的就可以使用别人的. 
: ................... 



☆─────────────────────────────────────☆
   X22 (X) 于  (Fri Jul 27 00:16:45 2007)  提到:

我是想做引擎或AI,主要是学习方法


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Fri Jul 27 12:19:55 2007)  提到:

可以试试 robocode ，只写AI的~~~

【 在 X22 的大作中提到: 】
: 我是想做引擎或AI,主要是学习方法 



☆─────────────────────────────────────☆
   kissme (kissme) 于  (Fri Jul 27 14:25:09 2007)  提到:


【 在 X22 的大作中提到: 】
: 我是想做引擎或AI,主要是学习方法 

麻烦说明白是什么引擎...因为"引擎"只是一种泛性的说法,具体的话差别就大了.
至于AI,这个我不是太了解,但目前AI的使用层次还较高,不是所有游戏都能用上AI的.
而算法倒是十分普遍的.哪都能用到算法.


☆─────────────────────────────────────☆
   X22 (X) 于  (Fri Jul 27 17:53:08 2007)  提到:

只要有人带着做什么都行


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Fri Jul 27 18:24:33 2007)  提到:

其实，算法也是个泛性的说法。相对数据结构的几个方法，有人说是算法；ＡＣＭ版的那些人，会认为他们研究的才是算法；可是ＡＩ用的那些，又是另一套不同的东西，也叫算法。
不知道ＬＺ想研究哪方面。毕竟，每一小项都有很大学问。

【 在 kissme 的大作中提到: 】
: 麻烦说明白是什么引擎...因为"引擎"只是一种泛性的说法,具体的话差别就大了. 
: 至于AI,这个我不是太了解,但目前AI的使用层次还较高,不是所有游戏都能用上AI的. 
: 而算法倒是十分普遍的.哪都能用到算法. 



☆─────────────────────────────────────☆
   kissme (kissme) 于  (Fri Jul 27 21:19:29 2007)  提到:


【 在 X22 的大作中提到: 】
: 只要有人带着做什么都行 

那你会写连连看算法不?会写的话马上有活你干.


☆─────────────────────────────────────☆
   zwz (Claymore No.47 Logo) 于  (Fri Jul 27 22:47:16 2007)  提到:


【 在 Jarod 的大作中提到: 】
: 可以试试 robocode ，只写AI的~~~ 

robocode好玩。。。。。。不想深入研究的话改别人的或者那几个例子也挺有意思。


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Fri Jul 27 23:14:19 2007)  提到:

连连看还有算法？

【 在 kissme 的大作中提到: 】
: 那你会写连连看算法不?会写的话马上有活你干. 



☆─────────────────────────────────────☆
   kissme (kissme) 于  (Sat Jul 28 00:21:29 2007)  提到:


【 在 Jarod 的大作中提到: 】
: 连连看还有算法？ 

这个这个...事实上我更佩服那些说了这样的话后还顺带帖上相关代码的人~
(最好不要跟我说自己找或baidu一下之类的话)

我问这样的话，
1.是试探楼主是否有这个能力。(写不出来就不要谈做游戏了，不管用什么语言。)
2.还要试探楼主是否有一定的自学能力，因为用C++或JAVA写都不是我想要的，而是用LUA写。(通常“有一定自学能力”的人，能将现在的代码转成所需要的任意形式。)

有关LUA的写法，可参照我BLOG中的一个范例。
http://blog.sina.com.cn/u/4db86818010009py

感兴趣就应。写代码是件很现实，很踏实的事。
我不是研究理论的，只是个游戏工程的砌砖工而已。


☆─────────────────────────────────────☆
   kissme (kissme) 于  (Sat Jul 28 00:24:44 2007)  提到:

补充一下：
上网找的也行，只要你实际编译通过并运行测试证明正确可用即可。
只有这样，才能实际掌控你手中的代码。
而不是看了说明下载后直接交给我。


☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 03:32:26 2007)  提到:

实话说我只会C++并且还不太会MFC,真的就是想跟着看看别人是怎么做东西的
我还是比较想学OpenGL,用一些巧妙的算法来实现动画演示


☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 03:35:14 2007)  提到:

我是从ACM版跑过来的
因为觉得自己知道的东西太少了,一直局限于ACM,所以来这里学习

【 在 Jarod 的大作中提到: 】
: 其实，算法也是个泛性的说法。相对数据结构的几个方法，有人说是算法；ＡＣＭ版的那些人，会认为他们研究的才是算法；可是ＡＩ用的那些，又是另一套不同的东西，也叫算法。 
: 不知道ＬＺ想研究哪方面。毕竟，每一小项都有很大学问。 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 03:41:58 2007)  提到:

这个我试过
可是对他的内部原理一点也不懂
只是在样例基础上改程序
如果人兄愿意指导,我想先从这个学起

【 在 Jarod 的大作中提到: 】
: 可以试试 robocode ，只写AI的~~~ 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 03:45:44 2007)  提到:

这个应该主要是策略问题
样例中的一个围着地图旋转的那个策略在所有样例中基本是无敌的是吗?

【 在 Jarod 的大作中提到: 】
: 可以试试 robocode ，只写AI的~~~ 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 03:54:42 2007)  提到:

我很火星,没玩过连连看
是不是就是随即产生一个两两配对的图
然后用鼠标去点击配对的两个图标来消除啊?
如果是,那么算法应该就是简单的模拟
先随即产生地图
然后就是判断人工选择点击的图标是否可以消除
还有就是消除后的状态再判消除直到没有可消除的,跳到下一次人工选择的状态
我说的对吗?

【 在 kissme 的大作中提到: 】
: 那你会写连连看算法不?会写的话马上有活你干. 



☆─────────────────────────────────────☆
   temp (北邮人) 于  (Sat Jul 28 07:31:59 2007)  提到:


【 在 X22 的大作中提到: 】
: 这个应该主要是策略问题 
: 样例中的一个围着地图旋转的那个策略在所有样例中基本是无敌的是吗? 

围着敌人扇形运动的是无敌策略。
Y轴（面向敌人，左右）随机移动保证很小被击中概率。不知道计算敌方炮弹了没。
计算敌人提前量发炮。


☆─────────────────────────────────────☆
   Jarod (轻轻地我走了) 于  (Sat Jul 28 09:18:49 2007)  提到:

U can try my robot:

[upload=1][/upload]

用import robot

【 在 X22 的大作中提到: 】
: 这个应该主要是策略问题 
: 样例中的一个围着地图旋转的那个策略在所有样例中基本是无敌的是吗? 



☆─────────────────────────────────────☆
   kissme (kissme) 于  (Sat Jul 28 10:44:13 2007)  提到:

从楼主的答复看，楼主没有说明白究竟想做啥和能做啥。
又OPENGL又AI又引擎的。
(基本是别人说到一处就说想学一处...)
没有玩过连连看？工作后可不是所有别人安排的任务都是你干过的。不会学啊~
楼主只限于讨论，而无实际的实践操作，
说得理论性很强，叫做起来找各种托词。
这一点也是很多抱有XX幻想的初学者的通病。
以为做过些东东，就可以是程序员，可以踏入软件开发的大厅了。

我的语气可能不太谦和，但也是一些心里话。
外我用的是D3D8和SDK，无MFC...


☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 23:51:33 2007)  提到:

谢谢教导,但我并没有推脱的言辞
如果你愿意要我我就学就做
我是初学所以什么都不知道,什么都想学
难道我这样不对吗?
这样我可以在接触各方面时找到自己想要的想学的


【 在 kissme 的大作中提到: 】
: 从楼主的答复看，楼主没有说明白究竟想做啥和能做啥。 
: 又OPENGL又AI又引擎的。 
: (基本是别人说到一处就说想学一处...) 
: ................... 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 23:54:31 2007)  提到:

我上面不是说了自己对你说的连连看的一些想法吗?
我说没玩过,但没有说不学不做啊
我是很认真的对你说的东西,给出了我自己头脑里的想法

【 在 kissme 的大作中提到: 】
: 从楼主的答复看，楼主没有说明白究竟想做啥和能做啥。 
: 又OPENGL又AI又引擎的。 
: (基本是别人说到一处就说想学一处...) 
: ................... 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sat Jul 28 23:58:28 2007)  提到:

我个人的理解openGL是做图的,AI是玩家的对手,引擎是搭建游戏的平台,不对吗?
我是都想学,但是也要有人愿意带我啊
所以我是说了,谁带就学什么
我这样也招骂吗?

【 在 kissme 的大作中提到: 】
: 从楼主的答复看，楼主没有说明白究竟想做啥和能做啥。 
: 又OPENGL又AI又引擎的。 
: (基本是别人说到一处就说想学一处...) 
: ................... 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sun Jul 29 00:10:39 2007)  提到:

本人就是因为什么都没有接触过才来请教大家的
如果大家都是以专家的眼光来看我,那我也没什么好说的了
我只能说一句:人弱就是会被人鄙视

【 在 X22 的大作中提到: 】
: 征师傅学习制作游戏 
: 本人想学习制作游戏,不过我只会写算法程序,其他的什么也不会了 
: 所以希望有会做游戏的高手赐教,或带我一起制作,愿意作徒弟 



☆─────────────────────────────────────☆
   kissme (kissme) 于  (Sun Jul 29 01:15:54 2007)  提到:


【 在 X22 的大作中提到: 】
: 征师傅学习制作游戏 
: 本人想学习制作游戏,不过我只会写算法程序,其他的什么也不会了 
: 所以希望有会做游戏的高手赐教,或带我一起制作,愿意作徒弟 
[upload=1][/upload]

按要求上传的HGE。可从官网下载：
http://hge.relishgames.com


☆─────────────────────────────────────☆
   UnrealT (UT) 于  (Sun Jul 29 07:15:21 2007)  提到:

一直很想说，可以看一下版规中发贴要求第13条和删封条例第13条

前面看见讨论得还不错，就忍住没说，现在有点不太和谐了，就说一下

还有就是，LZ一开始换个问法会比较好，毕竟大家时间有限，你征人能征成功的概率太低了

如果换“我要制作游戏的话，应该学些什么知识比较好”的话，虽然这不是个好问题，没有体现出自己任何的思考痕迹，不过还是比征人要强


☆─────────────────────────────────────☆
   X22 (X) 于  (Sun Jul 29 22:31:28 2007)  提到:

谢谢,但是我确实是想征人


☆─────────────────────────────────────☆
   boots (北邮首席乖孩子=&gt;小子马甲) 于  (Sun Jul 29 22:50:27 2007)  提到:

谁带就学什么,这种态度其实也说明了你并没有自己的目标,学东西一定要有个师傅才能学么

我觉得前面的贴子里kissme对你的回复非常认真,而且他也真正是做这个的,他说的不是事实么

你并没有自己的选择,一堆一堆的技术你完全没有侧重点,这么征师傅,试问有人敢应么? 

或许你会说,征不征得到是你自己的事情,但是这个贴子里很多都是从你这个阶段走过来的,他们给的建议也很中肯,你总觉得只要有人带你什么都愿意学,可你凭什么让别人带你把你当徒弟一个付出时间和精力去给一个连选择都不爱做自己对自己没有一个清晰的认识和目标的人? 

知识必须要有人教才能学么? 

还有就是这种态度,谁带就学什么,其实就像现在的大三学生找实习一样,有的人会说,只要让我实习不给工资也行.但是公司招一个人进公司也是有成本的,经过一系列的手续流程,会有专门的人带着入门,如果你连工资都没要求,那公司能指望你做些什么呢,工作不积极,分配任务也不做,公司拿你没办法啊,你又不要工资,这样下来公司根本看不到这个人的任何有用的价值,又怎么会招收这个人进来实习呢



【 在 X22 (X) 的大作中提到: 】
: 我个人的理解openGL是做图的,AI是玩家的对手,引擎是搭建游戏的平台,不对吗? 
: 我是都想学,但是也要有人愿意带我啊 
: 所以我是说了,谁带就学什么 
: ................... 



☆─────────────────────────────────────☆
   boots (北邮首席乖孩子=&gt;小子马甲) 于  (Sun Jul 29 22:52:45 2007)  提到:

如果你愿意要我我就学就做


如果你在说这句话之前已经做了,那么这个师傅估计你已经找到了.


【 在 X22 (X) 的大作中提到: 】
: 谢谢教导,但我并没有推脱的言辞 
: 如果你愿意要我我就学就做 
: 我是初学所以什么都不知道,什么都想学 
: ................... 



☆─────────────────────────────────────☆
   X22 (X) 于  (Sun Jul 29 23:00:51 2007)  提到:

谢谢各位,我也不想狡辩什么,是我的方式不对
我也只是想了解了各种情况才能做选择啊
就想高考选专业一样,如果不了解怎么选择
当时我是因为一直做ACM,所以有目标,完全不用思考就是选择计算机专业
而我现在想学习做游戏,但是从没有接触过任何制作
想看别人是怎么做的,来选择自己的方向

再次感谢给我提出宝贵意见的各位

【 在 boots 的大作中提到: 】
: 谁带就学什么,这种态度其实也说明了你并没有自己的目标,学东西一定要有个师傅才能学么 
: 我觉得前面的贴子里kissme对你的回复非常认真,而且他也真正是做这个的,他说的不是事实么 
: 你并没有自己的选择,一堆一堆的技术你完全没有侧重点,这么征师傅,试问有人敢应么?  
: ................... 



☆─────────────────────────────────────☆
   CNLAS (Ich gewinne bestimmt……) 于  (Sun Jul 29 23:21:42 2007)  提到:

所谓的师傅是干嘛的。。。我的理解
就是推荐你几本入门书籍。。。解决你一些baidu google不到的问题（这种问题应该很少吧。。。通常很多人是不愿意自己去找。。。）

剩下的自己该干嘛干嘛去吧。。。该看些什么书。。。该写些什么东西。。。该问些什么问题。。。都是自己的事情了。。。俗话说的好。。。师傅领进门，修行看个人。。。

这里出现的人一般都是忙人。。。要学的东西只会越学越多。。。没有谁有时间有义务手把手的教。。。有那种闲功夫的人都去开学校和培训班去了。。。

所以啊。。。找人给你推荐些书。。。看多了自然就会找到路子了。。。




☆─────────────────────────────────────☆
   X22 (X) 于  (Sun Jul 29 23:48:05 2007)  提到:

建议斑竹删掉此帖吧
人以征到,正在学习当中


 
【文章标题】：哪位OpenGL高手可以给帮帮忙 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21542 【创建时间】：2007-10-04 【作者】：X22 【评论】：7 【内容】：发信人: X22 (X), 信区: SoftDesign
标  题: 哪位OpenGL高手可以给帮帮忙
发信站: 北邮人论坛 (Thu Oct  4 22:44:35 2007), 站内

不知道为什么图象显示不完全

<a href="/att/SoftDesign/0/21542/259" target="_blank" color="blue">附件(125.2KB)  Map.rar</a>
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.192.*]

 
【文章标题】：关于数据结构B－树的问题[求助] 【文章地址】：https://bbs.byr.cn/article/SoftDesign/21494 【创建时间】：2007-10-01 【作者】：CS 【评论】：11 【内容】：发信人: CS (Computer&amp;Science), 信区: SoftDesign
标  题: 关于数据结构B－树的问题[求助]
发信站: 北邮人论坛 (Mon Oct  1 21:30:53 2007), 站内

B－树中有k个子树的分支结点包含k-1个关键字
这个说法对吗？
为什么？<img src="/img/ubb/em/40.gif" alt="em40" style="display:inline;border-style:none">
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.196.*]
 
【文章标题】：[询问]C++里的set容器有办法串行化输出到文件/从文件输入？ 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20045 【创建时间】：2007-07-26 【作者】：windam 【评论】：10 【内容】：发信人: windam (windam), 信区: SoftDesign
标  题: [询问]C++里的set容器有办法串行化输出到文件/从文件输入？
发信站: 北邮人论坛 (Thu Jul 26 12:08:55 2007), 站内

嗯。。。对stl的实现不是特别清楚。
貌似没有提供相关的接口吧。。。
只知道set/map的数据结构是红黑树，问题是，如果数据量很大的情况，每次都要从文件里一个一个节点的读出来再构建这么一棵树，再使用，不是很低效么。。。
有没有什么办法可以直接load进来就已经是一颗成型了这样的树的。。。= =
就是预先构建好树的结构用于查询，然后不用再每次都构建一遍树。把数据从硬盘读入到内存就直接是这样的结构的。。。= =（貌似好像没法直接实现）

嗯，貌似只想到了用数组的办法构建的二叉树可以直接输出到文件或者从文件直接读入。不知道有没有人比较清楚有没有什么别的办法，就是直接利用现有的set，然后实现与文件的输入输出。（数据量比较大的情况下。。。）
p.s.这个问题应该算软件版的问题吧。。。挺犹豫发软件还是发算法的。。。= =

--

※ 修改:·windam 于 Jul 26 12:25:31 修改本文·[FROM: 59.64.235.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.235.*]
 
【文章标题】：LEGO可编程机器人。。。 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20170 【创建时间】：2007-07-30 【作者】：coolfantasy 【评论】：3 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题: LEGO可编程机器人。。。
发信站: 北邮人论坛 (Mon Jul 30 13:19:33 2007), 站内

http://www.robotdiy.com/article.php?sid=260


--
   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 61.135.146.*]
 
【文章标题】：[zz] Teach a Kid to Program 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20165 【创建时间】：2007-07-30 【作者】：coolfantasy 【评论】：4 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题: [zz] Teach a Kid to Program
发信站: 北邮人论坛 (Mon Jul 30 12:16:22 2007), 站内

From [<a target="_blank" href="http://howto.wired.com/wiredhowtos/index.cgi?page_name=teach_a_kid_to_program;action=display;category=Live%5D">http://howto.wired.com/wiredhowtos/index.cgi?page_name=teach_a_kid_to_program;action=display;category=Live]</a>


Teach a Kid to Program
See Also: Comments on the Geek Dad Post [<a target="_blank" href="http://blog.wired.com/geekdad/2007/07/how-to-teach-a-.html#comments%5D">http://blog.wired.com/geekdad/2007/07/how-to-teach-a-.html#comments]</a>

Table of Contents: Teach a Kid to Program



The question 
Tools 
Practices 
Books 



The question
I don't really know the answer to this, so I'm asking for a How To. My kid is 5, about to enter kindergarten. What are some entry points for coding? Fun environments, or basics that are great foundations? Should I get a Apple II+ on eBay and start with BASIC? I'll cross post suggestions to Geek Dad. Thanks, Ross Mayfield.

Tools
Logo
Logo is a programing language for kids. There is a free version for the PC, MSWlogo, which also has lots of online tutorials. There is also a free version for the Mac, ACSLogo.

Lego Mindstorms
Programmable lego sets that offer a fairly simple programming interface. There is also a free online Lego simbot which overlaps with Logo.

Flowol
Control applications offer a good visual way to learn programming concepts. Flowol is a popular one used with students.

Game Maker
Game maker is excellent and free and allows for both drag and drop and coding.

Scratch
Scratch is a superb new visual programming environment that is gathering a lot of attention amongst educators. It can be used to create games, tell stories, respond to variables and so on.

Alice
For the final stage I would recommend alice for OOP but without the headache!

Pipes

One thing I'm going to try with my 10 year old is Yahoo Pipes

KPL

Code for Fun says I would highly recommend KPL(Kids Programming Language) ...It's like BASIC on steriod..KPL is based on C#.

Hackety Hack

why, the luck stiff, put together an environment specifically designed to get kids interested in programming. It's based on ruby and specializes in creating applications that would interest kids, such as a blog or a music player. This is why he did, here is how you can get it, and here is more info about it.

Phrogram

My husband started my then seven year-old with <a target="_blank" href="http://phrogram.com/">http://phrogram.com/</a> She was able to do "Hello World" and line graphics with his help, using the free version. They include a nice tutorial and it looks like a real programming environment, so moving up, when they're ready, won't be too hard.

Practices
Dear Ross!

I need to tell you first that most of my reply is theory - I haven't succesfully tried them. One of the things which supposedly needs to comes out is LOGO - it is a programming language for kids see the LOGO entry at Wiki for a starter. You should of course try the programmable LEGO sets.

The other what comes to my mind are the level and script editors to some computer games. My theory is that by grabbing/keeping the attention you can "teach" a lot more to any child than by force ( the same way hackers works ). Heroes of might and magic got some level editors with some scripting - you can put a whole story in it. There is scripting for the Fallout series - if you are able to dig it out - and feel it appropriate to your child :). There was a thing called RPGMaker. The games are all supposedly grab the attention for enough time to create a positive feedback when they create enough interesting thing to enjoy it, and it make them the energy


--------------------------------------------------------------------------------

I'm a secondary teacher rather than primary so am not an expert at teaching 5 year olds but I can say what I do in secondary:

I would say the first stop should be MSWlogo which is free - <a target="_blank" href="http://www.softronix.com/logo.html">http://www.softronix.com/logo.html</a> - with lots of online tutorials
Control applications offer a good visual way to learn programming concepts. Flowol is a popular one I use with my students - <a target="_blank" href="http://www.flowol.com/">http://www.flowol.com/</a>
Another control application is a free online lego simbot which has overlaps with Logo - <a target="_blank" href="http://mindstorms.lego.com/simbot/">http://mindstorms.lego.com/simbot/</a>
Scratch would extend what has been learned form the above applications nicely - <a target="_blank" href="http://scratch.mit.edu/">http://scratch.mit.edu/</a> - and free courses are available on the web - <a target="_blank" href="http://www.meridianmoodle.com/course/view.php?id=35">http://www.meridianmoodle.com/course/view.php?id=35</a>
Game maker is excellent and free and allows for both drag and drop and coding - <a target="_blank" href="http://www.yoyogames.com/gamemaker">http://www.yoyogames.com/gamemaker</a>
For the final stage I would recommend alice - <a target="_blank" href="http://www.alice.org/">http://www.alice.org/</a>

I have these in my delicious bookmarks - <a target="_blank" href="http://del.icio.us/dagza">http://del.icio.us/dagza</a> - but have no experience of them - <a target="_blank" href="http://www.kidsprogramminglanguage.com/">http://www.kidsprogramminglanguage.com/</a> and <a target="_blank" href="http://msdn2.microsoft.com/en-us/robotics/default.aspx">http://msdn2.microsoft.com/en-us/robotics/default.aspx</a>

Have fun!


--------------------------------------------------------------------------------

NRK says...

I'll recommend
Lego Robotics as first step
and Parallax Robotic Kits
as second step.

With the built-in programming language
for lego bots the kids could learn the
basics of programming like loops etc.
and afterwards they can try out
programming walking algorithms etc.
in the more complex parallax language.

Most children love building things,
so robotics is a good start...


--------------------------------------------------------------------------------

Piaget discovered that children develop in stages and that the transition between stages is often abrupt. I attempted to start my 12-year old son on Commodore 64 Basic with no results; the mental wiring simply wasn't there at his age. I did, however, discover the following:

1. He could understand simple BASIC programs long before he could write them;

2. He could modify BASIC programs long before he could start from scratch;

3. One day he woke up and without warning created complete programs as though it was second nature to him.

I had read an article years before in Psychology Today on Piaget and knew a little about mental development, but it was still amazing and delightful to see the jumps in mental and emotional complexity that occurred almost overnight in my teenage son. Once he could write in BASIC, it seemed that Pascal and then C came without any difficulty and without my help.

TomL


--------------------------------------------------------------------------------

Books
I learned BASIC when I was a kid through a great little book-- Let's Learn Basic: A Kids' Introduction to Basic Programming on the Commodore 64. It provided pictures and step-by-step instructions on how to program. I'd reccommend it. You can pick it up online for under 5 bucks.

--
   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 修改:·coolfantasy 于 Jul 30 12:16:30 修改本文·[FROM: 61.135.146.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 61.135.146.*]
 
【文章标题】：$符号与c语言 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20340 【创建时间】：2007-08-10 【作者】：wks 【评论】：5 【内容】：发信人: wks (cloverprince), 信区: SoftDesign
标  题: $符号与c语言
发信站: 北邮人论坛 (Fri Aug 10 18:11:10 2007), 站内

$这个符号在很多语言里都很重要。
在perl里面表示标量（scalar），
shell script、PHP里面表示任何变量。

但是似乎在c语言和c++里不常见$。
$这个符号在c/c++里面有什么意义么？
--
"I tried setting my hotmail password to penis. It said my password wasn't long enough. :("

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 58.207.152.*]
 
【文章标题】：一个自己写的猜数字的小游戏程序，有兴趣的看看吧 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20190 【创建时间】：2007-07-31 【作者】：Rukawa 【评论】：27 【内容】：发信人: Rukawa (4ever之飘在海上的雪), 信区: SoftDesign
标  题: 一个自己写的猜数字的小游戏程序，有兴趣的看看吧
发信站: 北邮人论坛 (Tue Jul 31 10:52:34 2007), 站内

猜数字这个游戏大家都玩过吧？
就是你脑袋里想个四位数字（四个数字不能相同），然后让别人猜
对方没猜一次，你就给他一个反馈信息，反馈信息是：你有X个数字猜对了，有Y个数字虽然猜对了，但数字的位置不对；
（EXAMPLE：你脑子里想的数字是2546，对方猜的是4527，那么你反馈的信息就是1 ，2）
对方根据你这个反馈信息继续猜，直到猜对为止

我写的这个程序，是让电脑来猜你想的数字，呵呵，大家有兴趣的话给测试一下：

PS：算法不是最好的，正在想如何才能让电脑用更少的次数猜出你所想的数字来！


<a href="/att/SoftDesign/0/20190/1039" target="_blank" color="blue">附件(2.8KB)  try.cpp</a>
--
[color=blue]花开了，然后又会凋零。星星是璀璨的，可那光芒也会消失
这个地球、太阳，这整个银河系，甚至这个宇宙，也会有死亡的时候
人的一生，和这些东西相比，简直就像是刹那间的事情
在这样的一个瞬间，人降生了
笑着、哭着、战斗、伤害、喜悦、悲伤、憎恶、爱
一切都是刹那间的邂逅，而最后都要归入死的永眠[/color]

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.42.126.*]

 
【文章标题】：终于完成了第一个成品小游戏 【文章地址】：https://bbs.byr.cn/article/SoftDesign/20198 【创建时间】：2007-08-01 【作者】：X22 【评论】：18 【内容】：发信人: X22 (X), 信区: SoftDesign
标  题: 终于完成了第一个成品小游戏
发信站: 北邮人论坛 (Wed Aug  1 07:42:27 2007), 站内

在师傅的耐心教导下,我终于完成了第一个成品
师傅叫我拿来让大家给些建议
第一次做希望大家多多支持

<a href="/att/SoftDesign/0/20198/326" target="_blank" color="blue">附件(573.6KB)  HGE.rar</a>
--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.192.*]

 
【文章标题】：C#中启动多个timer的问题 【文章地址】：https://bbs.byr.cn/article/SoftDesign/17005 【创建时间】：2007-04-23 【作者】：wiwi 【评论】：8 【内容】：发信人: wiwi (...), 信区: SoftDesign
标  题: C#中启动多个timer的问题
发信站: 北邮人论坛 (Mon Apr 23 21:28:52 2007), 站内

怎样在c#中启动多个timer?
不是说只是启动两个或者几个timer的问题，是想通过数组启动多个timer,然后不同的timer有不同的interval和触发事件。
测试代码如下：
//代码
using System;
using System.Timers;

namespace TimerTest
{
    class Class1
    {
    
        [STAThread]
        static void Main(string[] args)
        {
            TimerTest[] tt = new TimerTest[3];
            for(int i = 1; i &lt; 3; i++)
            {
                tt[i] = new TimerTest();
                tt[i].Timer1(i,i);
            }
        }
    }
        
    public class TimerTest
    {

        private static System.Timers.Timer aTimer = new System.Timers.Timer();
        private static string info;
        private static int a;
        public TimerTest()
        {
            
        }

        public void Timer1(int i, int a1)
        {
            a = a1;
            info = "This is the " + i.ToString() + "th timer";            
            aTimer.Interval = i*1000;
            aTimer.Elapsed += new System.Timers.ElapsedEventHandler(aTimer_Elapsed);
            aTimer.Enabled = true;
            while(a&lt;4);        
        }

        private void aTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
    
            Console.WriteLine(info);
            a++;
        }
    }
}
//end

现在输出为：
this is the 1th timer
this is the 1th timer
this is the 1th timer
this is the 2th timer
this is the 2th timer
但实际上想实现为：
this is the 1th timer
this is the 1th timer
this is the 2th timer
this is the 1th timer
this is the 2th timer
问题是只有运行完第一个循环後才会运行第二个循环，也就是说只有打印完timer 1之后才会去打印timer 2。想实现两个同时计时，不知道应该怎样实现？
--
miss wiwi


※ 修改:·wiwi 于 Apr 23 21:30:05 修改本文·[FROM: 59.64.156.*]
※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.156.*]

<a href="/att/SoftDesign/0/17005/1977" target="_blank" color="blue">附件(621.1KB)  1.bmp</a> 
【文章标题】： MIT开放课件 (转载) 【文章地址】：https://bbs.byr.cn/article/SoftDesign/17158 【创建时间】：2007-04-28 【作者】：coolfantasy 【评论】：0 【内容】：发信人: coolfantasy (Cool), 信区: SoftDesign
标  题:  MIT开放课件
发信站: 北邮人论坛 (Sat Apr 28 12:06:39 2007), 站内

【 以下文字转载自 StudyShare 讨论区 】
发信人: coolfantasy (Cool), 信区: StudyShare
标  题:  MIT开放课件
发信站: 北邮人论坛 (Sat Apr 28 12:05:40 2007), 站内

http://www.core.org.cn/OcwWeb/index.htm
--

   欢迎来到人文艺术分区—摄影版   (Photo)                      ID:coolfantasy 
                                                                              
   欢迎访问学术科技分区—信息安全 (Security)                                  
                                                                              
   MD5(coolfantasy) = e91424cd260758e65915170633d1a2fd                        


※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 211.99.222.*]
 
【文章标题】：[原创][测试]毕设的简陋preview版本 【文章地址】：https://bbs.byr.cn/article/SoftDesign/16957 【创建时间】：2007-04-22 【作者】：Neverwinter 【评论】：12 【内容】：发信人: Neverwinter (nez@Atlantis), 信区: SoftDesign
标  题: [原创][测试]毕设的简陋preview版本
发信站: 北邮人论坛 (Sun Apr 22 21:49:35 2007), 站内

毕业设计做了一半，现在把已经完成的部分show出来 XDD

由于很多功能都还没有完善，所以请多多包涵


我的毕设是做一个eclipse的插件，主要是用来辅助管理Hibernate的映射配置文件(Hibernate Mapping File)
下面的附件就是我已经完成的部分打包，直接解压到ecl目录下就可以使用了
我的插件是在jdk 1.5，ecl 3.2下开发的，所以测试的环境最好也是jdk 1.5 &amp; ecl 3.2

<a href="/att/SoftDesign/0/16957/2672" target="_blank" color="blue">附件(196.6KB)  plugin.zip</a>
插件提供了两个窗口，一个是XML的编辑器，一个是图形化的hbm文件配置管理界面。
目前，XML编辑器的功能基本上都做好了，就是显示的颜色还要改。 -___-!!
而图形化的hbm文件配置管理界面的话，目前也就仅仅做了个界面出来而已，有些东西还没有添加上去，很多功能也还没有做。简单来说，就是目

前还没有Save功能，在那个界面下做的修改完全无效(:P)。另外还有一些功能也还在计划中...... =v=!!


这是我提供的一个例子项目，可以用来测试一下我的插件

<a href="/att/SoftDesign/0/16957/203967" target="_blank" color="blue">附件(9.6KB)  Sample.rar</a>
如果不用我提供的项目，用别的Hibernate映射配置文件来测试也可以，不过会有些问题。
我目前是用jdom来分析xml文件的，如果hbm的文件头中有包含指向dtd文件的位置的话，如
[quote]&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;[/quote]
jdom就会到指定的地方去查找dtd文件，要花不少时间。如果网络速度快、能访问外网到还好，网络环境差的话，eclipse就死在那里了。
以后要看看怎样禁止掉查找dtd文件的这个过程，不过目前来说，还是最好将DOCTYPE去掉，反正那个不影响测试的功能。



下面是测试的方法和过程

将压缩包直接解压到eclipse的目录下

启动eclipse，如果ecl已经能正确认出插件的话，在help菜单下Software Updates-&gt;Manage Configuration中，可以看到本插件（临时乱起的一

个名字，orz）
如下图:

<a target="_blank" href="/att/SoftDesign/0/16957/213772"><img border="0" title="01.JPG" src="/att/SoftDesign/0/16957/213772" alt="01.JPG" class="resizeable"></a>



将Sample解压到ecl的workspace，import进去。

打开Sample，选取其中一个.hbm.xml文件，鼠标右键选取Open With -&gt; Hibernate Config File Parse Editor
如下图:

<a target="_blank" href="/att/SoftDesign/0/16957/258420"><img border="0" title="02.JPG" src="/att/SoftDesign/0/16957/258420" alt="02.JPG" class="resizeable"></a>



打开后，看到如下画面:

<a target="_blank" href="/att/SoftDesign/0/16957/381885"><img border="0" title="03.JPG" src="/att/SoftDesign/0/16957/381885" alt="03.JPG" class="resizeable"></a>


注意到主窗口其实有两个标签页，第一个页面（也就是默认显示的页面）是一个XML的编辑器。
选取第二个页面，就看到如下画面:

<a target="_blank" href="/att/SoftDesign/0/16957/565841"><img border="0" title="04.JPG" src="/att/SoftDesign/0/16957/565841" alt="04.JPG" class="resizeable"></a>


点击左半边的部分，可以展开各个元素
选取某个元素，就可以在右边看到对应的一些属性，可以在右边修改这些属性，如下图:
需要说明的是，目前只有many-to-one的属性是全部做出来了，其他的只是做出了部分属性

<a target="_blank" href="/att/SoftDesign/0/16957/677110"><img border="0" title="05.JPG" src="/att/SoftDesign/0/16957/677110" alt="05.JPG" class="resizeable"></a>



--
[QMD No. 1]
看 C++ Primer 发现自己知道的太少
看 The C++ Programming Language 发现自己清楚的太少
看 Effective C++ 发现自己明白的太少
看 Ruminations on C++ 发现自己思考的太少
看 Modern C++ Design 发现自己梦想的太少


※ 修改:·Neverwinter 于 Apr 22 21:53:26 修改本文·[FROM: 59.64.196.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.196.*]
 
【文章标题】：[zt]编程高手的基础素养 【文章地址】：https://bbs.byr.cn/article/SoftDesign/17262 【创建时间】：2007-05-02 【作者】：littleboy 【评论】：0 【内容】：发信人: littleboy (要做到，不在技术版发贴。), 信区: SoftDesign
标  题: [zt]编程高手的基础素养
发信站: 北邮人论坛 (Wed May  2 03:07:51 2007), 站内

http://www.javaresearch.org/faq/thread.jsp?thread=38473
 
世界上并没有成为高手的捷径，但一些基本原则是可以遵循的。  

1、扎实的基础  


　　数据结构、离散数学、编译原理，这些是所有计算机科学的基础，如果不掌握它们，很难写出高水平的程序。程序人人都会写，但当你发现写到一定程度很难再提高的时候，就应该想想是不是要回过头来学学这些最基本的理论。不要一开始就去学OOP，即使你再精通OOP，遇到一些基本算法的时候可能也会束手无策。因此多读一些计算机基础理论方面的书籍是非常有必要的。  



2、丰富的想像力  



　　不要拘泥于固定的思维方式，遇到问题的时候要多想几种解决问题的方案，试试别人从没想过的方法。丰富的想像力是建立在丰富的知识的基础上，除计算机以外，多涉猎其他的学科，比如天文、物理、数学等等。开阔的思维对程序员来说很重要。  



3、最简单的是最好的  



　　这也许是所有科学都遵循的一条准则，复杂的质能转换原理在爱因斯坦眼里不过是一个简单得不能再简单的公式：E=mc2。简单的方法更容易被人理解，更容易实现，也更容易维护。遇到问题时要优先考虑最简单的方案，只有简单方案不能满足要求时再考虑复杂的方案。  



4、不钻牛角尖  



　　当你遇到障碍的时候，不妨暂时远离电脑，看看窗外的风景，听听轻音乐，和朋友聊聊天。当我遇到难题的时候会去玩游戏，当负责游戏的那部分大脑细胞极度亢奋的时候，负责编程的那部分大脑细胞就得到了充分的休息。当重新开始工作的时候，我会发现那些难题现在竟然可以迎刃而解。  



　　5、对答案的渴求  



　　人类自然科学的发展史就是一个渴求得到答案的过程，即使只能知道答案的一小部分也值得我们去付出。只要你坚定信念，一定要找到问题的答案，你才会付出精力去探索，即使最后没有得到答案，在过程中你也会学到很多东西。  



　　6、多与别人交流  



　　三人行必有我师，也许在一次和别人不经意的谈话中，就可以迸出灵感的火花。多上上网，看看别人对同一问题的看法，会给你很大的启发。  



　　7、良好的编程风格  



　　注意养成良好的习惯，代码的缩进编排，变量的命名规则要始终保持一致。大家都知道如何排除代码中错误，却往往忽视了对注释的排错。注释是程序的一个重要组成部分，它可以使你的代码更容易理解，而如果代码已经清楚地表达了你的思想，就不必再加注释了，如果注释和代码不一致，那就更加糟糕。  



　　8、韧性和毅力  



　　这也许是“高手”和一般程序员最大的区别。高手们并不是天才，他们是在无数个日日夜夜中磨炼出来的。成功能给我们带来无比的喜悦，但过程却是无比的枯燥乏味。你不妨做个测试，找个10000以内的素数表，把它们全都抄下来，然后再检查三遍，如果能够不间断地完成这一工作，你就可以满足这一条 
 

--
罗永浩教导我们，你可以说一个人做的事傻B，但不能说这个人傻B


※ 修改:·littleboy 于 May  2 03:08:10 修改本文·[FROM: 59.64.220.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 59.64.220.*]
 
【文章标题】：[求助]关于C++中函数参数是类的传递方式 【文章地址】：https://bbs.byr.cn/article/SoftDesign/16482 【创建时间】：2007-04-07 【作者】：hman 【评论】：13 【内容】：发信人: hman (oy), 信区: SoftDesign
标  题: [求助]关于C++中函数参数是类的传递方式
发信站: 北邮人论坛 (Sat Apr  7 18:39:28 2007), 站内

本人突然对函数参数的 传递 和 返回值的 传递 产生了 兴趣。先发一贴来问问。

下面的是我的源代码
#include &lt;iostream&gt;
using namespace std;

class X
{
public:
    int a;
    void modify(){a++;}
};

void f(X x)
{
    x.modify();
}

int main()
{
    X a;
    f(a);
    return 0;
}

下面的是我从2003里反汇编里挖出来的东东。
int main()
{
00411A70  push        ebp  
00411A71  mov         ebp,esp 
00411A73  sub         esp,0D8h 
00411A79  push        ebx  
00411A7A  push        esi  
00411A7B  push        edi  
00411A7C  lea         edi,[ebp-0D8h] 
00411A82  mov         ecx,36h 
00411A87  mov         eax,0CCCCCCCCh 
00411A8C  rep stos    dword ptr [edi] 
00411A8E  mov         byte ptr [ebp-0D1h],0 
    X a;
    f(a);
00411A95  cmp         byte ptr [ebp-0D1h],0 
00411A9C  jne         main+3Bh (411AABh) 
00411A9E  push        411AF2h 
00411AA3  call        @ILT+565(__RTC_UninitUse) (41123Ah) 
00411AA8  add         esp,4 
00411AAB  mov         eax,dword ptr [a] 
00411AAE  push        eax  
00411AAF  call        f (41151Eh) 
00411AB4  add         esp,4 
    return 0;
00411AB7  xor         eax,eax 
}

这个反汇编我看不太懂，还请哪位高手指点一下。


我想知道的是，在函数参数是一个对象的时候，编译器是不是将整个类的所有东西都压到了堆栈里？还是只是压了一个指针？


--

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.180.*]
 
【文章标题】：【Origin】某日的无聊产物，拿出来晾晾——Windy Text Reader 【文章地址】：https://bbs.byr.cn/article/SoftDesign/17046 【创建时间】：2007-04-24 【作者】：TimNew 【评论】：12 【内容】：发信人: TimNew (米良), 信区: SoftDesign
标  题: 【Origin】某日的无聊产物，拿出来晾晾——Windy Text Reader
发信站: 北邮人论坛 (Tue Apr 24 22:44:24 2007), 站内

一个读英文的东东！
运行环境：.Net 2.0 + Microsoft Speech API
使用方法：
1.Interactive Mode: 直接打开，在提示符下输入的字符会被读出来
2.File Mode: 拖几个文本文件扔到主程序上，文本内容会被读出来

Known Issues:
1. Chinese Have NOT been Supported
2. Sometimes Initialize Speech engine consume a lot of time!
3. A lot of other bugs haven't been figure out!

主程序

<a href="/att/SoftDesign/0/17046/714" target="_blank" color="blue">附件(41.5KB)  TextReader.rar</a>
此为一个测试文本

<a href="/att/SoftDesign/0/17046/43194" target="_blank" color="blue">附件(298B)  Test.txt</a>
--
Release Your Passion,
To Realize Your Potential

※ 来源:·北邮人论坛 <a target="_blank" href="http://forum.byr.edu.cn">http://forum.byr.edu.cn</a>·[FROM: 59.64.211.*]

 
【文章标题】：Consolas字体，有需要的就下载吧 【文章地址】：https://bbs.byr.cn/article/SoftDesign/37939 【创建时间】：2010-04-05 【作者】：Thinker 【评论】：2 【内容】：发信人: Thinker (思想者), 信区: SoftDesign
标  题: Consolas字体，有需要的就下载吧
发信站: 北邮人论坛 (Mon Apr  5 17:25:28 2010), 站内


Consolas 字体

<a href="/att/SoftDesign/0/37939/441" target="_blank" color="blue">附件(3.9MB)  ConsolasInstaller.7z</a>

--
---------------------------
       有所为有所不为
---------------------------

※ 修改:·Thinker 于 Apr  5 17:25:48 2010 修改本文·[FROM: 118.229.160.*]
※ 来源:·北邮人论坛 forum.byr.edu.cn·[FROM: 118.229.160.*]

 
